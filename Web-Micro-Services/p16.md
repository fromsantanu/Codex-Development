
# Chapter 16: Connecting Microservices

## Introduction

Microservices are like **small shops in a marketplace**.
Each shop does its own work, but sometimes they need to **talk to each other**.

For example:

* The **Orders Service** asks the **User Service**: “Is this user real?”
* The **Orders Service** asks the **Inventory Service**: “Is this item available?”
* The **Orders Service** calls the **Notification Service**: “Please send confirmation.”

To make all this smooth, we use **internal APIs** and sometimes an **API Gateway**.

This chapter explains how microservices communicate safely and simply.

---

## Concepts

### **Internal APIs**

* Private APIs used only by your services.
* Not exposed to the public internet.
* Think of them like *staff-only phone numbers* between shops.

### **API Gateway**

* A single entry point for all external users.
* Think of it as the **main gate** of the marketplace.
* Customers enter through the gate; inside, shops talk among themselves.

### **Shared Database vs Separate Databases**

**Separate DBs (recommended for microservices):**

* Each service has its own database.
* Like each shop having its own storage room.
* Services don’t fight over data.

**Shared DB (not recommended):**

* All services use one big database.
* Like all shops using the same warehouse.
* Easy in the beginning, but leads to conflicts and dependency problems.

---

## Step-by-step Explanation

### **1. How services talk using internal APIs**

Services call each other using simple HTTP requests.

Example:
Orders → Inventory
Orders → User
Orders → Notification

This communication is controlled, simple, and safe.

---

### **2. Why internal APIs are important**

* Keeps the system modular
* Saves time (services don’t rewrite the same logic)
* Allows replacement of one service without touching others

Example:
If you rebuild User Service, Orders Service still works because it calls the API, not the internal code.

---

### **3. Why we use an API Gateway**

Without a gateway, the user must know:

* Auth URL
* Product URL
* Orders URL
* Notification URL

This is confusing.

Gateway solves it:

```
User → API Gateway → (routes request to correct service)
```

The gateway can also:

* Check tokens
* Block bad requests
* Handle logging
* Combine responses from multiple services

---

### **4. Shared DB vs Separate DB**

Use simple real-life examples.

#### **Separate DB (microservices way)**

```
User Service → user.db
Inventory Service → inventory.db
Orders Service → orders.db
Notification Service → notify.db
```

Benefits:

* No conflicts
* Each team owns its database
* Easier to scale
* Easier to replace one service

#### **Shared DB (monolithic style)**

```
All services → one big database
```

Problems:

* Harder to change one service
* More locking and conflicts
* One small mistake can break everything
* Not truly independent

So for microservices, **separate DB** is the simple, safe option.

---

## Simple Diagram (Text Format)

### **Flow with Internal APIs**

```
Orders Service
   |--> User Service (check user)
   |--> Inventory Service (check stock)
   `--> Notification Service (send SMS/email)
```

### **Flow with API Gateway**

```
        +--------------------+
        |     API Gateway    |
        +---------+----------+
                  |
     +------------+-------------+
     |            |             |
User Service   Inventory     Orders
                   |
             Notification
```

---

## Code Examples

### **Internal API call example (Orders → User)**

```python
import requests

USER_URL = "http://user-service/users/"

def verify_user(user_id):
    response = requests.get(USER_URL + user_id)
    return response.json()
```

### **Internal API call (Orders → Inventory)**

```python
STOCK_URL = "http://inventory-service/stock/"

def check_stock(item_id):
    return requests.get(STOCK_URL + item_id).json()
```

### **Gateway Example (FastAPI simple router)**

```python
from fastapi import FastAPI
import requests

app = FastAPI()

@app.get("/products")
def products():
    return requests.get("http://product-service/products").json()
```

This is a **very basic gateway**, but it helps learners understand the idea.

---

## How Codex Helps

Codex can:

### ✓ Create all service-to-service API call code

Just ask:

```
"Codex, add internal API calls in Orders Service to check user and stock."
```

### ✓ Generate gateway routes automatically

Example:

```
"Codex, generate a FastAPI gateway that forwards routes to user, inventory, and orders services."
```

### ✓ Fix communication issues

If a service can’t reach another, Codex can:

* Detect wrong URLs
* Fix wrong request data
* Add missing headers
* Suggest retries/timeouts

### ✓ Write database code for separate DBs

Codex saves time by generating:

* SQLAlchemy models
* Alembic migrations
* CRUD functions

---

## Small Exercise

Create a simple design (text diagram) showing:

1. A **User Service**
2. An **Inventory Service**
3. An **Orders Service**
4. A **Notification Service**
5. An **API Gateway** in front

Draw:

* Who talks to whom
* What data moves

Then write one small API call code where Orders Service checks stock.

