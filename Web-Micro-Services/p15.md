# Chapter 15: Building Independent Microservices

## Introduction

When we say **independent microservices**, think of **four small shops** inside a town.
Each shop does one job only:

* **User Service** → Handles user accounts
* **Inventory Service** → Manages stock
* **Orders Service** → Handles buying and selling
* **Notification Service** → Sends messages (email/SMS)

Each shop works on its own, has its own “storage room” (database), and can run even if the others are down for some time.

## Concepts

* **Independence** → Each service has its own code, database, and responsibilities.
* **Single Responsibility** → One service = one job (just like one shop sells clothes, another sells groceries).
* **Loose Coupling** → Services talk to each other but do not depend heavily on each other.
* **REST API** → The simple way they talk using URLs.
* **Database per service** → No sharing databases; each service owns its data.

## Step-by-step Explanation

### 1. Create separate folders

Each microservice lives in its own folder.

```
services/
 ├── user-service/
 ├── inventory-service/
 ├── orders-service/
 └── notification-service/
```

### 2. Give each service its own FastAPI app

All four apps run independently.

Example:

* `user-service/main.py`
* `inventory-service/main.py`
* `orders-service/main.py`
* `notification-service/main.py`

### 3. Give each service its own database

This keeps them independent.

Examples:

* user.db
* inventory.db
* orders.db
* notifications.db

### 4. Define simple APIs for each service

Each service exposes only what others need.

### 5. Connect services using simple HTTP calls

For example:

* Orders Service calls User Service to check if a user exists
* Orders Service calls Inventory Service to reduce stock
* Orders Service calls Notification Service to send order confirmation

### 6. Make services replaceable

Because they’re separate, you can update or redeploy one service without touching the others.

## Code Examples

### User Service (FastAPI)

```python
from fastapi import FastAPI

app = FastAPI()

users = {"u1": {"name": "Santanu"}}

@app.get("/users/{user_id}")
def get_user(user_id: str):
    return users.get(user_id, {"error": "Not found"})
```

### Inventory Service

```python
from fastapi import FastAPI

app = FastAPI()

inventory = {"item1": 12, "item2": 5}

@app.get("/stock/{item_id}")
def check_stock(item_id: str):
    return {"available": inventory.get(item_id, 0)}
```

### Orders Service (calling other services)

```python
import requests
from fastapi import FastAPI

app = FastAPI()

USER_URL = "http://user-service/users/"
INV_URL = "http://inventory-service/stock/"
NOTIFY_URL = "http://notification-service/send"

@app.post("/order")
def place_order(user_id: str, item_id: str):
    user = requests.get(USER_URL + user_id).json()
    stock = requests.get(INV_URL + item_id).json()["available"]

    if "error" in user:
        return {"error": "User not found"}

    if stock <= 0:
        return {"error": "Out of stock"}

    # reduce stock simulated
    requests.post(NOTIFY_URL, json={"user_id": user_id, "msg": "Order placed"})

    return {"message": "Order successful"}
```

### Notification Service

```python
from fastapi import FastAPI

app = FastAPI()

@app.post("/send")
def send_message(user_id: str, msg: str):
    return {"status": "sent", "to": user_id, "message": msg}
```

## How Codex Helps

Codex can:

### ✓ Create all microservice folders and starter code

You can ask:

```
"Codex, create four microservices: user, inventory, orders, notification — each with its own FastAPI app."
```

### ✓ Add new endpoints quickly

Example:

```
"Codex, add a POST /create-user endpoint to user-service with validation."
```

### ✓ Generate SQLAlchemy models for each service

No need to write repetitive code.

### ✓ Auto-generate HTTP calls between services

Codex can write neat request code for you.

### ✓ Debug service-to-service communication

For example:

* Wrong URLs
* Wrong payload shape
* Connection refused
* Timeout

### ✓ Create docker-compose files

Codex can set up all microservices to run together.

## Small Exercise

Create the following:

1. A simple **User Service** with an API:

   * `GET /users/{id}`
   * `POST /users`

2. A simple **Inventory Service**:

   * `GET /items/{id}`
   * `POST /items`

3. Draw a small text diagram showing how:

   * Orders Service will call both
   * Notification Service will send messages


