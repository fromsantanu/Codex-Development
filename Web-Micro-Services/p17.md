# Chapter 17: Implementing Simple Event-Based Communication

## Introduction

So far, our microservices have been talking to each other by **directly calling APIs** (like one shop phoning another shop).
But sometimes we want a more **indirect, relaxed way of communication**.

Think of it like this:
If the **Orders Service** finishes an order, it can simply **announce**:

> “Order completed!”

Whoever is interested (Notification Service, Analytics Service, etc.) will listen and act.

This is called **event-based communication**.
It makes the system smoother because services don’t wait for each other.

In this chapter, we will use two simple methods:

* Redis Pub/Sub (very easy introduction)
* Simulating events using a “jobs” table in a database

---

## Concepts

* **Event** → A simple message describing something that happened.
  Example: “order_created”, “payment_success”, “user_registered”

* **Publisher** → The service that sends the event.
  Example: Orders Service sends “order_created”

* **Subscriber** → The service that listens and reacts.
  Example: Notification Service listens and sends confirmation.

* **Pub/Sub** → Publish / Subscribe method
  Like a radio station broadcasting news, and listeners tuning in.

* **Job Table** (database method)
  You store tasks in a table, and another service picks them up later.

---

## Step-by-step Explanation

### 1. Why use events?

Direct API calls can create tight dependency:

* If Notification Service is down → Orders Service might fail.

Events solve this:

* Orders Service just announces an event.
* Notification Service can pick it up whenever it is ready.

### 2. Redis Pub/Sub (very easy explanation)

Redis is like a **small postman** running in memory.

* A publisher sends a message to a *channel* (like a radio frequency).
* Subscribers listen on that channel.
* Whoever is listening receives it instantly.

### 3. Jobs Table (database method)

If you don’t want Redis, you can simulate events.

* Orders Service inserts a “job” into a table:

  * job_type: "order_created"
  * data: {"user_id": ..., "item_id": ...}

* Notification Service checks the table every few seconds:

  * If a job exists → process → mark as done.

This is simple but works very well for small systems.

---

## Simple Diagrams

### **Redis Pub/Sub approach**

```
Orders Service ---- publish ---> Redis Channel ----> Notification Service (listens)
```

### **Jobs Table approach**

```
Orders Service ---> jobs table ---> Notification Service (poll + process)
```

---

## Code Examples

### 1. Redis Pub/Sub

Simple Python example (very beginner-friendly).

#### Publisher (Orders Service)

```python
import redis
import json

r = redis.Redis(host="localhost", port=6379)

event = {
    "event": "order_created",
    "user_id": "u1",
    "item_id": "item1"
}

r.publish("orders_channel", json.dumps(event))
```

#### Subscriber (Notification Service)

```python
import redis
import json

r = redis.Redis(host="localhost", port=6379)
pubsub = r.pubsub()
pubsub.subscribe("orders_channel")

print("Listening for events...")

for message in pubsub.listen():
    if message["type"] == "message":
        data = json.loads(message["data"])
        print("Received:", data)
        # send SMS/email here
```

---

### 2. Simulated Events with Jobs Table

#### Create jobs table

```sql
CREATE TABLE jobs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    job_type VARCHAR(50),
    payload JSON,
    status VARCHAR(20) DEFAULT 'pending'
);
```

#### Publisher (Orders Service)

```python
from sqlalchemy import insert
from database import jobs_table, engine

def publish_order_event(order):
    with engine.connect() as conn:
        conn.execute(
            insert(jobs_table).values(
                job_type="order_created",
                payload=order
            )
        )
```

#### Subscriber (Notification Service)

```python
from sqlalchemy import select, update
from database import jobs_table, engine

def process_jobs():
    with engine.connect() as conn:
        pending_jobs = conn.execute(
            select(jobs_table).where(jobs_table.c.status == "pending")
        )

        for job in pending_jobs:
            print("Processing job:", job.payload)
            # send notification here

            conn.execute(
                update(jobs_table)
                .where(jobs_table.c.id == job.id)
                .values(status="done")
            )
```

This method is extremely simple and works without any new tools.

---

## How Codex Helps

Codex can:

### ✓ Generate Publisher and Subscriber code

You can say:

```
"Codex, write a Redis pub/sub publisher for order_created event."
```

### ✓ Create SQLAlchemy job tables

Codex can make full models, migrations, and CRUD functions.

### ✓ Generate polling logic

Ask:

```
"Codex, generate a job processor that runs every 5 seconds."
```

### ✓ Debug event processing

If events are stuck, Codex can:

* check Redis connection
* check job table queries
* check JSON formatting
* add logs for tracing events

### ✓ Create docker-compose setup for Redis

One command and everything is connected.

---

## Small Exercise

### Try one of the following:

**Option A: Redis**

1. Create a publisher that sends a message:
   `"user_registered"`
2. Create a subscriber that prints the message.

**Option B: Job Table**

1. Create a `jobs` table.
2. Insert a pending job manually.
3. Write a Python script that reads and processes the job.


