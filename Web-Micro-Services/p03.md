# **Chapter 3: Why Microservices?**

## **Introduction**

Imagine a **big restaurant** that serves thousands of customers a day.
If everything—starter, main course, dessert, billing, delivery—runs from **one huge kitchen**, things become slow and messy.

A better approach is to have **many small kitchens**, each handling a specific type of work.
This is exactly how **microservices** work in software.

Instead of one big application doing everything, we break it into many small services.
Each service handles **one responsibility**, works independently, and can grow separately.

## **Concepts**

* **Monolith:** One large application doing everything.
* **Microservices:** Many small, independent services working together.
* **Decoupling:** Separating responsibilities so systems do not depend too much on each other.
* **Scaling:** Increasing capacity when demand increases.

## **Step-by-step Explanation**

### **1. The Big Restaurant Analogy (Monolith)**

Imagine a big restaurant with **one giant kitchen**:

* All cooks share the same space.
* A problem in one corner slows down the whole kitchen.
* Adding more cooks creates **confusion** and **overcrowding**.
* If the kitchen shuts down, **everything stops**.

This is a **monolithic application** — one system doing all tasks:

* user login
* order management
* payments
* notifications
* reporting

When it grows, it becomes difficult to maintain.

---

### **2. Many Small Kitchens (Microservices)**

Now imagine the restaurant splits into **separate kitchens**:

* Starter kitchen
* Main course kitchen
* Dessert kitchen
* Delivery packing station
* Billing counter

Each kitchen works **independently**, using its own staff, tools, and workflow.

This is **microservices architecture**.

Each service in a system becomes like its own mini-team:

* user-service
* order-service
* payment-service
* notification-service

If the payment system fails, the rest still work.

---

### **3. Pros (Benefits) of Microservices**

#### **A. Each service is independent**

Just like each kitchen can run alone, each service can:

* be developed
* be deployed
* be scaled
* be fixed
* be restarted
  … without affecting others.

#### **B. Easy to scale**

If desserts are in high demand, you only scale the dessert kitchen.

In microservices:
If your “order service” gets heavy traffic, scale only that service.

#### **C. Faster development**

Different teams can work **in parallel** without blocking each other.

#### **D. Technological freedom**

One service may use Python, another Node.js, another Go — no restrictions.

#### **E. Better fault isolation**

If one service fails, the whole system doesn’t collapse.

---

### **4. Cons (Disadvantages) of Microservices**

#### **A. More moving parts**

Instead of one system, you now manage 10–20 smaller systems.

#### **B. Network complexity**

Services must communicate with each other through APIs.
If communication breaks, problems happen.

#### **C. Harder to test**

Testing one big system is simpler than testing many tiny systems.

#### **D. Requires DevOps maturity**

Microservices need:

* containers
* CI/CD
* monitoring
* logging
* service discovery

This can be heavy for small teams.

#### **E. Overkill for small projects**

A small app with simple features doesn’t need microservices.

---

### **5. When Should We Avoid Microservices?**

Avoid microservices when:

#### ✔ Your project is small

Example:
A simple student management system with 2–3 screens.

#### ✔ Your team is small

Microservices need coordinated teams; 1–2 developers may struggle.

#### ✔ Features are not too complex

If all features fit easily in one neat codebase, use a monolith.

#### ✔ You are early in development

Start with monolith → if the project grows → break into microservices later.

#### ✔ You don’t have strong DevOps setup

Without automation tools, managing many services becomes frustrating.

---

## **Code Examples**

A **monolith** example:

```python
# main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/users")
def users():
    return {"users": []}

@app.get("/orders")
def orders():
    return {"orders": []}

@app.get("/payments")
def payments():
    return {"payments": []}
```

A **microservice** example (order-service):

```python
# order_service/main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/orders")
def get_orders():
    return {"orders": ["order1", "order2"]}
```

Another microservice (payment-service):

```python
# payment_service/main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/payments")
def get_payments():
    return {"payments": ["paymentA"]}
```

Each service runs independently.

---

## **How Codex Helps**

### ✔ Generate microservice folders

Prompt:

```
Create a folder structure for three microservices: user, order, payment. Use FastAPI and MySQL.
```

### ✔ Create services quickly

Prompt:

```
Generate a new FastAPI service for payments with routes: create, list, delete.
```

### ✔ Add features gradually

Prompt:

```
Add a notification microservice that sends email when an order is placed.
```

### ✔ Convert a monolith to microservices

Prompt:

```
Split this monolithic FastAPI app into three microservices: auth, order, product. Suggest folder structures.
```

### ✔ Debug issues

Prompt:

```
My microservices are not communicating. Here are my logs. What is wrong?
```

Codex will help trace the error, find missing routes, or fix configurations.

---

## **Small Exercise**

Create two small microservices:

1. **user-service**

   * GET `/users`

2. **order-service**

   * GET `/orders`

Then ask Codex:

```
Now create an API gateway that calls both services and returns a combined response.
```

---

