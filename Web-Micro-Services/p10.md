# **Chapter 10: Service 1 — User Authentication**

## **Introduction**

In any web application, we need a way to know *who* is using the system.
Just like a security guard checks ID cards before allowing someone into a building, your backend must check a user’s identity before giving access to certain features.

In this chapter, we will build a simple **User Authentication Service** using FastAPI.
We will cover:

* User registration
* User login
* JWT tokens
* Simple role-based access (Admin/User)

Think of JWT like a **digital ID card** that users carry after logging in.

---

## **Concepts**

* **User Registration**
  A new user creates an account by giving basic details (name, email, password).

* **Password Hashing**
  We never store plain text passwords.
  Hashing = storing a scrambled version of the password.

* **JWT (JSON Web Token)**
  A small string given to the user after login.
  It works like a temporary pass that proves identity.

* **Login**
  User enters email + password → system verifies → returns JWT token.

* **Role-based Access**
  Each user has a role (e.g., “admin”, “user”).
  Some API routes can be allowed only for admins.

---

## **Step-by-step Explanation**

### **1. Register a new user**

* User sends name, email, password.
* Password is converted into a hashed form.
* Save user in the database with a default role (“user”).

### **2. Login and generate JWT**

* User enters email + password.
* Backend checks if user exists.
* Backend checks if password matches (using the hashed version).
* If correct → Generate JWT token with:

  * user_id
  * email
  * role
  * expiry time

### **3. Use JWT to access protected routes**

* Every protected API checks:

  * Is token valid?
  * Has it expired?
  * Does user have the required role?

### **4. Simple role protection**

Example:

* `/admin-only` → Only admins
* `/profile` → Any logged-in user

---

## **Code Examples**

### **User model (SQLAlchemy)**

```python
from sqlalchemy import Column, Integer, String
from database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    email = Column(String, unique=True, index=True)
    password_hash = Column(String)
    role = Column(String, default="user")
```

### **Password hashing**

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str):
    return pwd_context.hash(password)

def verify_password(plain, hashed):
    return pwd_context.verify(plain, hashed)
```

### **Generate JWT**

```python
from datetime import datetime, timedelta
from jose import jwt

SECRET_KEY = "your_secret_here"
ALGORITHM = "HS256"

def create_token(data: dict):
    to_encode = data.copy()
    to_encode["exp"] = datetime.utcnow() + timedelta(hours=1)
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
```

### **Registration API**

```python
@app.post("/register")
def register(user: UserCreate, db: Session = Depends(get_db)):
    hashed = hash_password(user.password)
    new_user = User(name=user.name, email=user.email, password_hash=hashed)
    db.add(new_user)
    db.commit()
    return {"message": "User registered successfully"}
```

### **Login API**

```python
@app.post("/login")
def login(form: LoginForm, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == form.email).first()
    if not user or not verify_password(form.password, user.password_hash):
        raise HTTPException(status_code=400, detail="Invalid credentials")

    token = create_token({"id": user.id, "email": user.email, "role": user.role})
    return {"access_token": token}
```

### **Role-based access**

```python
def require_admin(token_data):
    if token_data.role != "admin":
        raise HTTPException(status_code=403, detail="Admins only")

@app.get("/admin-area")
def admin_area(token_data = Depends(decode_jwt)):
    require_admin(token_data)
    return {"message": "Welcome Admin"}
```

---

## **How Codex Helps**

Codex can help you:

### **1. Generate boilerplate code**

Ask:

```
Generate a FastAPI authentication service with:
- registration
- login
- JWT
- password hashing
- SQLAlchemy models
```

### **2. Create folder structure**

Ask:

```
Create a clean folder structure for an Auth microservice using FastAPI and SQLAlchemy.
```

### **3. Add new features**

Ask:

```
Add refresh tokens to my existing auth service.
```

### **4. Debug errors**

Ask:

```
Here is my JWT error. Fix it and explain the mistake.
```

### **5. Extend roles**

Ask:

```
Add support for multiple roles: admin, doctor, nurse, patient.
Update the authorization logic accordingly.
```

---

## **Small Exercise**

1. Add a new role called **“manager”** and create an API route `/manager-area` that only managers can access.
2. Create a `/me` endpoint that returns the logged-in user’s name and email from the JWT token.
3. Add token expiry of 2 hours instead of 1 hour.

---
