# **Chapter 11: Service 2 — Product/Item Management**

## **Introduction**

Every online shop, restaurant app, or inventory system needs a way to **store and manage products/items**.
Think of this service like the *store manager* who handles:

* Adding new items
* Updating details
* Removing items
* Showing item lists with filters

This chapter teaches you how to build a simple **Product/Item Management Service** using FastAPI.
You will learn:

* CRUD operations
* Input validation
* Pagination (showing items in pages)
* Search API

This service will later work as a building block in a complete microservice-based backend.

---

## **Concepts**

* **CRUD**
  Basic actions on data:

  * Create
  * Read
  * Update
  * Delete

* **Validation**
  Making sure user inputs are correct before saving (e.g., name not empty, price positive).

* **Pagination**
  Showing items in small chunks, like 10 items per page.
  This avoids sending huge lists.

* **Search API**
  Users can search items by name or category.

---

## **Step-by-step Explanation**

### **1. Create Product Model**

We store each item in a database:

* name
* description
* price
* stock
* category

### **2. Build CRUD APIs**

* `POST /products/` → add new product
* `GET /products/{id}` → get single product
* `PUT /products/{id}` → update product
* `DELETE /products/{id}` → delete product

### **3. Validate the data**

Examples:

* Name must not be empty
* Price must be greater than 0
* Stock must be 0 or more

Using Pydantic makes validation very easy.

### **4. Add Pagination**

Client requests:

```
/products?page=2&limit=10
```

Backend returns only items for page 2.

### **5. Add Search API**

Client sends:

```
/products/search?query=milk
```

Backend returns items containing the word “milk”.

---

## **Code Examples**

### **SQLAlchemy Model**

```python
from sqlalchemy import Column, Integer, String, Float
from database import Base

class Product(Base):
    __tablename__ = "products"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)
    description = Column(String)
    price = Column(Float)
    stock = Column(Integer)
    category = Column(String, index=True)
```

---

### **Pydantic Schemas**

```python
from pydantic import BaseModel, Field

class ProductCreate(BaseModel):
    name: str = Field(..., min_length=2)
    description: str
    price: float = Field(..., gt=0)
    stock: int = Field(..., ge=0)
    category: str

class ProductOut(BaseModel):
    id: int
    name: str
    description: str
    price: float
    stock: int
    category: str

    class Config:
        orm_mode = True
```

---

### **Create Product API**

```python
@app.post("/products", response_model=ProductOut)
def create_product(product: ProductCreate, db: Session = Depends(get_db)):
    new_item = Product(**product.dict())
    db.add(new_item)
    db.commit()
    db.refresh(new_item)
    return new_item
```

---

### **Get Single Product**

```python
@app.get("/products/{item_id}", response_model=ProductOut)
def get_product(item_id: int, db: Session = Depends(get_db)):
    product = db.query(Product).filter(Product.id == item_id).first()
    if not product:
        raise HTTPException(404, "Product not found")
    return product
```

---

### **Update Product**

```python
@app.put("/products/{item_id}", response_model=ProductOut)
def update_product(item_id: int, product: ProductCreate, db: Session = Depends(get_db)):
    db_product = db.query(Product).get(item_id)
    if not db_product:
        raise HTTPException(404, "Product not found")
    for key, value in product.dict().items():
        setattr(db_product, key, value)
    db.commit()
    db.refresh(db_product)
    return db_product
```

---

### **Delete Product**

```python
@app.delete("/products/{item_id}")
def delete_product(item_id: int, db: Session = Depends(get_db)):
    item = db.query(Product).get(item_id)
    if not item:
        raise HTTPException(404, "Product not found")
    db.delete(item)
    db.commit()
    return {"message": "Deleted"}
```

---

### **Pagination API**

```python
@app.get("/products")
def list_products(page: int = 1, limit: int = 10, db: Session = Depends(get_db)):
    skip = (page - 1) * limit
    products = db.query(Product).offset(skip).limit(limit).all()
    return products
```

---

### **Search API**

```python
@app.get("/products/search")
def search_products(query: str, db: Session = Depends(get_db)):
    results = db.query(Product).filter(Product.name.ilike(f"%{query}%")).all()
    return results
```

---

## **How Codex Helps**

### **1. Generate CRUD automatically**

Ask Codex:

```
Generate complete Product CRUD APIs using FastAPI and SQLAlchemy.
Include validation and pagination.
```

### **2. Help with model design**

```
Suggest an improved Product model for an e-commerce app.
```

### **3. Add search filters**

```
Add search by category and price range to my existing Product service.
```

### **4. Improve code**

```
Refactor my Product CRUD APIs to reduce repetition.
```

### **5. Debug errors**

```
Fix this SQLAlchemy error in my Product update API.
```

---

## **Small Exercise**

1. Add a new field **"brand"** to the product model and update all APIs.
2. Add new filters to search API:

   * minimum price
   * maximum price
   * category
3. Add sorting support:

   * price low → high
   * price high → low

---

