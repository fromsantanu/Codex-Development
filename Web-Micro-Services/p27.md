# Chapter 27: Clean Folder Structure

*(Show good vs bad structure)*

---

## Introduction

When we build backend applications, one of the biggest challenges is keeping the project clean and easy to understand.
Think of your project like a **house**:

* If everything is dumped in one room, you will struggle to find anything.
* But if you keep clothes in one cupboard, utensils in another, and books on a shelf, life becomes easier.

A **clean folder structure** makes your project easier to maintain, debug, and extend.
It also helps you explain your system to new team members quickly.

---

## Concepts

* **Bad folder structure:** Everything is mixed together. Hard to follow.
* **Good folder structure:** Clear separation of API routes, services, models, database, configuration, and utilities.
* **Separation of concerns:** Each part of the system has its own place.
* **Scalability:** A clean structure allows the project to grow without becoming messy.
* **Codex can reorganize or refactor your folder structure automatically.**

---

## Step-by-step Explanation

### 1. What Bad Structure Looks Like

A bad backend folder structure is like a kitchen where plates, vegetables, knives, and dustbin are all put on the same shelf.

Example of a messy project:

```
project/
│-- app.py
│-- routes.py
│-- db.py
│-- user.py
│-- product.py
│-- utils.py
│-- helper1.py
│-- helper2.py
│-- config.json
│-- test_user.py
│-- test_product.py
```

Problems:

* Hard to guess where API code is.
* Models, routes, and helpers are mixed.
* No clear rules for adding new files.
* Testing files are lying beside system files.

### 2. What Good Structure Looks Like

A good structure keeps related things together—like grouping all kitchen items in the kitchen.

Example clean structure for FastAPI + MySQL:

```
project/
│
├── app/
│   ├── main.py
│   ├── api/
│   │   ├── v1/
│   │   │   ├── user_routes.py
│   │   │   ├── product_routes.py
│   │   │   └── order_routes.py
│   │   └── __init__.py
│   │
│   ├── core/
│   │   ├── config.py
│   │   └── security.py
│   │
│   ├── db/
│   │   ├── base.py
│   │   ├── session.py
│   │   └── models/
│   │       ├── user_model.py
│   │       ├── product_model.py
│   │       └── order_model.py
│   │
│   ├── services/
│   │   ├── user_service.py
│   │   ├── product_service.py
│   │   └── order_service.py
│   │
│   ├── schemas/
│   │   ├── user_schema.py
│   │   ├── product_schema.py
│   │   └── order_schema.py
│   │
│   └── utils/
│       └── common.py
│
└── tests/
    ├── test_user.py
    ├── test_product.py
    └── test_order.py
```

Advantages:

* **Routes** → one place
* **Business logic (services)** → separate
* **Database models** → cleanly grouped
* **Schemas** → easy validation
* **Database connection** → isolated
* **Tests** → outside app folder

### 3. Why This Structure Works

* Easier to add new features.
* Easy for Codex to understand and generate new files.
* Other developers understand the system faster.
* Testing and debugging become simpler.

---

## Code Examples

### Example 1: A messy file (bad structure)

Everything in one place:

```python
# bad example
from fastapi import FastAPI
from sqlalchemy import Column, Integer, String
from database import session

app = FastAPI()

class User(Base):
    id = Column(Integer, primary_key=True)
    name = Column(String)

@app.get("/users")
def get_users():
    users = session.query(User).all()
    return users
```

### Example 2: A clean structure (good structure)

**models/user_model.py**

```python
from sqlalchemy import Column, Integer, String
from app.db.base import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    name = Column(String)
```

**services/user_service.py**

```python
from app.db.session import get_db
from app.db.models.user_model import User

def get_all_users(db):
    return db.query(User).all()
```

**api/v1/user_routes.py**

```python
from fastapi import APIRouter, Depends
from app.services.user_service import get_all_users
from app.db.session import get_db

router = APIRouter()

@router.get("/users")
def list_users(db = Depends(get_db)):
    return get_all_users(db)
```

Cleaner, easier to grow, easier to debug.

---

## How Codex Helps

Codex can assist you by:

### ✔ Generating a clean folder structure

Just request:

```
Create a clean FastAPI + MySQL folder structure with models, routes, schemas, services, and tests.
```

### ✔ Automatically moving messy code into correct folders

Ask:

```
Refactor my user.py file: separate model, service, and route into their correct folders.
```

### ✔ Creating new features cleanly

Example:

```
Add a new Order service with model, schema, service, and route. Follow the existing structure.
```

### ✔ Debugging structure mistakes

Ask:

```
Check if my folder structure follows best practices. Suggest improvements.
```

---

## Small Exercise

1. Look at your current backend project.
2. Compare it with the **bad structure** and **good structure** above.
3. Rearrange your folders into the following sections:

   * api/
   * services/
   * models/
   * schemas/
   * db/
   * utils/
   * tests/
4. Ask Codex:
   **“Refactor my project into this structure. Generate missing files if needed.”**

---

