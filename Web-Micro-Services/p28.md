# Chapter 28. Environment Variables

*.env file, Config class*

---

## Introduction

In a real project, you often need to use **secrets** like:

* Database password
* API keys (payment gateway, email service, OpenAI key, etc.)
* JWT secret
* Debug mode (ON/OFF)

You **must not** write these directly in your code, because:

* Itâ€™s unsafe (anyone seeing your code can see passwords).
* Different environments need different values (local, testing, production).

To solve this, we use:

* **Environment variables** â†’ values stored outside code.
* A **`.env` file** â†’ a simple text file holding these values.
* A **Config class** â†’ a central place in Python to read and use these values.

Imagine a **restaurant** with a secret sauce recipe.
You donâ€™t write the recipe on the menu card (the code).
You keep it in the kitchen (the `.env` file), and the chef (Config class) uses it.

---

## Concepts

* **Environment variable**:
  A keyâ€“value setting (like `DB_PASSWORD=abc123`) available to your program from the system.

* **`.env` file**:
  A simple file containing environment variables in `KEY=VALUE` format.

* **Config class**:
  A Python class that loads and exposes configuration values (like `DB_URL`, `SECRET_KEY`) in a clean way.

* **Why use them?**

  * No secrets in code
  * Different settings for dev / test / prod
  * Easier deployment

---

## Step-by-step Explanation

### Step 1: Create a `.env` file

Inside your project folder, create a file called `.env`:

Example structure:

```
project/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â””â”€â”€ config.py
â”‚   â””â”€â”€ ...
â””â”€â”€ .env
```

In `.env`, write keyâ€“value pairs:

```env
APP_NAME=My Cool Backend
APP_ENV=development
DEBUG=True

DB_HOST=localhost
DB_PORT=3306
DB_USER=myuser
DB_PASSWORD=mypassword
DB_NAME=mydatabase

JWT_SECRET=supersecretjwttoken
```

> Note:
> No quotes needed. One `KEY=VALUE` per line.

Also:
ğŸ‘‰ Do **not** commit `.env` into Git. Add it to `.gitignore`.

---

### Step 2: Install helper package (optional but useful)

We can use **python-dotenv** or Pydanticâ€™s `BaseSettings`.
Letâ€™s keep it simple and show both options (you can choose one).

Install `python-dotenv`:

```bash
pip install python-dotenv
```

---

### Step 3: Create a Config class (`config.py`)

We create a single place to read environment variables and make them available to the rest of the app.

#### Option A: Simple Config using `os` + `python-dotenv`

**app/core/config.py**

```python
import os
from dotenv import load_dotenv

# Load values from .env file into environment variables
load_dotenv()

class Config:
    APP_NAME: str = os.getenv("APP_NAME", "My App")
    APP_ENV: str = os.getenv("APP_ENV", "development")
    DEBUG: bool = os.getenv("DEBUG", "False") == "True"

    DB_HOST: str = os.getenv("DB_HOST", "localhost")
    DB_PORT: int = int(os.getenv("DB_PORT", "3306"))
    DB_USER: str = os.getenv("DB_USER", "root")
    DB_PASSWORD: str = os.getenv("DB_PASSWORD", "")
    DB_NAME: str = os.getenv("DB_NAME", "test_db")

    JWT_SECRET: str = os.getenv("JWT_SECRET", "changeme")

config = Config()
```

Here:

* `load_dotenv()` loads values from `.env` into system environment.
* `os.getenv("KEY", "default")` reads each value.
* `config` object can be imported anywhere.

---

### Step 4: Use Config in your FastAPI app

**app/main.py**

```python
from fastapi import FastAPI
from app.core.config import config

app = FastAPI(title=config.APP_NAME)

@app.get("/info")
def get_info():
    return {
        "app_name": config.APP_NAME,
        "environment": config.APP_ENV,
        "debug": config.DEBUG
    }
```

Now your application title and properties come from the `.env` file.

---

### Step 5: Use Config for Database URL

You can combine DB settings into one connection string.

**app/core/config.py** (add this inside the class):

```python
    @property
    def DATABASE_URL(self) -> str:
        return (
            f"mysql+pymysql://{self.DB_USER}:{self.DB_PASSWORD}"
            f"@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"
        )
```

Then, in your DB session file:

**app/db/session.py**

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import config

engine = create_engine(config.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
```

Now, changing the DB host/user/password only needs editing `.env`, not Python files.

---

### Step 6 (Alternative): Config Using Pydantic `BaseSettings`

If you are comfortable adding one more small library, Pydantic makes this even cleaner.

Install:

```bash
pip install pydantic
```

**app/core/config.py**

```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    APP_NAME: str = "My App"
    APP_ENV: str = "development"
    DEBUG: bool = True

    DB_HOST: str = "localhost"
    DB_PORT: int = 3306
    DB_USER: str = "root"
    DB_PASSWORD: str = ""
    DB_NAME: str = "test_db"

    JWT_SECRET: str = "changeme"

    class Config:
        env_file = ".env"

    @property
    def DATABASE_URL(self) -> str:
        return (
            f"mysql+pymysql://{self.DB_USER}:{self.DB_PASSWORD}"
            f"@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"
        )

settings = Settings()
```

Now Pydantic will automatically read from `.env` and environment variables.

Usage:

```python
from app.core.config import settings

print(settings.APP_NAME)
print(settings.DATABASE_URL)
```

---

## Code Examples

### 1. `.env` Example

```env
APP_NAME=Order Service
APP_ENV=production
DEBUG=False

DB_HOST=prod-db.company.com
DB_PORT=3306
DB_USER=orders_user
DB_PASSWORD=strongpassword
DB_NAME=orders_db

JWT_SECRET=super-secret-jwt-key
```

### 2. Simple Config Class Using `dotenv`

```python
# app/core/config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    APP_NAME = os.getenv("APP_NAME", "My App")
    APP_ENV = os.getenv("APP_ENV", "development")
    DEBUG = os.getenv("DEBUG", "False") == "True"

config = Config()
```

### 3. Using Config in API

```python
# app/main.py
from fastapi import FastAPI
from app.core.config import config

app = FastAPI(title=config.APP_NAME)

@app.get("/health")
def health_check():
    return {
        "status": "ok",
        "env": config.APP_ENV
    }
```

---

## How Codex Helps

Codex can make working with config and environment variables much easier.

You can ask Codex to:

1. **Create a `.env` template**

   > â€œGenerate a .env template for FastAPI + MySQL with DB host, port, user, password, name, JWT secret, and app name.â€

2. **Generate a Config class**

   > â€œCreate a Config class in Python that reads values from .env using python-dotenv, and builds a SQLAlchemy DATABASE_URL.â€

3. **Refactor hard-coded values into env variables**

   If you have something like:

   ```python
   engine = create_engine("mysql+pymysql://root:1234@localhost:3306/mydb")
   ```

   You can tell Codex:

   > â€œRefactor this code to use environment variables and a Config class instead of hardcoded DB URL.â€

4. **Create different `.env` files for dev and prod**

   > â€œGenerate .env.development and .env.production examples for this project and show me how to load them in config.py.â€

5. **Debug issues**

   > â€œIâ€™m getting a â€˜KeyError: DB_HOSTâ€™. Check my config.py and .env content and tell me whatâ€™s wrong.â€

Codex is very good at:

* suggesting good names for variables
* fixing small bugs in Config classes
* updating all the places where the config is used

---

## Small Exercise

1. Create a **new `.env` file** in your current backend project with at least:

   * `APP_NAME`
   * `APP_ENV`
   * `DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, `DB_NAME`
   * `JWT_SECRET`

2. Create a **Config class** (or `Settings` class with Pydantic) that:

   * Reads all these values
   * Exposes a `DATABASE_URL` property

3. Update your **database connection code** to use `config.DATABASE_URL` (or `settings.DATABASE_URL`) instead of hardcoding the URL.

4. Ask Codex:

   > â€œHere is my current main.py, session.py, and config.py. Please refactor them to use a Config class with environment variables loaded from .env and clean up any mistakes.â€


