# **How to Use Codex for Debugging + Refactoring**

## **1. Introduction**

Codex can work like a **smart assistant engineer** who helps you:

* find mistakes
* explain why something is failing
* suggest cleaner code
* rewrite messy functions
* break a large file into small modules

You only need to give Codex **clear context**, and it behaves like a helpful senior reviewer.

This chapter shows **how to ask Codex to debug issues and refactor existing code**, using very simple steps and real-life examples.

---

# **2. Debugging vs Refactoring — Simple Explanation**

### ✔ Debugging

Finding and fixing errors.
Like a mechanic checking why a car makes noise.

### ✔ Refactoring

Improving code design without changing behaviour.
Like reorganizing items in a room without throwing anything away.

Codex supports both.

---

# **3. How Codex Helps in Debugging**

Codex is very good at:

* spotting syntax errors
* catching logical mistakes
* identifying missing imports
* noticing wrong variable names
* understanding stack traces
* explaining why a function behaves incorrectly

You simply show Codex:

* the error message
* the code file
* what you expected the program to do

And Codex can point out the exact mistake.

---

## **3.1 Example: Debug a FastAPI route**

### You say:

```text
Here is my FastAPI endpoint:

@app.get("/users/{user_id}")
async def get_user(user_id: int, db: Session):
    user = db.query(User).filter(User.id == user_id).first()
    return user.name

Error:
TypeError: object has no attribute 'name'

I expected user.name to exist. Please debug.
```

### Codex will explain:

* The user may be NULL
* ORM model may not have `name` field
* Your query may be wrong
* You may need `.first()` vs `.one()`
* Your model may not be imported

It can then generate a corrected version:

```python
if not user:
    raise HTTPException(status_code=404, detail="User not found")

return {"name": user.name}
```

---

## **3.2 Example: Debug database connection**

You say:

```text
My SQLAlchemy connection shows this error:

OperationalError: (2003, "Can't connect to MySQL server on 'localhost'")

Here is my engine code:

engine = create_engine("mysql+pymysql://root:pwd@localhost:3306/testdb")

Help me find the issue.
```

Codex may tell you:

* MySQL server may not be running
* Wrong port
* Wrong password
* Missing `pymysql` installation
* Container → host mismatch
* Should use `127.0.0.1` instead of `localhost`

---

## **3.3 Debugging Step-by-Step Using Codex**

You can say:

```text
You are my debugging assistant.
Explain in small steps what the error means,
why it occurs,
and give 3 possible fixes.
```

Codex will break the problem down into simple, understandable steps.

---

# **4. How Codex Helps in Refactoring**

Refactoring = improving design while keeping behaviour same.

Codex can help you:

* split large functions
* reduce repeated code
* organize folders better
* move business logic out of routes
* convert spaghetti code into clean modules
* add comments
* rewrite code more simply

---

## **4.1 Asking Codex to Refactor a Large File**

You give Codex a file:

```text
This file is too large and unreadable.
Please refactor it by splitting into:
- routers
- services
- schemas
- tests

Do not change functionality.
Just reorganize structure.
```

Codex will:

1. Propose a clean folder structure
2. Suggest names for each file
3. Show new code sections
4. Explain how to migrate safely

---

## **4.2 Example: Refactor a long function**

Before:

```python
def calculate_bill(items):
    total = 0
    for i in items:
        if i["category"] == "food":
            total += i["price"] + (i["price"] * 0.05)
        if i["category"] == "electronics":
            total += i["price"] + (i["price"] * 0.18)
        if i["category"] == "clothes":
            total += i["price"] + (i["price"] * 0.12)
    return round(total, 2)
```

You ask:

```text
Refactor this function.
Remove repeated code.
Make it readable.
```

Codex will rewrite:

```python
def calculate_bill(items):
    tax_rates = {
        "food": 0.05,
        "electronics": 0.18,
        "clothes": 0.12,
    }
    total = 0
    for item in items:
        rate = tax_rates.get(item["category"], 0)
        total += item["price"] * (1 + rate)
    return round(total, 2)
```

Cleaner, shorter, easier.

---

# **5. How to Ask Codex to “Find Problems” Automatically**

Codex understands patterns.
You can ask:

```text
Read this file and list 10 design problems.
Also explain why they matter.
```

Or:

```text
Identify any bad practices in this code.
Suggest improvements.
```

Codex can catch:

* unused variables
* duplicated logic
* missing error handling
* wrong naming conventions
* insecure code
* tight coupling

---

# **6. Showing Codex Your Project Tree**

Codex becomes much smarter when you show your folder structure:

```text
Here is my project tree:

app/
    main.py
    models/
        user.py
        order.py
    routes/
        users.py
        orders.py
    services/
        user_service.py
        order_service.py

Please review the structure and tell me how to improve it.
```

Codex can then:

* Suggest splitting large directories
* Propose better naming
* Ask you to separate domain logic and API logic
* Identify circular imports

---

# **7. Using Codex to Clean Your Codebase**

You can say:

```text
Perform a code cleanup:
1. Remove unused imports.
2. Remove commented-out code.
3. Improve variable names.
4. Add docstrings to each function.
5. Format code using PEP8.
```

Codex can rewrite the entire file.

---

# **8. Debugging With Stack Traces**

Codex is excellent with stack traces.

You say:

```text
Here is the error traceback.
Explain the cause in simple language.
Then fix the code.

<stack trace>
```

Codex will:

* read the traceback
* locate the failing line
* explain in simple language
* provide corrected code

---

# **9. Combined Prompt: Debug + Refactor + Improve**

Sometimes you want everything at once.
Use a combined prompt:

```text
Read this file and do the following:

1. Debug any errors.
2. Explain in simple language what was wrong.
3. Refactor the code for readability.
4. Reduce repeated logic.
5. Separate business logic into service functions.
6. Add comments and docstrings.
7. Do not change behaviour.

Output:
- Fixed and refactored code
- Short explanation of what changed
```

This is extremely powerful.

---

# **10. Best Practices When Asking Codex**

### ✔ Give full context

Include file, folder tree, error messages.

### ✔ Say what must NOT change

Example: “Don’t change API response format.”

### ✔ Show expected behaviour

Example: “Function should return list of active users.”

### ✔ Ask for step-by-step explanation

Helps you understand the fix.

### ✔ Follow up

After Codex fixes something, ask:

```text
Now simplify it further.
```

or

```text
Now make it more modular.
```

---

# **11. Summary Checklist: How to Use Codex for Debugging + Refactoring**

### **To Debug**

* Provide code + error message
* Ask for explanation
* Ask for corrected version
* Ask for alternative fixes
* Ask for step-by-step reasoning

### **To Refactor**

* Provide messy code
* Specify what should not change
* Tell Codex to clean, simplify, reorganize
* Ask for modular structure
* Ask for comments/docstrings
* Ask for a “before → after” comparison

### **To Improve Whole Design**

* Show Codex your project tree
* Ask it to list problems
* Ask it to propose new structure
* Let it generate updated files

---

Just tell me!

