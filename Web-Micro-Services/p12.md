# Chapter 12. Service 3 ‚Äî Billing & Payments (Simple Simulation)

## Introduction

Once a user can **log in** and see **products**, the next natural step is:
üëâ *‚ÄúHow do they place an order and pay?‚Äù*

In real life, payment is done using gateways like Razorpay, Stripe, PayPal, etc.
But for learning, we will build a **simple simulation** of billing and payments:

* Create an **order** with selected items
* Track **order status** (e.g., `PENDING`, `PAID`, `CANCELLED`)
* Simulate **payment success**
* Simulate **Email/SMS notifications** (just print / log them)

Think of this like a **mock cashier counter** in a training shop:
You don‚Äôt use real money, but you practice the steps.

---

## Concepts

* **Order**
  A record of what the user bought: items, quantity, total amount.

* **Order Status**
  Simple states like:

  * `PENDING` ‚Üí Order created, payment not done
  * `PAID` ‚Üí Payment success
  * `CANCELLED` ‚Üí Order cancelled

* **Payment Simulation**
  Instead of integrating a real payment gateway, we just pretend:

  * A `/pay` endpoint sets the order to `PAID`.

* **Notification Mock**
  Instead of sending real Email/SMS, we:

  * Print a message to console
  * Or log a message like: ‚ÄúEmail sent to [user@example.com](mailto:user@example.com): Your order is confirmed.‚Äù

---

## Step-by-step Explanation

1. **Design an Order model**

   * Fields:

     * `id`
     * `user_id`
     * `total_amount`
     * `status`
     * `created_at`
   * (Optional) Another table `order_items` with product-wise details.

2. **Create Order API**

   * User sends a list of product IDs and quantities.
   * Backend:

     * Looks up product prices
     * Calculates total amount
     * Saves order with status `PENDING`.

3. **Payment Simulation API**

   * Endpoint like: `POST /orders/{order_id}/pay`
   * It:

     * Checks if order exists and is `PENDING`
     * Sets status to `PAID`
     * Triggers mock notification.

4. **Order Status API**

   * `GET /orders/{order_id}`
   * Returns:

     * id
     * status
     * amount
     * items

5. **Notification Mock**

   * When an order becomes `PAID`, call a small function:

     * `send_email_mock(email, message)`
     * `send_sms_mock(phone, message)`
   * For now, just `print()` to console.

---

## Code Examples

> These are **simplified** examples just to show structure.

### SQLAlchemy Models (Order + OrderItem)

```python
from sqlalchemy import Column, Integer, Float, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base

class Order(Base):
    __tablename__ = "orders"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, index=True)
    total_amount = Column(Float)
    status = Column(String, default="PENDING")
    created_at = Column(DateTime, default=datetime.utcnow)

    items = relationship("OrderItem", back_populates="order")


class OrderItem(Base):
    __tablename__ = "order_items"

    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id"))
    product_id = Column(Integer)
    quantity = Column(Integer)
    price = Column(Float)  # price at the time of order

    order = relationship("Order", back_populates="items")
```

---

### Pydantic Schemas

```python
from pydantic import BaseModel
from typing import List

class OrderItemInput(BaseModel):
    product_id: int
    quantity: int

class OrderCreate(BaseModel):
    user_id: int
    items: List[OrderItemInput]

class OrderItemOut(BaseModel):
    product_id: int
    quantity: int
    price: float

class OrderOut(BaseModel):
    id: int
    user_id: int
    total_amount: float
    status: str
    items: List[OrderItemOut]

    class Config:
        orm_mode = True
```

---

### Mock Notification Functions

```python
def send_email_mock(to_email: str, subject: str, body: str):
    print(f"[EMAIL MOCK] To: {to_email}, Subject: {subject}, Body: {body}")

def send_sms_mock(to_phone: str, text: str):
    print(f"[SMS MOCK] To: {to_phone}, Text: {text}")
```

In a real system, these would call an Email/SMS provider.
Here, we just log to console.

---

### Create Order API

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

router = APIRouter(prefix="/orders", tags=["orders"])

@router.post("/", response_model=OrderOut)
def create_order(order_data: OrderCreate, db: Session = Depends(get_db)):
    total = 0.0
    order_items = []

    # For simplicity, assume we have a Product model already
    for item in order_data.items:
        product = db.query(Product).filter(Product.id == item.product_id).first()
        if not product:
            raise HTTPException(400, f"Product {item.product_id} not found")
        line_total = product.price * item.quantity
        total += line_total
        order_items.append((item, product.price))

    order = Order(user_id=order_data.user_id, total_amount=total, status="PENDING")
    db.add(order)
    db.commit()
    db.refresh(order)

    # Save order items
    for item, price in order_items:
        oi = OrderItem(order_id=order.id,
                       product_id=item.product_id,
                       quantity=item.quantity,
                       price=price)
        db.add(oi)

    db.commit()
    db.refresh(order)
    return order
```

---

### Get Order Status API

```python
@router.get("/{order_id}", response_model=OrderOut)
def get_order(order_id: int, db: Session = Depends(get_db)):
    order = db.query(Order).filter(Order.id == order_id).first()
    if not order:
        raise HTTPException(404, "Order not found")
    return order
```

---

### Payment Simulation API

```python
@router.post("/{order_id}/pay")
def pay_order(order_id: int, db: Session = Depends(get_db)):
    order = db.query(Order).filter(Order.id == order_id).first()
    if not order:
        raise HTTPException(404, "Order not found")

    if order.status != "PENDING":
        raise HTTPException(400, "Order is not pending")

    # Simulate payment success
    order.status = "PAID"
    db.commit()
    db.refresh(order)

    # Mock notification
    # In real life, fetch email/phone from User table using order.user_id
    user_email = "user@example.com"
    user_phone = "+911234567890"

    send_email_mock(
        to_email=user_email,
        subject="Order Confirmed",
        body=f"Your order #{order.id} is paid. Amount: {order.total_amount}"
    )
    send_sms_mock(
        to_phone=user_phone,
        text=f"Order #{order.id} paid successfully."
    )

    return {"message": "Payment simulated, order marked as PAID"}
```

---

## How Codex Helps

Codex can make this service much faster to build.

### 1. Generate the initial service

Prompt example:

> ‚ÄúGenerate a FastAPI billing service with Order and OrderItem models using SQLAlchemy. Include APIs for creating an order, viewing order status, and simulating payment.‚Äù

### 2. Add notification mocks

> ‚ÄúAdd mock email and SMS notification functions that log to console when an order becomes PAID.‚Äù

### 3. Improve model design

> ‚ÄúRefactor the Order and OrderItem models to be more suitable for an e-commerce system. Add fields like discount and payment_method.‚Äù

### 4. Handle edge cases

> ‚ÄúUpdate the payment API so that it does not allow payment for CANCELLED or already PAID orders and returns friendly error messages.‚Äù

### 5. Debug issues

If you get a SQLAlchemy or FastAPI error, you can paste it:

> ‚ÄúHere is my FastAPI order creation code and the error I‚Äôm getting. Fix the bug and explain what I did wrong.‚Äù

---

## Small Exercise

Try these small tasks to practice:

1. **Add `CANCELLED` status**

   * Create an endpoint: `POST /orders/{order_id}/cancel`
   * Only allow cancel if the order is still `PENDING`.

2. **Add a simple `payment_method` field**

   * Values: `"COD"` (Cash on Delivery), `"ONLINE"`
   * Store it during order creation.

3. **Extend the notification mock**

   * When an order is cancelled, send a different mock Email/SMS like:

     * ‚ÄúYour order #ID has been cancelled.‚Äù



