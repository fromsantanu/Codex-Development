# Chapter 13. MySQL Integration with All Services

## Introduction

So far, we created:

* **Service 1:** User Authentication
* **Service 2:** Product / Item Management
* **Service 3:** Billing & Payments (simulation)

Now we must connect everything to a **real database (MySQL)** in a clean and professional way.

In this chapter, we will see:

* How to use **SQLAlchemy ORM** to talk to MySQL
* How to use **Alembic** for database migrations (simple intro)
* How to use **config files and environment variables** to keep passwords and secrets safe

Think of this like running a **shopping mall**:

* SQLAlchemy is your *staff* who speak to the MySQL *storage room*
* Alembic is your *record keeper* who tracks changes in the storage layout
* Config files are your *safe locker* where you keep keys and passwords

---

## Concepts

* **SQLAlchemy ORM**
  A Python library that lets you work with database tables as Python classes (models).
  You don’t write raw SQL every time.

* **MySQL Integration**
  Connecting FastAPI + SQLAlchemy to a MySQL database using a **connection URL**.

* **Alembic Migration**
  A tool that tracks changes in database structure (tables/columns) over time.
  Example: adding a new column `phone` to `users` without manually writing ALTER TABLE every time.

* **Config Files & Secrets**
  We do **not** hard-code passwords in code.
  Instead, we use:

  * `.env` file
  * environment variables
  * a config module to read them

---

## Step-by-step Explanation

### Step 1: Decide database approach

For microservices, there are two common styles:

1. **Single database, multiple schemas/tables for all services** (simple for learning):

   ```
   auth service   → uses users table
   product service → uses products table
   billing service → uses orders, order_items tables
   ```
2. **Separate database for each microservice** (more “true” microservice style):
   Each service has its own DB.

For training, we’ll assume a **single MySQL database**, e.g. `shop_db`.

---

### Step 2: Setup SQLAlchemy connection

We create a common `database.py` file that:

* Connects to MySQL
* Creates a Session for queries
* Holds the Base class for models

---

### Step 3: Use ORM models in all services

Each service defines its own **models** using `Base` from `database.py`.
Example: `User`, `Product`, `Order`.

---

### Step 4: Use Alembic to manage DB changes

We will:

* Initialize Alembic
* Tell Alembic where our models are
* Create a migration script
* Run the migration to create/update tables

Think of Alembic as **Git for database structure**.

---

### Step 5: Config & Secrets

We use a `.env` file to store:

* `DATABASE_URL`
* `SECRET_KEY` (JWT secret)
* Email/SMS API keys (later)

We do **not** commit `.env` to Git.

---

## Code Examples

### 1. `.env` file (secrets and config)

```env
# .env
DATABASE_URL=mysql+pymysql://username:password@localhost:3306/shop_db
SECRET_KEY=super_secret_jwt_key_here
```

> In real life, choose a strong, random secret key.

---

### 2. Config loader (`config.py`)

```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    database_url: str
    secret_key: str

    class Config:
        env_file = ".env"

settings = Settings()
```

Now anywhere in the project, we can do:

```python
from config import settings

print(settings.database_url)
print(settings.secret_key)
```

---

### 3. SQLAlchemy database setup (`database.py`)

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from config import settings

SQLALCHEMY_DATABASE_URL = settings.database_url

engine = create_engine(SQLALCHEMY_DATABASE_URL, pool_pre_ping=True)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

Now all services will import `Base` and `get_db` from here.

---

### 4. Example: User model using the shared Base

```python
# models_user.py
from sqlalchemy import Column, Integer, String
from database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100))
    email = Column(String(255), unique=True, index=True)
    password_hash = Column(String(255))
    role = Column(String(50), default="user")
```

---

### 5. Example: Product model

```python
# models_product.py
from sqlalchemy import Column, Integer, String, Float
from database import Base

class Product(Base):
    __tablename__ = "products"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(200), index=True)
    description = Column(String(500))
    price = Column(Float)
    stock = Column(Integer)
    category = Column(String(100), index=True)
```

---

### 6. Example: Order model (from previous chapter)

```python
# models_order.py
from sqlalchemy import Column, Integer, Float, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base

class Order(Base):
    __tablename__ = "orders"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, index=True)
    total_amount = Column(Float)
    status = Column(String(50), default="PENDING")
    created_at = Column(DateTime, default=datetime.utcnow)

    items = relationship("OrderItem", back_populates="order")


class OrderItem(Base):
    __tablename__ = "order_items"

    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id"))
    product_id = Column(Integer)
    quantity = Column(Integer)
    price = Column(Float)

    order = relationship("Order", back_populates="items")
```

All of these models share the same `Base` and go to the same MySQL database.

---

### 7. Simple ASCII diagram of integration

```text
          +-----------------+
          |   FastAPI App   |
          +--------+--------+
                   |
                   v
       +--------------------------+
       |    SQLAlchemy ORM        |
       |  (User, Product, Order)  |
       +-------------+------------+
                     |
                     v
            +-----------------+
            |    MySQL DB     |
            |   shop_db       |
            +-----------------+
```

---

### 8. Alembic basic usage (easy intro)

**(a) Install Alembic**

```bash
pip install alembic
```

**(b) Initialize Alembic in your project**

```bash
alembic init alembic
```

This creates an `alembic` folder and `alembic.ini` file.

**(c) Edit `alembic.ini`**

Set the DB URL (optional, or you can use env):

```ini
sqlalchemy.url = mysql+pymysql://username:password@localhost:3306/shop_db
```

**(d) Edit `alembic/env.py`**

Tell Alembic about your `Base` and models:

```python
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context

from config import settings
from database import Base
from models_user import User
from models_product import Product
from models_order import Order, OrderItem

config = context.config

# Use DATABASE_URL from .env if you like
config.set_main_option("sqlalchemy.url", settings.database_url)

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata
```

Now Alembic knows all your models.

**(e) Create first migration**

```bash
alembic revision --autogenerate -m "create initial tables"
```

Alembic will inspect `Base.metadata` and create a migration script.

**(f) Apply migration to MySQL**

```bash
alembic upgrade head
```

This will create all the tables (users, products, orders, etc.) in `shop_db`.

Whenever you change a model (e.g., add a new column), you repeat:

1. `alembic revision --autogenerate -m "add phone to users"`
2. `alembic upgrade head`

Alembic keeps a history of DB changes.

---

## How Codex Helps

Codex can reduce a lot of setup pain here.

### 1. Generate SQLAlchemy + FastAPI boilerplate

Prompt example:

> “Generate a FastAPI `database.py` file that connects to a MySQL database using SQLAlchemy ORM, with `SessionLocal`, `Base`, and `get_db()` function.”

### 2. Create models for all services

> “Create SQLAlchemy models for User, Product, Order, and OrderItem for an e-commerce app. Use appropriate columns and indexes.”

### 3. Setup Alembic configuration

> “Modify Alembic `env.py` so that it uses my `Base` from `database.py` and reads `DATABASE_URL` from `.env` via Pydantic `Settings` class.”

### 4. Generate migration scripts

> “Given these SQLAlchemy models, generate Alembic revision code for the initial migration.”

### 5. Secret and config management

> “Create a `config.py` file using Pydantic BaseSettings to load `DATABASE_URL` and `SECRET_KEY` from a `.env` file. Show how to use it in FastAPI and Alembic.”

---

## Small Exercise

1. **Add a new column to `users` table**

   * Add `phone` column in `User` model.
   * Use Alembic to:

     * autogenerate a migration
     * apply it to MySQL

2. **Split models into a `models` package**

   * Create folder `app/models/`
   * Put `models_user.py`, `models_product.py`, `models_order.py` inside
   * Update `env.py` to import from this package.

3. **Improve secret management**

   * Add `EMAIL_API_KEY` and `SMS_API_KEY` to `.env`
   * Extend `Settings` in `config.py` to include them
   * Print them once in main app (just to confirm they load correctly), then remove the print.

