# Chapter 30. CI/CD Basics (Optional)

*GitHub Actions simple example, automatic testing, automatic deployment*

---

## Introduction

When you build backend systems, you don't want to manually:

* Test your code
* Run linting
* Deploy to server
* Restart service

Doing these manually every time is slow and error-prone.

**CI/CD** solves this.

Think of CI/CD like a **conveyor belt in a factory**:

* Whenever you place a new item (your latest code),
* The machine automatically checks it, tests it, paints it, packs it,
* And delivers it to the customer (deployment).

You don’t need to stand there and do things by hand.

In software:

* **CI (Continuous Integration)** = Automatic testing whenever code is pushed
* **CD (Continuous Deployment)** = Automatic deployment whenever code is merged

In this chapter, you will learn a **simple GitHub Actions example** for:

✔ running tests
✔ checking code
✔ deploying automatically (basic demonstration)

---

## Concepts

* **Pipeline**: A sequence of automated steps (test → build → deploy).
* **Workflow**: A YAML file inside `.github/workflows/` where CI/CD steps are defined.
* **Trigger**: What starts the pipeline (e.g., push to main branch).
* **Job**: A block of work (e.g., “run tests”).
* **Runner**: A machine that executes the instructions.
* **Automatic testing**: Running pytest automatically.
* **Automatic deployment**: Uploading your code or restarting your server automatically.

---

## Step-by-step Explanation

### 1. Create the workflow folder

Inside your project:

```
project/
├── .github/
│   └── workflows/
│       └── ci.yml
└── app/
    └── ...
```

GitHub Actions only works if your workflow files are inside this folder.

---

### 2. Add a simple CI workflow (test + lint)

Create:
**.github/workflows/ci.yml**

```yaml
name: CI Pipeline

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install -r requirements.txt

      - name: Run tests
        run: |
          pytest
```

What this does:

* Runs on every push to **main**
* Installs dependencies
* Runs `pytest`
* Fails the pipeline if any test fails

This ensures you never merge broken code.

---

### 3. Add a simple deployment job (very basic example)

Assume:

* You have a **VPS server**
* You SSH into it
* You run `git pull`
* Then you restart your app

We can automate this.

Add a second job to the same file:

```yaml
deploy:
  needs: test
  runs-on: ubuntu-latest

  steps:
    - name: Deploy to server
      uses: appleboy/ssh-action@v0.1.6
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SERVER_SSH_KEY }}
        script: |
          cd /home/app/myproject
          git pull
          sudo systemctl restart myapp
```

You must add secrets in GitHub:
**Settings → Secrets → Actions**

* `SERVER_HOST`
* `SERVER_USER`
* `SERVER_SSH_KEY`

This pipeline now:

1. Runs tests
2. If tests pass → deploys
3. Restarts your app automatically

---

### 4. Automatic Testing Explained

With the above setup:

* Whenever you push code
* GitHub automatically runs `pytest`
* If there is even **one bug**, deployment stops
* This saves you from pushing broken code to production

This is like checking every item on your conveyor belt before sending to the customer.

---

### 5. Automatic Deployment Explained

Once tests pass:

* GitHub securely connects to your server
* Pulls the latest code
* Restarts the FastAPI service

This ensures:

* No manual commands
* No missing steps
* No human errors
* Faster development

---

## Code Examples

### 1. Simple pytest example (for testing)

**tests/test_sample.py**

```python
def test_addition():
    assert 2 + 2 == 4
```

### 2. GitHub Secrets Example

Use these names:

```
SERVER_HOST=your.server.ip
SERVER_USER=ubuntu
SERVER_SSH_KEY=<your_private_key>
```

Add them in:
**GitHub → Repository → Settings → Secrets → Actions**

---

## How Codex Helps

Codex can assist you significantly with CI/CD setups:

### ✔ Write complete GitHub Actions files

Ask Codex:

```
Create a GitHub Actions workflow that installs dependencies, runs pytest, and deploys to a VPS via SSH only when tests pass.
```

### ✔ Create pipeline templates

Codex can generate pipelines for:

* Docker builds
* Kubernetes deployments
* AWS, Azure, or Google Cloud
* Nginx reload
* Build and push Docker images

### ✔ Debug pipeline failures

Codex can analyze error logs like:

```
ERROR: pytest not found
ERROR: ssh key invalid
ERROR: folder does not exist
```

You can paste your GitHub Actions logs, and Codex will fix them.

### ✔ Improve performance

Codex can reduce build times by:

* Using caching
* Splitting workflows
* Adding parallel jobs

---

## Small Exercise

1. Create the file `.github/workflows/ci.yml` inside your project.

2. Add this simple workflow:

   * set up python
   * install packages
   * run tests

3. Push your code to a GitHub repo.

4. Watch the “Actions” tab and see your pipeline run.

5. Add an intentional failing test and observe the CI fail.

6. Ask Codex:

   > “Improve my CI workflow by adding caching and linting with flake8.”

7. (Optional) Add deployment using SSH.

---


