# Chapter 19. Building an API Gateway

## Introduction

In a microservice system, you often have many small services:

* User service
* Product service
* Order service
* Notification service

If each service exposes its own API, the client (mobile app or frontend) becomes confused:

* â€œWhich URL should I call?â€
* â€œHow do I handle authentication?â€
* â€œWhy do I have to talk to 5 different services?â€

To make this simple, we put a **single entry point** in front of all services.
This single entry point is called an **API Gateway**.

Think of it like the **main gate of a large housing society**â€”you enter from one gate, and from inside the security room, guards guide you to the correct building.

---

## Concepts

### ğŸ  What is a Gateway?

* It is a **single door** to all your backend services.
* it receives incoming requests and forwards them to the correct microservice.
* It also handles security, logging, rate limits, etc.

### ğŸ¤” Why do we need it?

* The client only needs **one URL**.
* We can apply **common security** rules at one place.
* Microservices stay hidden and safe inside.
* We can add **monitoring**, **request logs**, and **caching** easily.
* Easy to switch or update services without changing the frontend.

### âš™ï¸ Creating a Gateway with FastAPI

FastAPI makes it very easy to build a simple gateway using:

* Routes
* HTTP client
* Middleware

We will forward requests to internal services using Pythonâ€™s `httpx` or `requests`.

---

## Step-by-step Explanation

### â­ Step 1: Understanding the Flow

Imagine this simple diagram:

```
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Client  ---> â”‚   API Gateway       â”‚ ----> User Service
             â”‚ (One Entry Point)   â”‚ ----> Product Service
             â”‚                     â”‚ ----> Order Service
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The client always calls the gateway:

```
https://myapp.com/api/users
https://myapp.com/api/products
```

The gateway forwards:

* `/api/users` â†’ user service at `http://localhost:8001`
* `/api/products` â†’ product service at `http://localhost:8002`

---

### â­ Step 2: Define the Internal Microservices

Assume you already have:

* User service running on port 8001
* Product service running on port 8002

Each has its own routes.

---

### â­ Step 3: Create Gateway Routes

The gateway will have routes like:

* `/users/*` â†’ forward to User Service
* `/products/*` â†’ forward to Product Service

---

### â­ Step 4: Forward Requests Using httpx

We take the incoming request from the client and pass it to the correct service.

---

### â­ Step 5: Add Security, Logging, Rate Limits (Optional)

Since this is a beginner chapter, weâ€™ll only handle:

* Receiving request
* Forwarding request
* Returning service response

---

## Code Examples

### ğŸ”Œ Basic FastAPI API Gateway

```python
from fastapi import FastAPI, Request
import httpx

app = FastAPI()

USER_SERVICE = "http://localhost:8001"
PRODUCT_SERVICE = "http://localhost:8002"

@app.api_route("/users/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def users_proxy(path: str, request: Request):
    async with httpx.AsyncClient() as client:
        url = f"{USER_SERVICE}/{path}"
        response = await client.request(
            request.method,
            url,
            headers=request.headers,
            content=await request.body()
        )
        return response.json()

@app.api_route("/products/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def products_proxy(path: str, request: Request):
    async with httpx.AsyncClient() as client:
        url = f"{PRODUCT_SERVICE}/{path}"
        response = await client.request(
            request.method,
            url,
            headers=request.headers,
            content=await request.body()
        )
        return response.json()
```

---

### â­ How it Works

1. The client calls:

   ```
   GET /users/profile
   ```
2. Gateway forwards it to:

   ```
   http://localhost:8001/profile
   ```
3. Gateway returns the response back to the client.

---

## How Codex Helps

Codex can:

### âœ” Create the entire gateway structure

â€œCodex, generate a FastAPI gateway with routes for user and product services.â€

### âœ” Add new proxy routes automatically

â€œCodex, add forwarding logic for the order service running on port 8003.â€

### âœ” Improve forwarding logic

â€œCodex, update the gateway to correctly forward query parameters.â€

### âœ” Add logging middleware

â€œCodex, write middleware to log every incoming request in the gateway.â€

### âœ” Add JWT validation at the gateway

â€œCodex, add security so that only valid JWT tokens reach internal services.â€

Codex helps you build production-level gateways very quickly.

---

## Small Exercise

**Task:**
Create a very simple API Gateway with two routes:

1. `/api/user/*` â†’ forward to user service (`http://localhost:8001`)
2. `/api/inventory/*` â†’ forward to inventory service (`http://localhost:8002`)

**Bonus:**
Add a common header `X-Gateway: True` to all forwarded requests.

**Super Bonus:**
Add JWT validation in the gateway before forwarding.

---



