# **Chapter 5: Python FastAPI Crash Course**

## **Introduction**

FastAPI is like a smart receptionist in an office.
When someone (a client) asks for something, it receives the request, checks what they want, and then sends the request to the right room (your Python function).
It also returns the response back to the visitor in a clean, organized format (usually JSON).

FastAPI is popular because it is:

* **Very fast**
* **Easy to write**
* **Automatically generates documentation**
* **Perfect for building microservices**

In this chapter, we learn the basics:

* How to create API routes
* How to use request and response models
* How to handle errors
* Basic idea of dependency injection

---

## **Concepts**

### **1. API Route**

A route is simply a **path** that the client calls.
Example:

* `/login`
* `/get-products`
* `/add-patient`

Think of routes like *doors* in a big office. Each door leads to a different room (function).

---

### **2. Request Model**

This is a structured format of data that the API **expects** from the client.
Example: When adding a patient, we expect name, age, gender.

---

### **3. Response Model**

This defines what we **send back** to the user.

---

### **4. Error Handling**

If something goes wrong, we must return a clean, human-readable message.

---

### **5. Dependency Injection**

A fancy term meaning:
**We create some common function once and allow many routes to use it.**

Real-life example:
Think of a **water purifier** attached to a kitchen.
You don’t boil water in each room.
Everyone uses the **same purified water source**.

Similarly, your routes can share things like:

* Database connection
* Authentication
* Common utilities

---

## **Step-by-step Explanation**

### **Step 1: Install FastAPI & Uvicorn**

```bash
pip install fastapi uvicorn
```

---

### **Step 2: Create a simple FastAPI app**

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def home():
    return {"message": "Welcome to FastAPI!"}
```

Run it:

```bash
uvicorn main:app --reload
```

Visit in browser:
`http://127.0.0.1:8000/docs` ← Auto-generated API docs!

---

### **Step 3: Creating API Routes**

```python
@app.get("/hello")
def say_hello():
    return {"msg": "Hello!"}

@app.post("/add-item")
def add_item():
    return {"status": "Item added"}
```

---

### **Step 4: Using Request Models**

We use **Pydantic models** to validate input.

```python
from pydantic import BaseModel

class Patient(BaseModel):
    name: str
    age: int
    gender: str
```

Now use the model:

```python
@app.post("/add-patient")
def add_patient(patient: Patient):
    return {
        "message": "Patient added",
        "data": patient
    }
```

If a client sends wrong data (e.g., age="ten"), FastAPI automatically returns a clean error.

---

### **Step 5: Response Models**

This ensures our response is always consistent.

```python
class PatientResponse(BaseModel):
    message: str
    name: str
```

```python
@app.post("/register", response_model=PatientResponse)
def register(patient: Patient):
    return {
        "message": "Registered Successfully",
        "name": patient.name
    }
```

---

### **Step 6: Error Handling**

Simple way to create readable errors:

```python
from fastapi import HTTPException

@app.get("/divide")
def divide(a: int, b: int):
    if b == 0:
        raise HTTPException(status_code=400, detail="Cannot divide by zero")
    return {"result": a / b}
```

---

### **Step 7: Dependency Injection (Very Simple)**

Create a common dependency:

```python
def get_api_key():
    return "MY_SECURE_KEY"
```

Use dependency:

```python
from fastapi import Depends

@app.get("/secure-data")
def secure_data(api_key: str = Depends(get_api_key)):
    return {"status": "ok", "api_key": api_key}
```

This is a simple example.
In real systems, dependencies are used for:

* Database connections
* Authentication
* Logging
* Configurations

---

## **Code Examples (Clean Collection)**

### **Minimal FastAPI App**

```python
from fastapi import FastAPI
from pydantic import BaseModel
from fastapi import HTTPException, Depends

app = FastAPI()

# Request Model
class Patient(BaseModel):
    name: str
    age: int
    gender: str

# Dependency
def get_api_key():
    return "ABC123"

@app.get("/")
def home():
    return {"msg": "API running"}

@app.post("/add-patient")
def add_patient(patient: Patient):
    return {"message": "Patient added", "data": patient}

@app.get("/divide")
def divide(a: int, b: int):
    if b == 0:
        raise HTTPException(400, "Cannot divide by zero")
    return {"result": a / b}

@app.get("/secure", dependencies=[Depends(get_api_key)])
def secure_route():
    return {"secret": "This is protected data"}
```

---

## **How Codex Helps**

Codex can help you at every step:

### **1. Generate API routes**

You can say:

> “Codex, create FastAPI routes for adding, updating, listing, and deleting products.”

Codex instantly writes the functions.

---

### **2. Generate request/response models**

You can say:

> “Create a Pydantic model for patient registration with name, age, blood group, and phone.”

---

### **3. Build full folder structures**

Codex can create a standard layout:

```
app/
 ├── main.py
 ├── routers/
 ├── models/
 ├── schemas/
 ├── services/
```

---

### **4. Add new features to existing code**

Example:

> “Add pagination to my /list-products API.”

Codex will read your project and insert new code properly.

---

### **5. Debug errors**

You can copy an error message and ask:

> “Codex, why is FastAPI giving this error and how do I fix it?”

---

## **Small Exercise**

### **Task**

Create a FastAPI project with:

1. A GET route: `/status` → returns `{ "service": "running" }`
2. A POST route: `/add-book`

   * Request model: title, author, price
   * Returns the same data with message: “Book added”
3. Add a divide API with error handling
4. Add a simple dependency that returns `"TOKEN-123"`

### **Bonus**

Ask Codex to:

* Generate folder structure
* Split routes into `/routers/books.py`
* Add a service layer



