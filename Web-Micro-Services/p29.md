# Chapter 29. Logging & Monitoring

*Simple logging setup, error tracking*

---

## Introduction

When you build backend systems, it’s important to know:

* What is happening inside your application
* What errors occurred
* When something went wrong
* Which user or which part of the system caused issues

This is exactly what **logging and monitoring** help you with.

Think of logging like a **CCTV camera** inside your application.
It quietly writes down important events such as:

* API calls
* Errors
* Database failures
* Unexpected conditions

Monitoring is like the **security guard** who watches the CCTV feed and alerts you if something looks wrong.

In this chapter, we will learn a **simple and practical logging setup** suitable for small to medium projects.

---

## Concepts

* **Log:** A message written to a file or console to record what happened.
* **Log levels:**

  * DEBUG → detailed internal info
  * INFO → normal messages (“User logged in”)
  * WARNING → minor issues
  * ERROR → something broke
  * CRITICAL → system crash
* **Log file:** A text file where log messages are stored.
* **Monitoring:** Observing logs and system behavior.
* **Error Tracking:** Storing and noticing errors quickly.

---

## Step-by-step Explanation

### 1. Why Logging is Needed

Imagine running a courier service.
If a delivery fails and there is **no log**, you will not know:

* Which driver took the package
* What went wrong
* When it happened

The same problem happens in software.

Logging helps you:

* Debug problems
* Understand flow
* Track errors
* Improve the system

---

### 2. Basic Logging Setup (Python)

Python has a built-in logging module.

We will create:

* a `logs` folder
* a `app_logger.py` file
* rotate logs so files don’t get too large

### Folder structure:

```
project/
│
├── app/
│   ├── core/
│   │   └── config.py
│   ├── utils/
│   │   └── app_logger.py
│   └── main.py
│
└── logs/
    └── app.log
```

---

### 3. Create a Simple Logger

**app/utils/app_logger.py**

```python
import logging
from logging.handlers import RotatingFileHandler
import os

# Create logs folder if not exists
LOG_DIR = "logs"
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)

LOG_FILE = os.path.join(LOG_DIR, "app.log")

# Basic logger setup
logger = logging.getLogger("app_logger")
logger.setLevel(logging.INFO)

handler = RotatingFileHandler(
    LOG_FILE,
    maxBytes=2 * 1024 * 1024,  # 2 MB
    backupCount=3              # keep 3 backups
)

formatter = logging.Formatter(
    "%(asctime)s - %(levelname)s - %(message)s"
)

handler.setFormatter(formatter)
logger.addHandler(handler)
```

What this does:

* Creates a `logs/app.log` file
* Rotates logs when size reaches 2 MB
* Creates backups (`app.log.1`, `app.log.2`, etc.)
* Adds timestamps and log levels

---

### 4. Use Logger in FastAPI Routes

**app/main.py**

```python
from fastapi import FastAPI
from app.utils.app_logger import logger

app = FastAPI()

@app.get("/hello")
def hello():
    logger.info("Hello endpoint was called")
    return {"message": "Hello!"}

@app.get("/cause-error")
def cause_error():
    try:
        5 / 0
    except Exception as e:
        logger.error(f"An error occurred: {str(e)}")
        return {"error": "Something went wrong"}
```

When you call the endpoint, logs will be added to:

```
logs/app.log
```

---

### 5. Add Error Tracking (Simple Version)

You can create a dedicated error log file.

Modify logger to write errors separately:

**app/utils/app_logger.py**

```python
error_handler = RotatingFileHandler(
    os.path.join(LOG_DIR, "error.log"),
    maxBytes=1 * 1024 * 1024,
    backupCount=2
)
error_handler.setLevel(logging.ERROR)
error_handler.setFormatter(formatter)

logger.addHandler(error_handler)
```

Now:

* `app.log` → all logs
* `error.log` → only errors

---

### 6. Add Error Tracking in Middleware (Auto-capture errors)

You can capture all unhandled exceptions.

**app/main.py**

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from app.utils.app_logger import logger

app = FastAPI()

@app.middleware("http")
async def log_requests(request: Request, call_next):
    try:
        response = await call_next(request)
        logger.info(f"{request.method} {request.url} → {response.status_code}")
        return response
    except Exception as e:
        logger.error(f"Unhandled error: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"message": "Internal server error"}
        )
```

This automatically logs:

* Every incoming request
* Any unhandled exception

---

### 7. Simple Monitoring Approach

Without complex tools, you can still monitor by:

* Checking log files daily
* Writing a script to scan logs for ERROR
* Sending email alerts (Codex can generate this)
* Adding a `/health` endpoint

Example:

```python
@app.get("/health")
def health_check():
    return {"status": "ok"}
```

---

## Code Examples

### 1. Simple log message

```python
logger.info("User logged in successfully")
```

### 2. Log an error

```python
try:
    risky_code()
except Exception as e:
    logger.error(f"Error: {str(e)}")
```

### 3. Log request information

```python
logger.info(f"Received request: {request.method} {request.url}")
```

---

## How Codex Helps

Codex can assist in many ways:

### ✔ Generate complete logging setup

Ask:

```
Create a logging setup for FastAPI with rotating log files, separate error logs, and timestamps.
```

### ✔ Add logging to routes automatically

Ask Codex to scan your routes and insert logging statements.

### ✔ Add middleware logging

Ask:

```
Add middleware to log all incoming requests and unhandled exceptions.
```

### ✔ Debug logging mistakes

Codex can fix errors like:

* missing handlers
* incorrect log level
* double logging
* incorrect file path

### ✔ Suggest better log messages

Codex can rewrite vague messages like “Error occurred” to something meaningful.

---

## Small Exercise

1. Create a `logs/` folder.
2. Create a simple logger similar to the example.
3. Add logs to at least two API endpoints:

   * One normal request
   * One that causes an intentional error
4. Add the middleware that logs every request.
5. Ask Codex:

   > “Review my logging setup and suggest improvements. Also add an email alert function for ERROR logs.”

---
