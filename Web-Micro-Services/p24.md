# Chapter 24. Practical Session: Let Codex Upgrade a Running System

## Introduction

In this chapter, we will imagine you **already have a working backend system**
—for example, a small online shop or a simple booking app built with FastAPI + MySQL.

Now you tell Codex:

> “Here is my project. Please help me add more features.”

We will see how to **ask Codex** to:

* Add **authentication** (login/signup)
* Add **new fields** in the database
* Add a **payment microservice**
* Add **logging**
* Add **validation**

Think of this as a **hands-on lab**:
You give Codex your project, and Codex helps you extend it step by step.

---

## Concepts

* **Running system**
  A project that already works (APIs, database, some UI maybe).

* **Authentication**
  Making sure only registered users can access certain APIs (like checking ID at the gate).

* **New fields in database**
  Adding extra columns, e.g. `phone_number`, `address`, `status`.

* **Payment microservice**
  A separate small service only for handling payments, like a separate cash counter in a mall.

* **Logging**
  Saving important information about what your app is doing (like CCTV for your code).

* **Validation**
  Checking that the data coming from the user is correct (e.g., email format, required fields).

---

## Step-by-step Explanation

We’ll walk through a typical workflow with Codex.

### Step 1: Give Codex Your Project Context

Open the project in VS Code (with Codex enabled) and say something like:

> “Codex, this is a FastAPI + MySQL project for a small store.
> Please scan the folder and tell me how the project is structured.”

Codex can reply with something like:

* `main.py` – starts the app
* `routers/` – contains user and product routes
* `models/` – SQLAlchemy models
* `database.py` – DB session

Now Codex “understands” your system.

---

### Step 2: Ask Codex to Add Authentication

You might say:

> “Add basic JWT authentication:
>
> * user registration
> * login
> * protected route `/me`
>   Follow the existing project style.”

Codex can then:

* Create `auth_router.py`
* Create a `User` model if not present
* Add password hashing
* Add JWT token creation and verification
* Wire auth into `main.py`

---

### Step 3: Ask Codex to Add New Fields in Database

Say your `User` table currently has:

* `id`
* `email`
* `password`

Now you want to add:

* `full_name`
* `phone_number`

You can ask Codex:

> “Update the User model to add `full_name` and `phone_number`,
> and generate the Alembic migration script.”

Codex will:

* Update SQLAlchemy model
* Create migration script
* (Optionally) tell you the SQL that will run on MySQL

---

### Step 4: Add a Payment Microservice

Suppose you have an `orders` service and now you want a **separate payment service**.

Folder view (before):

```text
/app
   main.py
   /routers
      users.py
      orders.py
   /models
      user.py
      order.py
   /services
      order_service.py
```

Ask Codex:

> “Create a new microservice `/payment_service` that:
>
> * has its own `main.py`
> * exposes `POST /payments`
> * simulates payment success/failure
> * uses its own SQLite/MySQL DB (simple).”

Codex can create:

```text
/payment_service
   main.py
   /routers
      payments.py
   /models
      payment.py
   /services
      payment_service.py
```

Then Codex can update your main system to call this new payment service (e.g., using HTTP).

---

### Step 5: Add Logging

Tell Codex:

> “Add structured logging to the project using Python’s `logging` module.
> Log incoming requests, responses, and errors.”

Codex can:

* Create a `logging_config.py`
* Configure log format (timestamp, level, message)
* Add log lines inside routes and services

This is like placing CCTV cameras in important parts of your code.

---

### Step 6: Add Validation

Most FastAPI projects already use **Pydantic models**.
You can enhance them.

Tell Codex:

> “Add strict validation for the user registration request:
>
> * email must be proper format
> * password minimum 8 characters
> * phone_number optional but if present, must be 10–15 digits.”

Codex updates your Pydantic schemas accordingly.

---

## Code Examples

### 1. Add Authentication (Simple)

**Pydantic schema:**

```python
from pydantic import BaseModel, EmailStr

class UserCreate(BaseModel):
    email: EmailStr
    password: str
```

**Router snippet:**

```python
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from .schemas import UserCreate
from .database import get_db
from . import auth_service

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/register")
def register_user(user: UserCreate, db: Session = Depends(get_db)):
    return auth_service.register_user(db, user)
```

Codex can generate `auth_service.register_user` implementation too.

---

### 2. Add New Fields in Database

**Before (User model):**

```python
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True)
    hashed_password = Column(String(255))
```

**After (with new fields):**

```python
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True)
    hashed_password = Column(String(255))
    full_name = Column(String(255), nullable=True)
    phone_number = Column(String(20), nullable=True)
```

Codex can then generate an Alembic migration like:

```python
def upgrade():
    op.add_column('users', sa.Column('full_name', sa.String(length=255), nullable=True))
    op.add_column('users', sa.Column('phone_number', sa.String(length=20), nullable=True))
```

---

### 3. Payment Microservice (Very Simple Example)

`payment_service/main.py`:

```python
from fastapi import FastAPI
from routers import payments

app = FastAPI(title="Payment Service")

app.include_router(payments.router)
```

`payment_service/routers/payments.py`:

```python
from fastapi import APIRouter
from pydantic import BaseModel

router = APIRouter(prefix="/payments", tags=["payments"])

class PaymentRequest(BaseModel):
    order_id: int
    amount: float
    method: str  # "card", "upi", etc.

@router.post("/")
def process_payment(payment: PaymentRequest):
    # Fake success
    return {
        "order_id": payment.order_id,
        "status": "success",
        "transaction_id": "TXN12345"
    }
```

Codex can generate this entire microservice by reading your existing `orders` model.

---

### 4. Add Logging

`logging_config.py`:

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s - %(message)s",
)

logger = logging.getLogger("app_logger")
```

Use in a route:

```python
from logging_config import logger

@router.get("/orders/{order_id}")
def get_order(order_id: int, db: Session = Depends(get_db)):
    logger.info(f"Fetching order with id={order_id}")
    order = order_service.get_order(db, order_id)
    logger.info(f"Order fetched: {order.id}")
    return order
```

Codex can insert such logging in all important routes.

---

### 5. Add Validation

**Before (simple Pydantic model):**

```python
class RegisterUser(BaseModel):
    email: str
    password: str
```

**After (stronger validation):**

```python
from pydantic import BaseModel, EmailStr, Field

class RegisterUser(BaseModel):
    email: EmailStr
    password: str = Field(min_length=8)
    full_name: str | None = None
    phone_number: str | None = Field(
        default=None,
        description="10-15 digit phone number"
    )
```

Codex can easily upgrade existing schemas like this.

---

## How Codex Helps

In this practical session, Codex is your **smart assistant** at every step:

* **Understanding the project**

  * “Scan this project and explain the architecture in bullets.”

* **Adding authentication**

  * “Add JWT-based authentication with register/login and a `/me` endpoint. Use existing DB setup.”

* **Adding new database fields**

  * “Update the User model with `full_name` and `phone_number`, and generate Alembic migration.”

* **Creating payment microservice**

  * “Create a new FastAPI microservice in `/payment_service` with a `POST /payments` endpoint and simple fake response.”

* **Adding logging**

  * “Add centralized logging. Create a `logging_config.py` and use it in all routers.”

* **Adding validation**

  * “Strengthen validation for all request models using EmailStr, min_length, and proper types.”

* **Debugging**

  * “Check all changes for errors and fix imports, types, or broken references.”

You are still the **architect**; Codex is like a senior developer doing the typing and details for you.

---

## Small Exercise

Take any small FastAPI + MySQL project you have (even a toy one with 2–3 endpoints):

1. Open it in VS Code with Codex.
2. Ask Codex:

   * “Explain the project structure in bullets.”
3. Then ask Codex to:

   * Add **JWT authentication** (`/auth/register`, `/auth/login`, `/auth/me`).
   * Add new fields to one of your models (e.g., `created_at`, `updated_at`).
   * Create a simple **payment microservice** in a new folder.
   * Add **logging** for at least one route.
   * Add **validation** rules to a request model.
4. Run the project and test the new features with a tool like **curl**, **Postman**, or **Thunder Client** in VS Code.



