# Chapter 13. Using a Database

*Example: Restaurant booking database*

---

#### 1. Why agents need a database

In the last chapter, we used **files** to save summaries.
Files are like **notebooks**: simple, good for text, but not great for:

* Many records (hundreds or thousands)
* Searching (e.g., “all bookings for today”)
* Avoiding duplicates and mistakes

For that, we use a **database**.

Think of a database as:

* A **tidy register book** in a restaurant
* Each row = one reservation
* You can easily search: “Show all bookings for Friday at 7 pm.”

For agentic AI:

* The **agent** can understand natural language:
  “Book a table for 4 people tomorrow at 8 pm for Rahul.”
* The **database** stores the confirmed booking safely.
* Later the agent can **read** the stored bookings and answer:
  “You already have a booking tomorrow at 8 pm.”

---

#### 2. Our example: Restaurant booking system

We’ll imagine a small restaurant with this data for each reservation:

* `id` – booking ID (number)
* `customer_name` – who booked
* `phone` – contact number
* `date_time` – when the table is booked
* `num_people` – how many people
* `notes` – anything special (“window seat”, “birthday”, etc.)

We’ll use:

* **SQLAlchemy** for Python to define the database table as a *model*
* **SQLite** as the actual database file (simple `.db` file)
* **Autogen agent** + tools to create and read reservations

---

#### 3. Step 1 – Define a SQLAlchemy model for reservations

This is like drawing the **table structure** in code.

```python
from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class Reservation(Base):
    __tablename__ = "reservations"

    id = Column(Integer, primary_key=True, index=True)
    customer_name = Column(String, nullable=False)
    phone = Column(String, nullable=False)
    date_time = Column(DateTime, nullable=False)
    num_people = Column(Integer, nullable=False)
    notes = Column(String, nullable=True)

    def __repr__(self):
        return (
            f"<Reservation(name={self.customer_name}, "
            f"time={self.date_time}, people={self.num_people})>"
        )
```

In simple words:

* `Reservation` is a **Python class** that represents one row.
* Each `Column` is a **field** (like a column in Excel).
* `__tablename__ = "reservations"` means the table name in the DB.

---

#### 4. Step 2 – Create a database and session

Now we tell SQLAlchemy **where** to store data and how to connect.

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# SQLite database file named restaurant.db
DATABASE_URL = "sqlite:///restaurant.db"

engine = create_engine(DATABASE_URL, echo=False)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create the table if it does not exist yet
Base.metadata.create_all(bind=engine)
```

Explanation:

* `engine` is like a **connection pipe** to the database.
* `SessionLocal()` gives us a **session**, which we use to:

  * add rows
  * query rows
  * commit changes

Think of a session like:

> “For the next few minutes, I will make a set of changes, then save them together.”

---

#### 5. Step 3 – Tool functions for the agent

We now write **helper functions** that:

* Take simple Python arguments
* Use the database to **create** or **read** reservations
* Return text the agent can use in replies

##### 5.1. Create a new reservation

```python
from datetime import datetime

def create_reservation(
    customer_name: str,
    phone: str,
    date_time_str: str,
    num_people: int,
    notes: str = ""
) -> str:
    """
    Create a new reservation in the database.
    date_time_str should be in 'YYYY-MM-DD HH:MM' format.
    """
    db = SessionLocal()
    try:
        # Parse date string into a datetime object
        dt = datetime.strptime(date_time_str, "%Y-%m-%d %H:%M")

        new_res = Reservation(
            customer_name=customer_name,
            phone=phone,
            date_time=dt,
            num_people=num_people,
            notes=notes,
        )

        db.add(new_res)
        db.commit()
        db.refresh(new_res)

        return (
            f"Reservation created with ID {new_res.id} for "
            f"{new_res.customer_name} on {new_res.date_time} "
            f"for {new_res.num_people} people."
        )
    except Exception as e:
        db.rollback()
        return f"Failed to create reservation: {e}"
    finally:
        db.close()
```

##### 5.2. Get reservations for a given date

```python
def get_reservations_for_date(date_str: str) -> str:
    """
    Return all reservations for a given date (YYYY-MM-DD).
    """
    db = SessionLocal()
    try:
        date_only = datetime.strptime(date_str, "%Y-%m-%d").date()

        results = (
            db.query(Reservation)
            .filter(Reservation.date_time.between(
                datetime.combine(date_only, datetime.min.time()),
                datetime.combine(date_only, datetime.max.time()),
            ))
            .order_by(Reservation.date_time)
            .all()
        )

        if not results:
            return f"No reservations found for {date_str}."

        lines = [f"Reservations for {date_str}:"]
        for r in results:
            lines.append(
                f"- {r.date_time.strftime('%H:%M')} | "
                f"{r.customer_name} ({r.num_people} people)"
            )
        return "\n".join(lines)

    except Exception as e:
        return f"Error fetching reservations: {e}"
    finally:
        db.close()
```

These two functions are our **database tools**.

---

#### 6. Step 4 – Connect Autogen to the database tools

Now we register these functions as **tools** so the agent can use them.

```python
from autogen import AssistantAgent, UserProxyAgent

# Wrap Python functions as tools
create_reservation_tool = {
    "name": "create_reservation",
    "description": (
        "Create a restaurant reservation. "
        "Arguments: customer_name, phone, date_time_str 'YYYY-MM-DD HH:MM', "
        "num_people (int), notes (optional)."
    ),
    "func": create_reservation,
}

get_reservations_tool = {
    "name": "get_reservations_for_date",
    "description": (
        "List reservations for a date. "
        "Argument: date_str 'YYYY-MM-DD'."
    ),
    "func": get_reservations_for_date,
}

# Create an Autogen assistant agent that can use these tools
booking_agent = AssistantAgent(
    name="booking_agent",
    system_message=(
        "You are a restaurant booking assistant. "
        "You can create and list reservations using the tools provided. "
        "Always ask for date, time, number of people, and a name "
        "before creating a reservation."
    ),
    tools=[create_reservation_tool, get_reservations_tool],
)

# User proxy to start a conversation
user = UserProxyAgent(name="user")

# Example conversation
message = (
    "Please book a table for 3 people tomorrow at 19:30 for Priya. "
    "Phone: 9876543210. Add note 'birthday'. "
    "Use date 2025-11-25 19:30."
)

reply = user.initiate_chat(booking_agent, message=message)
print("Agent reply:\n", reply)
```

In plain words:

* The **user** speaks naturally.
* The **booking_agent**:

  * understands the request,
  * calls `create_reservation` with the right arguments,
  * and replies with the confirmation message.
* All bookings are safely stored in `restaurant.db`.

This is a very realistic pattern for:

* Clinic appointments
* Classroom booking
* Hotel reservations
* Any system where **structured records** are important

---

#### 7. Takeaway

* A **database** is structured, searchable memory.
* **SQLAlchemy models** define tables in Python.
* Tool functions (`create_reservation`, `get_reservations_for_date`) are a safe bridge from the agent to the database.
* Autogen agents can use these tools to **create and query reservations** using natural language.

---

#### Codex Instruction for this Chapter

> **“Create a SQLAlchemy model for a restaurant reservations table (id, customer_name, phone, date_time, num_people, notes). Then generate Python code that connects this model to Autogen by exposing two tools: one to create a reservation and one to list reservations for a given date.”**
