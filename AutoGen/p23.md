# Chapter 23. Logging, Monitoring & Debugging

**Tracking agent conversations and saving every attempt**

---

#### 1. Why logging matters for agentic systems

When you build agent workflows, the agent behaves like a smart human assistant:

* It thinks
* It reasons
* It calls tools
* It tries different steps

But sometimes:

* It gives a wrong answer
* It gets stuck
* It calls the wrong tool
* It tries something unusual

To improve the system, you must **see what the agent tried**.

Logging gives you a simple way to:

* Track every message
* Record tool calls
* See how the agent reached its answer
* Debug failures
* Reproduce bugs later

You can think of it like **a CCTV camera inside your agent’s mind**.

---

#### 2. What do we want to log?

You don’t need anything complicated.
A simple record is enough:

* Timestamp
* Who sent the message (user, agent, tool)
* Text of the message
* Any error that happened

All of this can go into **a single file**, like:

```
agent_logs.txt
```

Later, you can build dashboards, charts, or deeper analytics.

But for now, **simple text logging** is more than enough for understanding your agent.

---

#### 3. A simple logging pattern

Imagine a mailbox where every letter from the agent, the user, or the tool is stored.

We’ll create a helper function:

```python
def log_message(role: str, message: str):
    with open("agent_logs.txt", "a", encoding="utf-8") as f:
        f.write(f"[{datetime.now()}] [{role}] {message}\n")
```

Every time:

* User speaks
* Agent replies
* Tool returns something

You call:

```python
log_message("agent", agent_reply)
log_message("user", user_input)
log_message("tool", tool_output)
```

Step-by-step and simple.

---

#### 4. Full example: Logging every message in a small agent script

Here is a **beginner-friendly** example using a tiny agent-like function.

```python
import time
from datetime import datetime

def log_message(role: str, message: str):
    """
    Append a message to agent_logs.txt with timestamp.
    role = 'user', 'agent', or 'tool'
    """
    with open("agent_logs.txt", "a", encoding="utf-8") as f:
        f.write(f"[{datetime.now()}] [{role.upper()}] {message}\n")


def simple_agent(user_input: str) -> str:
    """
    Fake agent:
    - logs user input
    - responds based on simple logic
    - logs agent reply
    """
    log_message("user", user_input)

    try:
        x = float(user_input)
        reply = f"The agent predicts: {2 * x}"
    except ValueError:
        reply = f"I received your message: {user_input}"

    log_message("agent", reply)
    return reply


# Example of a tool
def my_tool(value: float) -> float:
    """
    Simple doubling tool.
    We log both the call and result.
    """
    log_message("tool", f"Tool called with value={value}")
    result = value * 2
    log_message("tool", f"Tool returned result={result}")
    return result


# Running the agent
if __name__ == "__main__":
    while True:
        user_in = input("You: ")
        if user_in.lower() == "exit":
            print("Goodbye!")
            break

        response = simple_agent(user_in)
        print("Agent:", response)
```

When this script runs:

* Every user input gets logged
* Every agent reply gets logged
* If the agent calls a tool, that tool also logs its input/output

Your file will look something like:

```
[2025-11-24 19:15:20] [USER] 10
[2025-11-24 19:15:20] [AGENT] The agent predicts: 20.0
[2025-11-24 19:15:25] [USER] Hello agent
[2025-11-24 19:15:25] [AGENT] I received your message: Hello agent
```

Very clean.
Very easy to debug.

---

#### 5. Logging inside Autogen agent workflows

When you use Autogen, the logging idea is the same.

Autogen lets you intercept messages inside the agent loop.
Inside your custom agent class, you can plug in the same `log_message()` calls.

Simplified idea:

```python
class LoggingAgent(AssistantAgent):
    def send(self, message, recipient):
        log_message("agent", message)
        return super().send(message, recipient)

class LoggingUser(UserAgent):
    def send(self, message, recipient):
        log_message("user", message)
        return super().send(message, recipient)
```

All messages will go into your text file.
Later, you can search, filter, or analyze patterns.

---

#### 6. Adding error logging

When something fails, you want to know **why**.

Add this inside your agent code:

```python
import traceback

try:
    result = my_tool(value)
except Exception as e:
    log_message("error", traceback.format_exc())
```

Now even errors are captured and saved.

This helps when your agent behaves strangely, because you can check:

* Did the API fail?
* Did the tool raise an exception?
* Did the agent send wrong data?

---

#### 7. Takeaway

Logging is like keeping a diary of your agent’s thoughts.

It gives you:

* Transparency
* Debug-ability
* A full record of attempts
* A way to replay what happened
* The confidence to improve your system safely

Even a simple text file can completely change how easy agent debugging becomes.

---

#### 8. Codex Instruction Prompt for this Chapter

You can give this to Codex:

> “Add file logging for every message exchanged in this agent workflow. Create a log_message(role, text) function and call it for user messages, agent messages, and tool outputs. Save everything to agent_logs.txt with timestamps and clear role labels.”
