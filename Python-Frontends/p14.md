# **Chapter 14. Client-Side Validation vs Server-Side Validation**

---

## 1. Simple Introduction

When users fill a form, they can make mistakes:

* leave **required fields** empty
* type **wrong email**
* give **age = -5**
* send **invalid data** to the backend

To handle this, we use **validation**.

There are two main types:

1. **Client-side validation** → checks in the **frontend** (in the browser / UI)
2. **Server-side validation** → checks in the **backend** (API / server)

Both are important.
Frontend is for **quick feedback**, backend is for **real protection**.

---

## 2. Real-Life Analogy

Imagine a bank form:

* At the **front counter**, the clerk checks:

  * “Name is filled?”
  * “Phone number has 10 digits?”
    This is like **client-side validation**.

* Later, inside the **back office**, the bank system checks:

  * “Is this account number valid?”
  * “Is age allowed for this product?”
    This is like **server-side validation**.

If either stage finds an error, they **reject** or **correct** the form.

---

## 3. Key Concepts (Explained Gently)

### Client-Side Validation (Frontend)

* Done in the **UI code** (Streamlit / Gradio / NiceGUI).
* Checks simple things:

  * required fields not empty
  * email looks like an email
  * age is a positive number

**Goal:**
Give users **instant feedback** before sending to backend.

**Important:**
Client-side checks can be **bypassed**, so they are not enough for security.

---

### Server-Side Validation (Backend)

* Done in the **API** (FastAPI, Django, etc.).
* Always runs, no matter what the UI did.
* Checks:

  * all required fields
  * formats
  * business rules (no duplicate email, no invalid IDs, etc.)

**Goal:**
Protect your **database and system**.
Even if user sends bad data, backend stops it.

---

### Showing Helpful Messages

* Show **clear error messages**:

  * “Email is required”
  * “Please enter a valid email like [name@example.com](mailto:name@example.com)”
* Show message **near the field**, or just below the form.
* Don’t blame the user, just guide them.

---

## 4. Step-by-Step: Simple Frontend + Backend Validation (Streamlit)

We’ll use a “**User Registration**” form:

* name (required)
* email (required, valid format)

Frontend: **Streamlit**
Backend: simple **FastAPI** idea.

---

### 4.1 Simple Email Check in Frontend

A quick email rule:

* It must contain **“@”** and a **“.”** after it.
  This is not perfect, but good for beginners.

```python
def looks_like_email(email: str) -> bool:
    return "@" in email and "." in email
```

---

### 4.2 Streamlit Frontend with Client-Side Validation

```python
import streamlit as st
import requests

st.title("User Registration")

name = st.text_input("Full Name *")
email = st.text_input("Email *")

if st.button("Register"):
    # CLIENT-SIDE VALIDATION
    errors = []

    if not name:
        errors.append("Name is required.")
    if not email:
        errors.append("Email is required.")
    elif "@" not in email or "." not in email:
        errors.append("Please enter a valid email (like name@example.com).")

    if errors:
        for e in errors:
            st.error(e)
    else:
        # If frontend validation passes, call backend
        payload = {"name": name, "email": email}
        try:
            response = requests.post(
                "http://localhost:8000/register",
                json=payload,
                timeout=5
            )
            if response.status_code == 201:
                st.success("Registration successful!")
            else:
                # Show server-side validation error (if provided)
                try:
                    data = response.json()
                    msg = data.get("detail", "Registration failed.")
                except Exception:
                    msg = "Registration failed."
                st.error(f"Server said: {msg}")
        except Exception as e:
            st.error(f"Could not reach server: {e}")
```

Here we do:

1. **Client-side checks** before the API call.
2. Only if OK → we send data to backend.
3. If backend returns error → we show backend error.

---

## 5. Server-Side Validation Example (FastAPI Concept)

Backend must **also** validate, never trust the UI.

```python
# Example (not run in Streamlit) – FastAPI style

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, EmailStr

app = FastAPI()

class UserCreate(BaseModel):
    name: str
    email: EmailStr  # built-in email validation

fake_registered_emails = set()

@app.post("/register", status_code=201)
def register(user: UserCreate):
    # Server-side: check for duplicates
    if user.email in fake_registered_emails:
        raise HTTPException(
            status_code=400,
            detail="This email is already registered."
        )

    fake_registered_emails.add(user.email)
    return {"message": "Registered"}
```

Backend checks:

* email format (via `EmailStr`)
* uniqueness (no duplicate email)

If something is wrong, backend returns a **400 error** with helpful message.

---

## 6. Showing Helpful Messages Near Fields (Frontend Idea)

In Streamlit, we can show “field-specific” messages by placing checks near them.

Simple pattern:

```python
import streamlit as st

st.title("User Registration")

name = st.text_input("Full Name *")
if not name:
    st.caption("⚠ Name cannot be empty.")

email = st.text_input("Email *")
if email and ("@" not in email or "." not in email):
    st.caption("⚠ Please enter a valid email like name@example.com.")
```

* `st.caption` appears **just under** the field.
* This feels like the message is “attached” to the input.

Then when pressing **Register**, you still run final validation.

---

## 7. Putting It All Together: Flow Diagram

```text
User types data in form
        │
        ▼
Client-side validation (frontend)
    - empty fields?
    - email format?
        │
        ├── If errors → show messages, stop here
        │
        ▼
Send data to backend API
        │
        ▼
Server-side validation (backend)
    - email format (strict)
    - business rules (unique, min/max, etc.)
        │
        ├── If errors → return 400 + error text
        │
        ▼
Frontend reads backend response
        │
        ├── If error → show message from server
        └── If OK → show success message
```

---

## 8. How Codex Can Help Here

You can ask Codex to generate and refine all of this for you.

### Prompt 1 – Add Client-Side Checks

> “Here is my Streamlit registration form. Add client-side validation so name and email are required and email has a simple format check. Show st.error messages if validation fails.”

---

### Prompt 2 – Add Server-Side Validation

> “Generate a FastAPI backend with a /register endpoint that validates email using Pydantic EmailStr and rejects duplicate emails with a clear error message.”

---

### Prompt 3 – Connect Frontend and Backend

> “Take this Streamlit form and connect it to the FastAPI /register endpoint using requests.post. If backend returns an error with a ‘detail’ field, show it using st.error.”

---

### Prompt 4 – Field-Level Messages

> “Improve this Streamlit UI so that small helper messages are shown under the email field when the format is wrong, using st.caption.”

---

### Prompt 5 – Reusable Validation Functions

> “Create small reusable Python functions validate_name() and validate_email() and use them inside my Streamlit form to keep the code clean.”

---

## 9. Mini Exercises for Students

### Exercise 1 – Add More Frontend Checks

Add these client-side validations:

* Password must be at least 8 characters.
* Age must be between 18 and 100.

Show clear error messages.

---

### Exercise 2 – Handle Backend Error Messages

Assume backend sends JSON like:

```json
{ "detail": "Age must be at least 21 for this service." }
```

Show this message in Streamlit using `st.error`.

---

### Exercise 3 – Per-Field Messages

Show a warning under the age field if age < 18:

* “⚠ You must be at least 18 years old to register.”

---

### Exercise 4 – Try Breaking the System

Use a tool like **curl** or **Postman** (or simple `requests` script) to send:

* invalid emails
* empty names

Check that the **backend** still rejects them even if frontend is not used.

---
