# **Chapter 9. Using Codex to Design API Contracts**

## **1. Simple Introduction**

When frontend and backend teams work together, both must agree on:

* What data will come **from** the backend
* What data the UI will **send** to the backend
* What exact fields will be used
* What JSON shape will be returned

This agreement is called an **API Contract**.

The best part?
You can ask **Codex** to generate these contracts cleanly, quickly, and consistently.

---

## **2. Real-Life Analogy**

Think of an API contract like a **purchase invoice** in a shop.

The invoice clearly shows:

* What items you are buying
* Quantity
* Price
* Total
* Buyer details

Both the shop and the customer see the *same* invoice.
No confusion.

An API contract works the same way:
Frontend and backend both see the same “specification paper”.

---

## **3. Key Concepts (Explained Gently)**

### **1) JSON Schema**

A JSON Schema describes the structure of a JSON object:

* Which fields exist
* What type each field is (string, number, boolean, array, object)
* Which fields are required

### **2) Pydantic Models / Dataclasses**

These are Python classes describing the same structure.
Backend uses them for validation and automatic documentation.

### **3) Shared API Contract Document**

A simple document that tells everyone:

* Request shape
* Response shape
* Field names
* Field types
* Sample JSON

### **4) Why Codex is useful**

Codex can generate:

* JSON schemas
* Pydantic models
* Dataclasses
* Example request/response payloads

Just by giving a short description.

---

## **4. Step-by-Step Explanation**

### **Step 1 — Describe your UI need**

Example:
“I want a product entry form with name, price, and category.”

### **Step 2 — Ask Codex to generate JSON schema**

Codex produces a clean JSON Schema.

### **Step 3 — Ask Codex to translate that into Pydantic models**

These models ensure backend validation.

### **Step 4 — Ask Codex to create sample request/response payloads**

Useful for documentation.

### **Step 5 — Combine everything into an API Contract Document**

You can put this in `/docs/api/products_v1.md`.

---

## **5. JSON Schema Generation (Simple Explanation)**

### What is JSON Schema?

A JSON Schema is like a **blueprint** of your data.

Example schema:

```json
{
  "type": "object",
  "properties": {
    "name": {"type": "string"},
    "price": {"type": "number"},
    "category": {"type": "string"}
  },
  "required": ["name", "price"]
}
```

Codex can generate this instantly from a plain-English description.

---

## **6. Example Codex Prompt for JSON Schema**

### **Prompt**

“Generate a JSON schema for a product with id, name, price, category, and in_stock. Make id required and integer. Others may be optional.”

Codex output will look like:

```json
{
  "type": "object",
  "properties": {
    "id": {"type": "integer"},
    "name": {"type": "string"},
    "price": {"type": "number"},
    "category": {"type": "string"},
    "in_stock": {"type": "boolean"}
  },
  "required": ["id"]
}
```

---

## **7. Creating Pydantic Models Using Codex**

### Why Pydantic?

FastAPI uses Pydantic for data validation and automatic documentation.

### Example Codex Prompt

**Prompt:**
“Convert this JSON schema into a Python Pydantic model.”

Codex may respond with:

```python
from pydantic import BaseModel

class Product(BaseModel):
    id: int
    name: str | None = None
    price: float | None = None
    category: str | None = None
    in_stock: bool | None = None
```

### Dataclass Version

```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class Product:
    id: int
    name: Optional[str] = None
    price: Optional[float] = None
    category: Optional[str] = None
    in_stock: Optional[bool] = None
```

Codex can generate both types easily.

---

## **8. Creating an API Contract Document**

Your API contract should include:

### **A) Endpoint**

```
GET /api/v1/products
```

### **B) Request Parameters**

```
?page=1&limit=10&search=fan
```

### **C) Response JSON Schema**

(Generated by Codex)

### **D) Response Example**

```json
{
  "items": [
    {"id": 1, "name": "Fan", "price": 900},
    {"id": 2, "name": "Cooler", "price": 2500}
  ],
  "total": 2
}
```

### **E) Notes**

* “name” always string
* “price” always number
* Sorting available on: name, price

This small document acts like a “universal agreement”.

---

## **9. How Codex Can Help You Here**

### **Useful Prompts**

1. **“Codex, draft JSON request and response schemas for a student registration API.”**
2. **“Codex, convert this JSON schema into Pydantic models.”**
3. **“Codex, create sample request and response JSON for my contract file.”**
4. **“Codex, combine all models into a single API Contract Document for v1.”**
5. **“Codex, refactor this messy JSON into a clean, consistent schema.”**
6. **“Codex, generate dataclasses for both request and response objects.”**
7. **“Codex, write API contract documentation in markdown format.”**

Codex can produce clean, standard documentation far faster than manual writing.

---

## **10. Mini Exercises for Students**

### ✔️ Exercise 1

Describe a "User Profile" screen in plain English.
Ask Codex to generate:

* JSON request schema
* JSON response schema
* Pydantic models

### ✔️ Exercise 2

Create an API contract for “Order Placement” with:

* items (list)
* address
* payment method

Ask Codex to prepare:

* request schema
* response schema
* example payloads

### ✔️ Exercise 3

Create a shared contract document for a “Login API”.
Include:

* endpoint
* request schema
* response schema
* sample JSON
* error JSON

---
