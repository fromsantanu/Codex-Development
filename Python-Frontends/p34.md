### Chapter 34. Form Error Messages and Validation Feedback

---

## 1. Simple Introduction

When users fill a form, mistakes are very common:

* Missing information
* Wrong format (example: wrong email)
* Values that do not meet the rules (example: age must be a number)

If we don’t guide the user properly, they feel frustrated.
A good frontend should:

* Show **which field** has the problem
* Show **simple and friendly messages**
* Keep the user’s **partially filled data** so they don’t have to type everything again
* Show **backend validation errors** (example: *“email already exists”*)

Good error messages make a form feel supportive instead of irritating.

---

## 2. Real-Life Analogy

Imagine a **bank account opening form**.
You are filling it at the counter.
If something is wrong, the staff does not tell you:

> “THE FORM IS WRONG!”

They tell you gently:

* “Please write your full name here.”
* “This email is already registered.”
* “Please sign on page 2.”

And they **do not throw away your half-filled form**.
They give it back with the fields you already filled preserved.

Frontend forms should behave exactly like this.

---

## 3. Key Concepts (Explained Gently)

### 3.1 Field-Level Validation

Check each field separately, such as:

* Name cannot be empty
* Email must contain “@”
* Age must be a number

The error should appear **near the field**, not at the top.

---

### 3.2 Server-Side Validation

Backend often checks things frontend cannot check, like:

* “Email already exists”
* “Username taken”
* “Phone number must be unique”

Frontend should display this **exact message**, in friendly form.

---

### 3.3 Keeping User Data After Error

When a form has errors:

* Do *not* clear all fields
* Keep all entered values
* Only highlight the problematic fields

This gives a smooth experience.

---

### 3.4 Combining Frontend + Backend Validation

A complete form usually works like this:

```
User fills form
      │
      ▼
Frontend validation (quick checks)
      │
      ▼
Send request to backend
      │
      ▼
Backend validation (deep checks)
      │
      ├─ Success → create user / record
      │
      └─ Failure → “email already exists”, “invalid input”
```

Both sides cooperate.

---

## 4. Step-by-Step Explanation

Let’s build a **simple registration form** with:

* name
* email
* password

We will handle:

* frontend errors
* backend errors
* keep user data intact

---

### Step 1: Frontend Quick Checks

Before sending data to backend, check simple things:

```python
errors = {}

if not name:
    errors["name"] = "Name is required."

if "@" not in email:
    errors["email"] = "Please enter a valid email."

if len(password) < 6:
    errors["password"] = "Password must be at least 6 characters."
```

If `errors` is not empty, show them near each field.

---

### Step 2: Send Data to Backend

If frontend checks pass, send request:

```python
response = requests.post(API_URL, json={
    "name": name,
    "email": email,
    "password": password
})
```

---

### Step 3: Handling Backend Validation Errors

Backend may return something like:

```json
{
  "error": "Email already exists"
}
```

In frontend, show this under the email field:

> “This email is already registered. Please use another one.”

---

### Step 4: Keep User’s Input

Never clear data unless the submission succeeds.
In Streamlit or NiceGUI, simply store inputs in state variables.

Example:

```python
st.session_state["name"] = name
st.session_state["email"] = email
```

Even after error messages, these values remain visible.

---

## 5. Example UI Code (Using Streamlit)

Below is a clean and simple Streamlit version:

```python
import streamlit as st
import requests

API_URL = "http://localhost:8000/register"

# Initialize fields if not present
if "name" not in st.session_state:
    st.session_state.name = ""
if "email" not in st.session_state:
    st.session_state.email = ""
if "password" not in st.session_state:
    st.session_state.password = ""

st.title("User Registration")

name = st.text_input("Name", st.session_state.name)
email = st.text_input("Email", st.session_state.email)
password = st.text_input("Password", st.session_state.password, type="password")

errors = {}

if st.button("Register"):
    # Frontend validation
    if not name:
        errors["name"] = "Name is required."
    if "@" not in email:
        errors["email"] = "Please enter a valid email address."
    if len(password) < 6:
        errors["password"] = "Password must be at least 6 characters."

    if errors:
        st.error("Please fix the highlighted errors.")
    else:
        # Save fields so data stays on screen
        st.session_state.name = name
        st.session_state.email = email
        st.session_state.password = password

        try:
            response = requests.post(API_URL, json={
                "name": name,
                "email": email,
                "password": password
            })
            if response.status_code == 200:
                st.success("Registration successful!")
            else:
                data = response.json()
                backend_error = data.get("error", "Something went wrong.")
                st.error(backend_error)
        except Exception:
            st.error("Unable to reach server. Please try again.")
            

# Show field-level errors
if "name" in errors:
    st.warning(errors["name"])
if "email" in errors:
    st.warning(errors["email"])
if "password" in errors:
    st.warning(errors["password"])
```

This example demonstrates:

* per-field validation
* keeping user data
* showing backend messages
* no loss of data during errors

---

## 6. Simple Backend Example (FastAPI)

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

registered_emails = {"test@example.com"}

class Register(BaseModel):
    name: str
    email: str
    password: str

@app.post("/register")
def register_user(data: Register):
    if data.email in registered_emails:
        raise HTTPException(status_code=400, detail="Email already exists")
    return {"message": "User created"}
```

This shows a typical backend validation scenario.

---

## 7. How Codex Helps You Here

You can ask Codex to:

### ✔ Add field-level validation

> “Add frontend validation for empty name, invalid email, and short password in this Streamlit form.”

### ✔ Convert backend errors into UI messages

> “Read the backend’s JSON error message and show it below the corresponding field using Streamlit.”

### ✔ Keep user data on screen

> “Modify this form so all entered values are stored in `session_state` so that data stays even after errors.”

### ✔ Create a reusable validation function

> “Generate a Python function `validate_registration_form(name, email, password)` that returns an `errors` dictionary.”

### ✔ Suggest better messages

> “Rewrite these error messages in simple, friendly language: [paste messages].”

Codex can automate repetitive validation boilerplate.

---

## 8. Mini Exercises for Students

Try these small tasks to practice.

### **Exercise 1**

Add one more field **phone number** and validate:

* must be 10 digits
* must be numeric

Show error below the field.

---

### **Exercise 2**

Modify the backend to return:

```json
{"error": "Phone number already registered"}
```

Show this message nicely in the frontend.

---

### **Exercise 3**

Add a green success message after successful registration and automatically clear only the password field.

---

### **Exercise 4 (Optional)**

Convert this Streamlit form into a **NiceGUI** version using `ui.input()` and `ui.notify()`.

---

This chapter helps your students understand how to make forms that feel friendly and professional—just like real applications people trust.
