### Chapter 35. Loading States, Spinners, and Disabled Buttons

---

## 1. Simple Introduction

When a user clicks a **Submit** button on a form, something happens in the background:

* The frontend sends a request to the backend
* The backend does some work (database, calculation, API call)
* Then it sends back a response

This takes **time** â€“ sometimes 1â€“2 seconds, sometimes more.

If we **do nothing** during this time:

* The user may click many times
* The same request gets sent again and again
* They may think â€œApp is stuckâ€ and close the page

So a good frontend should:

* **Disable the button** while the request is running
* Show a **spinner / â€œLoadingâ€¦â€ message**
* **Prevent multiple submissions** of the same form

---

## 2. Real-Life Analogy

Think about a **lift (elevator) button**.

* You press the button once
* The light on the button turns on (this is like a **loading state**)
* While the light is on, pressing it again **does nothing**
* When the lift comes, the light goes off

We donâ€™t press the lift button 20 times because:

* The button shows that it is **already working on your request**

Loading states, spinners, and disabled buttons in frontend are like:

* The **light on the lift button**
* They say: â€œYour request is in progress, please wait.â€

---

## 3. Key Concepts (Explained Gently)

### 3.1 Loading State

A **loading state** is usually a simple variable like:

```python
is_loading = True / False
```

It means:

* `True` â†’ we are currently calling the backend
* `False` â†’ we are free to send a new request

---

### 3.2 Spinner / Progress Indicator

A **spinner** or **progress bar** shows the user:

* â€œWe are working on itâ€
* â€œPlease wait a momentâ€

This reduces anxiety.
Itâ€™s like a staff member saying:

> â€œOne minute please, Iâ€™m processing your request.â€

---

### 3.3 Disabled Button

A **disabled button**:

* Looks greyed out
* Cannot be clicked
* Stops multiple submissions

Example in real life:
In some ATMs, after you press â€œWithdrawâ€, the button doesnâ€™t work again until the process finishes.

---

### 3.4 Preventing Multiple Submissions

If user clicks Submit 5 times:

* You may create **5 orders**, **5 payments**, or **5 registrations** ğŸ˜…

To prevent this:

* Use `is_loading` flag
* Disable button when `is_loading == True`
* Ignore new clicks during that time

---

## 4. Step-by-Step Explanation

Weâ€™ll build a very simple flow:

> A **â€œCheck Balanceâ€** form
>
> * User enters account number
> * Clicks â€œCheck Balanceâ€
> * We call backend
> * Button becomes disabled while waiting
> * Spinner appears
> * Result is shown when ready

Weâ€™ll use **Streamlit** here.

Steps:

1. Create input for account number
2. Add a `loading` flag in `st.session_state`
3. Disable the button when `loading` is `True`
4. Show `st.spinner` while doing the API call
5. Re-enable the button after the response comes

---

## 5. Example UI Code (Using Streamlit)

```python
import time
import requests
import streamlit as st

API_URL = "http://localhost:8000/check_balance"

# Initialize loading state
if "loading" not in st.session_state:
    st.session_state.loading = False

st.title("Check Account Balance")

account_number = st.text_input("Account Number")

# The button will be disabled when loading is True
check_button = st.button(
    "Check Balance",
    disabled=st.session_state.loading
)

if check_button and not st.session_state.loading:
    # Set loading state to True
    st.session_state.loading = True

    # Show spinner while calling API
    with st.spinner("Contacting bank server..."):
        try:
            # Simulate some delay or real API call
            # time.sleep(2)  # fake delay
            response = requests.post(API_URL, json={"account_number": account_number}, timeout=5)
            if response.status_code == 200:
                data = response.json()
                balance = data.get("balance", "N/A")
                st.success(f"Balance for account {account_number}: â‚¹{balance}")
            else:
                st.error("Server returned an error. Please try again.")
        except requests.exceptions.RequestException:
            st.error("Unable to reach the server. Please check your internet connection.")
        finally:
            # Turn loading state OFF so button works again
            st.session_state.loading = False

# Show small info if currently loading
if st.session_state.loading:
    st.info("Please wait, your request is being processed...")
```

### Whatâ€™s happening here?

1. `st.session_state.loading` keeps track of whether an API call is in progress.
2. The button has `disabled=st.session_state.loading`, so it becomes unclickable while loading.
3. `with st.spinner("...")` shows a spinner and message during the API call.
4. In `finally`, we **always** set `loading = False` (even if there is an error).
5. We prevent multiple submissions by not allowing another click while `loading` is True.

---

### Optional: Add a Progress Bar

If you want to give more feedback, you can add a **progress bar**:

```python
if check_button and not st.session_state.loading:
    st.session_state.loading = True

    progress = st.progress(0)

    with st.spinner("Contacting bank server..."):
        try:
            for i in range(100):
                time.sleep(0.02)  # fake work
                progress.progress(i + 1)
            # After loop, pretend we got a response
            st.success("Balance: â‚¹10,000")
        finally:
            st.session_state.loading = False
```

This is just visual, but it feels more â€œaliveâ€ to the user.

---

### Simple Text Diagram

```text
User clicks "Check Balance"
          â”‚
          â–¼
Set loading = True
Disable button   â† prevents multiple clicks
Show spinner
          â”‚
          â–¼
Call backend API
          â”‚
          â”œâ”€ Success â†’ show result message
          â””â”€ Error   â†’ show error message
          â”‚
          â–¼
Set loading = False
Enable button again
Hide spinner
```

---

## 6. Simple Backend API Example

A tiny FastAPI backend for `/check_balance`:

```python
from fastapi import FastAPI
from pydantic import BaseModel
import time

app = FastAPI()

class BalanceRequest(BaseModel):
    account_number: str

@app.post("/check_balance")
def check_balance(data: BalanceRequest):
    # Simulate slow processing
    time.sleep(2)
    # Always return the same balance for demo
    return {"balance": 10000}
```

So the frontend:

* Calls `/check_balance`
* Shows spinner for ~2 seconds
* Then displays the balance

If the backend is slow, the UI still feels controlled and clear.

---

## 7. How Codex Helps You Here

Codex can quickly add all these â€œnice behaviourâ€ pieces.

You can ask Codex to:

1. **Add a loading state and spinner**

   > â€œHere is my Streamlit form. Please add a loading flag in `st.session_state`, show a spinner while the API call is happening, and disable the submit button during that time.â€

2. **Prevent double submissions**

   > â€œModify this code so that the user cannot submit the form again until the current API request finishes.â€

3. **Add a progress bar simulation**

   > â€œIn this Streamlit app, add a progress bar that fills from 0 to 100 while waiting for the backend.â€

4. **Port logic to another framework**

   > â€œConvert this Streamlit loading/spinner/disabled button logic into NiceGUI code using `ui.button` and `button.disable()`/`button.enable()`.â€

5. **Refactor loading logic into helper functions**

   > â€œRefactor this code to move API calling and loading state management into a separate function called `call_with_loading()`.â€

Codex saves you time on all the small, repetitive pieces.

---

## 8. Mini Exercises for Students

Try these to practice.

### **Exercise 1: Registration Form with Loading State**

Create a **user registration** form with fields:

* name
* email
* password

When the user clicks â€œRegisterâ€:

* Disable the button
* Show a spinner
* Wait 2 seconds using `time.sleep(2)` to simulate backend
* Then show â€œRegistration successful!â€

---

### **Exercise 2: Prevent Double Order**

Make a â€œPlace Orderâ€ button that:

* On click, shows â€œOrder placed!â€ after 3 seconds
* Button must stay disabled while the message is being prepared
* If the user clicks quickly many times, the order should still only be processed once

---

### **Exercise 3: Progress Bar Demo**

Create a fake **â€œGenerate Reportâ€** feature:

* User clicks â€œGenerate Reportâ€
* Show a progress bar going from 0 to 100
* Show â€œReport ready!â€ at the end
* Prevent the user from clicking again while progress is running

---

### **Exercise 4 (Optional â€“ NiceGUI)**

Using NiceGUI:

* Create a button that calls an async function
* Disable the button while the function runs
* Use `ui.spinner()` or `ui.label("Loading...")` as indicator

---

Once students understand loading states, spinners, and disabled buttons, their frontends will start to feel much more **professional**, even with very simple code.
