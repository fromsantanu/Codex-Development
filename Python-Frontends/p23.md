# **Chapter 23. Managing State in Streamlit / NiceGUI**

State simply means **“remembering something between user actions.”**
This chapter shows how Streamlit and NiceGUI handle state, how to avoid resets, and how to design stable, predictable UIs.

---

## **1. Simple Introduction**

When a user clicks buttons, changes dropdowns, or moves through the UI, the page may refresh. If we don’t use state correctly:

* selected item disappears
* cart becomes empty
* filters reset
* login token vanishes

This creates frustration.

State fixes this by giving your app a small “memory.”

---

## **2. Real-Life Analogy**

Think of a **reception counter at a clinic**.

When you say, “I want to meet Dr. Roy,” the receptionist writes your name in a small register.
Even if she answers phone calls or talks to others in-between, she **does not forget your name**.

This small register = **state** in your frontend.

---

## **3. Key Concepts (Explained Gently)**

### **a) Streamlit: `st.session_state`**

A built-in dictionary that remembers values:

```
st.session_state["user"]
st.session_state["cart"]
st.session_state["filter"]
```

It lasts for the whole session until page refresh by browser tab close.

---

### **b) NiceGUI: Using Variables, Classes, or ui.storage**

NiceGUI offers flexible ways:

* simple Python variables
* custom classes
* `ui.storage` (browser localStorage)

These survive interactions better and do not reset easily.

---

### **c) Why Reset Problems Happen**

Reset happens when:

* variables are created inside the main UI block without checking
* new values overwrite old values
* code re-runs fully on every interaction (Streamlit does this)

We must **initialize once**, and **update carefully**.

---

## **4. Step-by-Step Explanation**

### **Step 1: Identify what should persist**

Examples:

* logged-in user
* selected date
* cart items
* page number in table
* last uploaded file

---

### **Step 2: Initialize state only once**

Streamlit:

```python
if "cart" not in st.session_state:
    st.session_state.cart = []
```

NiceGUI:

```python
class Store:
    cart = []
store = Store()
```

or:

```python
ui.storage['cart'] = ui.storage.get('cart', [])
```

---

### **Step 3: Update state only when an event happens**

Never reassign state inside the main page without a condition.

---

### **Step 4: Use state to build stable UI**

Read from state when drawing widgets so the values do not reset.

---

## **5. Example UI Code – Streamlit**

### **Managing State Correctly**

```python
import streamlit as st

st.title("Managing State in Streamlit")

# Initialize once
if "name" not in st.session_state:
    st.session_state.name = ""

# Text input that updates state
name = st.text_input("Enter your name", st.session_state.name)

# Update only when needed
if name != st.session_state.name:
    st.session_state.name = name

st.write("Your name is:", st.session_state.name)
```

### **Avoid Reset Problem**

The key idea:

* **Always read from session_state**
* **Never hardcode default values again after initialization**

---

## **6. Example UI Code – NiceGUI**

### **Using a Simple Class for State**

```python
from nicegui import ui

class AppState:
    name = ""

state = AppState()

def update_name(value):
    state.name = value
    label.set_text(f"Hello, {state.name}")

ui.label("Enter your name:")
ui.input(on_change=lambda e: update_name(e.value))
label = ui.label("Hello, ...")

ui.run()
```

Here `state.name` never resets unless you reset it manually.

---

### **Using `ui.storage` (Persists in Browser)**

```python
from nicegui import ui

# Initialize
if not ui.storage.get('cart'):
    ui.storage['cart'] = []

def add_item():
    cart = ui.storage['cart']
    cart.append('Apple')
    ui.storage['cart'] = cart
    items.set_text(str(cart))

ui.button("Add Apple", on_click=add_item)
items = ui.label(str(ui.storage['cart']))

ui.run()
```

This remembers the cart even if the user refreshes the page.

---

## **7. How Codex Helps You Here**

### **Prompt 1**

“Generate a Streamlit example showing login state saved in st.session_state, with a logout button.”

### **Prompt 2**

“My Streamlit dropdown resets when I click a button. Rewrite the code so the selection is remembered.”

### **Prompt 3**

“Create a NiceGUI example where a global state class remembers selected items in a list.”

### **Prompt 4**

“Use NiceGUI ui.storage to implement a persistent shopping cart with add/remove buttons.”

### **Prompt 5**

“Analyze this code and fix the state reset problems. Suggest better initialization patterns.”

---

## **8. Small Text Diagram**

```
     ┌──────────────┐
     │ Frontend UI  │
     └──────┬───────┘
            │ uses
            ▼
     ┌──────────────┐
     │ Session State│  ← remembers values
     └──────┬───────┘
            │ sends data to
            ▼
     ┌──────────────┐
     │ Backend API  │
     └──────────────┘
```

---

## **9. Mini Exercises for Students**

### **Exercise 1 — Streamlit**

Build a small “Task List” app:

* input box for task
* “Add” button
* store tasks in `st.session_state`
* display list below

Ensure it doesn’t reset when interacting.

---

### **Exercise 2 — NiceGUI**

Create a simple counter:

* “+” and “–” buttons
* counter stored in a class
* label updates on each click

No reset allowed.

---

### **Exercise 3 — NiceGUI Storage**

Save favorite colors using `ui.storage`:

* dropdown of colors
* add to favorites
* display list

Check if list stays after refresh.

---
