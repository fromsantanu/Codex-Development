# **Chapter 2: Understanding API-Based Architecture (Restaurant Example)**

---

## **1. Simple Introduction**

Modern apps talk to each other using **APIs**.
An API is just a **simple message system**:

* The frontend sends a request to the backend
* The backend replies with a response

This is called **request–response architecture**.

In backend-heavy systems (like hospital apps, school ERPs, billing systems), the frontend must stay **light**, and all the heavy business logic should stay inside the backend.

To understand this easily, we will use a simple **restaurant analogy**.

---

## **2. Real-Life Analogy: “Menu + Waiter”**

Imagine a restaurant:

* The **menu** tells you what you can ask for
* The **waiter** collects your order and carries it to the kitchen
* The **kitchen** prepares the food
* The **waiter** brings the food back to you

In software:

* **API documentation = Menu**
* **API endpoint = Waiter**
* **Backend = Kitchen**
* **Frontend = Customer at the table**

You (frontend) **never enter the kitchen**.
You only communicate through the waiter (API).

This is exactly how API-based apps work.

---

## **3. Key Concepts (Explained Gently)**

### **API**

A simple way for one program to ask another program to do something.

### **Endpoint**

The “door” where the request is sent.
Example: `/add-patient`, `/calculate-bill`, `/login`

### **Request**

What the frontend sends.

### **Response**

What the backend returns.

### **JSON**

A simple text format to send data like:

```json
{"name": "Santanu", "age": 22}
```

### **Business Logic**

Rules and calculations that should stay in the backend.

---

## **4. Step-by-Step Explanation of Request–Response**

### **Step 1: Frontend prepares a request**

Example:

```json
{"item": "Paneer Butter Masala", "quantity": 2}
```

### **Step 2: Frontend sends request to API endpoint**

Like giving your order to a waiter.

Example URL:
`POST /order-food`

### **Step 3: Backend processes it**

Checks:

* Is the item available?
* What is the price?
* How long will it take?
* Is quantity allowed?

### **Step 4: Backend sends response**

Example:

```json
{
  "status": "Accepted",
  "total_price": 480,
  "estimated_time": "20 minutes"
}
```

### **Step 5: Frontend shows result to user**

Friendly UI messages:

> “Order accepted! Total price: ₹480. Estimated time: 20 minutes.”

---

## **5. Why the Frontend Should NOT Do Heavy Logic**

The frontend should be:

* simple
* light
* easy to change
* easy to deploy
* only responsible for buttons, forms, layout, display

### **What the frontend must NOT do**

❌ Calculate patient dose
❌ Check business rules
❌ Verify billing rules
❌ Decide treatment plan
❌ Compute taxes
❌ Validate medical conditions

All these belong to the **backend** — the "kitchen".

### **Why?**

Because:

* You want consistent rules everywhere
* Backend can be tested easily
* Backend is more secure
* Backend can scale better
* If rules change, you change only one place

---

## **6. Simple Diagram**

```
Frontend (UI)
     │
     │ request (JSON)
     ▼
Backend API (Business Logic)
     │
     │ response (JSON)
     ▼
Frontend shows result
```

---

## **7. Example: Streamlit Frontend Calling API**

```python
import streamlit as st
import requests

st.title("Food Ordering")

item = st.text_input("Enter item name")
qty = st.number_input("Quantity", min_value=1)

if st.button("Place Order"):
    response = requests.post(
        "http://localhost:8000/order-food",
        json={"item": item, "quantity": qty}
    )
    data = response.json()
    st.success(data["status"])
    st.info(f"Total Price: ₹{data['total_price']}")
```

---

## **8. Simple Backend API (FastAPI)**

```python
from fastapi import FastAPI

app = FastAPI()

@app.post("/order-food")
def order(data: dict):
    price_list = {"Paneer": 200, "Dosa": 80}
    item = data["item"]
    qty = data["quantity"]

    if item not in price_list:
        return {"status": "Item not available"}

    total = price_list[item] * qty

    return {"status": "Accepted", "total_price": total}
```

---

## **9. How Codex Helps You Here**

Codex can:

* generate the entire API function
* write JSON request/response examples
* generate simple frontend form code
* handle error messages
* clean up UI layout
* write backend business logic
* convert rules into Python
* fix bugs if API fails
* rewrite code in Streamlit, Gradio, or NiceGUI

### **Sample Codex Prompts**

#### **Prompt 1**

“Create a Streamlit form that calls `/order-food` API with item and quantity.”

#### **Prompt 2**

“Generate a FastAPI endpoint `/order-food` that uses a price list and returns JSON.”

#### **Prompt 3**

“Improve this API code and add validation for missing fields.”

#### **Prompt 4**

“Add loading spinner in Streamlit when sending API request.”

---

## **10. Mini Exercises for Students**

### **Exercise 1**

Draw a diagram showing:

```
UI → API → Backend Logic → API → UI
```

Write one sentence explaining each arrow.

---

### **Exercise 2**

Create a small API:

`POST /square-number`
Input: number
Output: its square

---

### **Exercise 3**

Build a tiny Gradio app:

* One textbox for a number
* A button
* Shows the square returned from your API

---
