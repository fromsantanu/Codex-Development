### Chapter 36. Basic Performance Ideas

---

## 1. Simple Introduction

When building a frontend, the biggest slowdowns usually come from:

* Calling the backend too many times
* Fetching too much data at once
* Repeating the same API call every few seconds
* Searching with every keystroke
* Loading very large lists without pagination

These things make the app feel **slow**, **heavy**, or **laggy**.

Good performance does NOT require complicated tricks.
Even **three simple ideas** can make your UI feel very fast:

1. Cache API results when they don’t change often
2. Reduce unnecessary API calls (e.g., use debounce for search)
3. Use simple pagination instead of loading huge lists at once

---

## 2. Real-Life Analogy

### Caching

Imagine you ask a shopkeeper:

> “Do you have Parle-G biscuits?”

If you ask again after 10 seconds, he won’t go back to the godown.
He will remember and say instantly:

> “Yes, I told you already.”

This memory is **caching**.

---

### Reducing unnecessary requests (Debounce)

Think of a receptionist writing down your name.
You don’t spell it letter-by-letter like:

“R”
“RA”
“RAJ”

That would waste time.
Instead, you say the full name once:

> “My name is Raj Kumar.”

This is **debounce** — waiting until the person finishes typing before searching.

---

### Pagination

If a restaurant menu had **2,000 items** on one page, you would get tired reading it.
Instead, menus break items into pages:

* Soups
* Starters
* Main Course
* Desserts

This is **pagination** — showing things in small batches.

---

## 3. Key Concepts (Explained Gently)

### 3.1 Caching

Store the results of an API call locally so you don’t call the backend repeatedly.

Useful when:

* List of departments
* List of product categories
* Static country/city list
* Today's dashboard that doesn’t change every second

---

### 3.2 Debounce

Debounce means:

> “Wait until the user finishes typing before sending the request.”

Example:
Search box should wait 300–500ms after the last keystroke.

---

### 3.3 Pagination

Instead of loading **10,000 records**, load:

* page 1 → 20 records
* page 2 → next 20
* page 3 → next 20

This makes the UI feel fast and stable.

---

## 4. Step-by-Step Explanation

### Step 1: Add Caching

When user loads categories for a dropdown, store them in `session_state`.

```python
if "categories_cache" not in st.session_state:
    st.session_state.categories_cache = None
```

When fetching:

```python
def get_categories():
    if st.session_state.categories_cache:
        return st.session_state.categories_cache

    response = requests.get("http://localhost:8000/categories")
    data = response.json()

    st.session_state.categories_cache = data
    return data
```

Now the backend is called **only once**, no matter how many times the user revisits the page.

---

### Step 2: Add Debounce for Search

In Streamlit, use a timer-like method:

```python
import time

if "search_time" not in st.session_state:
    st.session_state.search_time = 0

search = st.text_input("Search items")

current_time = time.time()

if search:
    if current_time - st.session_state.search_time > 0.5:  # 500ms
        st.session_state.search_time = current_time
        st.write("Searching for:", search)
        # Call API here
```

This prevents calling the backend **on every keystroke**.

---

### Step 3: Add Simple Pagination

Keep page number in session state:

```python
if "page" not in st.session_state:
    st.session_state.page = 1
```

Add buttons:

```python
col1, col2 = st.columns(2)
with col1:
    if st.button("◀ Previous") and st.session_state.page > 1:
        st.session_state.page -= 1
with col2:
    if st.button("Next ▶"):
        st.session_state.page += 1
```

Fetch page:

```python
response = requests.get(
    "http://localhost:8000/items",
    params={"page": st.session_state.page, "size": 20}
)
data = response.json()
st.table(data)
```

Now you load **only 20 items per page**, not thousands.

---

## 5. Example UI Code (Combined) – Streamlit

Here is a simple demo that shows all three concepts:

```python
import streamlit as st
import requests
import time

API_BASE = "http://localhost:8000"

# ----------------------
# CACHING
# ----------------------
if "categories" not in st.session_state:
    st.session_state.categories = None

def get_categories():
    if st.session_state.categories:
        return st.session_state.categories

    response = requests.get(f"{API_BASE}/categories")
    data = response.json()
    st.session_state.categories = data
    return data

st.title("Performance Demo")

st.subheader("1. Caching Demo")
categories = get_categories()
st.write("Categories:", categories)

# ----------------------
# DEBOUNCE SEARCH
# ----------------------
st.subheader("2. Debounced Search")

if "last_search" not in st.session_state:
    st.session_state.last_search = 0

query = st.text_input("Search items (debounced)")

now = time.time()
if query and now - st.session_state.last_search > 0.5:  # 500ms debounce
    st.session_state.last_search = now
    try:
        response = requests.get(f"{API_BASE}/search", params={"q": query})
        st.write(response.json())
    except:
        st.error("Search failed")

# ----------------------
# PAGINATION
# ----------------------
st.subheader("3. Pagination")

if "page" not in st.session_state:
    st.session_state.page = 1

col1, col2 = st.columns(2)
with col1:
    if st.button("◀ Previous"):
        if st.session_state.page > 1:
            st.session_state.page -= 1
with col2:
    if st.button("Next ▶"):
        st.session_state.page += 1

st.write(f"Page: {st.session_state.page}")

try:
    response = requests.get(
        f"{API_BASE}/items",
        params={"page": st.session_state.page, "size": 10}
    )
    st.table(response.json())
except:
    st.error("Could not load items")
```

This small example demonstrates all performance tricks clearly.

---

## 6. Simple Backend Example

```python
from fastapi import FastAPI

app = FastAPI()

# Fake data
ITEMS = [{"id": i, "name": f"Item {i}"} for i in range(1, 501)]
CATEGORIES = ["Electronics", "Books", "Fashion"]

@app.get("/categories")
def categories():
    return CATEGORIES

@app.get("/search")
def search(q: str):
    return [item for item in ITEMS if q.lower() in item["name"].lower()]

@app.get("/items")
def items(page: int = 1, size: int = 10):
    start = (page - 1) * size
    end = start + size
    return ITEMS[start:end]
```

---

## 7. How Codex Helps You Here

Codex is great for automating performance improvements without thinking too much.

You can ask:

### ✔ Add caching to API calls

> “Add caching so that categories are fetched only once and stored in session_state.”

### ✔ Add debounce to search

> “Convert this Streamlit search box into a debounced search with a 400ms delay.”

### ✔ Add pagination

> “Add simple pagination using page number and Next/Previous buttons.”

### ✔ Optimize repeated API calls

> “Check this file and tell me which API calls can be cached.”

### ✔ Rewrite large list into paginated list

> “Convert this big table loading into a paginated table loading only 20 records at a time.”

Codex can add these features in a few seconds.

---

## 8. Mini Exercises for Students

### **Exercise 1: Add cache expiry**

Add a 5-minute expiry for cached categories.

---

### **Exercise 2: Improve debounce**

Make debounce faster for small words (300ms) and slower for long words (700ms).

---

### **Exercise 3: Pagination with total pages**

Show:

> “Page X of Y”
> Where Y = total items / page size.

---

### **Exercise 4 (Optional)**

Implement the same in **NiceGUI**, with:

* cached dropdown options
* debounced search box
* paginated table

---

With these three simple performance ideas, students can make their apps feel much smoother—without any complicated tuning.
