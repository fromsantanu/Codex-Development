# **Chapter 17. Fetching Lists and Tables from APIs**

## **1. Simple Introduction**

Many dashboards and apps need to show **lists of items**â€”like patients, orders, products, or tasks.
But this data usually comes from a backend API, not from your frontend directly.

In this chapter, we learn how to:

* call APIs like `/items` or `/patients`
* show the result as a table
* handle pagination (page 1, page 2, etc.)
* do sorting and filtering on the frontend

Once you learn these skills, you can build almost any â€œlist pageâ€ in real apps.

---

## **2. Real-Life Analogy**

Imagine a **library catalogue**.

You ask the librarian:

* â€œShow me books on page 1â€
* â€œShow me books on page 2â€
* â€œSort by authorâ€
* â€œFilter by category: Scienceâ€

The librarian goes to the storehouse and brings only what you asked for, not the whole library at once.

Your backend API is like the librarian.

Your frontend is like a person requesting the right books in the right order.

---

## **3. Key Concepts (Explained Gently)**

### âœ”ï¸ **API Endpoint (List API)**

A simple URL that returns a list.

Examples:

* `/items`
* `/patients`
* `/orders`

The response is usually JSON.

---

### âœ”ï¸ **Pagination**

You donâ€™t fetch all the records at once.
You ask for:

* which **page** you want
* how many records per page (**page_size**)

Example:
`/patients?page=2&page_size=10`

---

### âœ”ï¸ **Sorting**

Choosing the order:

* sort by name
* sort by date
* sort by price

Example:
`/items?sort_by=name&order=asc`

---

### âœ”ï¸ **Filtering**

Find only what you need.

Examples:

```
/patients?status=active
/items?category=electronics
```

---

### âœ”ï¸ **Frontend Processing**

Sometimes the backend does not support sorting or filtering.
Then the frontend sorts/filter the data using Pandas or Python lists.

---

## **4. Step-by-Step Explanation**

### **Step 1: Call the List API**

Use `requests.get(url)` with proper query parameters.

---

### **Step 2: Parse the JSON**

Convert response to Python dict or Pandas DataFrame.

---

### **Step 3: Show as a Table**

Use Streamlit table or data editor.

---

### **Step 4: Add a Filter Widget**

Dropdowns, text input, date pickers.

---

### **Step 5: Add Sorting**

Sort the DataFrame using `df.sort_values()`.

---

### **Step 6: Handle Pagination**

Add â€œPrevious Pageâ€ and â€œNext Pageâ€ buttons.

---

### **Step 7: Show Loading Indication**

Users should know the data is being fetched.

---

## **5. Example UI Code (Using Streamlit)**

Hereâ€™s a simple **patients list** example.

```python
import streamlit as st
import pandas as pd
import requests

st.title("Patient List")

# --- Pagination state ---
if "page" not in st.session_state:
    st.session_state.page = 1

page_size = 5
page = st.session_state.page

# --- Filter ---
status_filter = st.selectbox("Filter by Status:", ["all", "active", "completed"])

params = {"page": page, "page_size": page_size}
if status_filter != "all":
    params["status"] = status_filter

# --- Fetch API ---
st.write("Fetching data...")
response = requests.get("http://localhost:8000/patients", params=params)
data = response.json()

df = pd.DataFrame(data["items"])

# --- Sorting ---
sort_col = st.selectbox("Sort by:", df.columns)
df = df.sort_values(sort_col)

# --- Table ---
st.table(df)

# --- Pagination Buttons ---
col1, col2 = st.columns(2)
if col1.button("Previous") and page > 1:
    st.session_state.page -= 1
if col2.button("Next"):
    st.session_state.page += 1
```

This includes:

* filters
* pagination
* table
* sorting

Very close to real-world usage.

---

## **6. Backend API Example (Simple)**

Typical backend response:

### **Request**

```
GET /patients?page=2&page_size=5&status=active
```

### **Response**

```json
{
  "page": 2,
  "page_size": 5,
  "total": 47,
  "items": [
    {"id": 6, "name": "Rahul", "status": "active"},
    {"id": 7, "name": "Anita", "status": "active"},
    {"id": 8, "name": "John", "status": "active"},
    {"id": 9, "name": "Mira", "status": "active"},
    {"id": 10, "name": "Vikram", "status": "active"}
  ]
}
```

This is the standard â€œpaged listâ€ pattern used everywhere.

---

## **7. How Codex Can Help Here**

Use these ready prompts:

### âœ”ï¸ Prompt 1: Create a list page

**"Codex, generate a Streamlit page that fetches `/patients` and displays a paginated table."**

---

### âœ”ï¸ Prompt 2: Add sorting and filtering

**"Codex, add sorting and filtering options to this Streamlit table using dropdowns."**

---

### âœ”ï¸ Prompt 3: Connect to real backend

**"Codex, connect this table to my FastAPI endpoint `/items` using Python requests."**

---

### âœ”ï¸ Prompt 4: Add pagination logic

**"Codex, add previous/next buttons and maintain pagination state using session_state."**

---

### âœ”ï¸ Prompt 5: Fix errors

**"Codex, debug this API-list code and explain why the table is not updating."**

---

## **8. Mini Exercises for Students**

### ğŸŸ¦ **Exercise 1**

Create a Streamlit page that fetches:

```
GET /items?page=1&page_size=10
```

and shows the table.

---

### ğŸŸ¦ **Exercise 2**

Add a filter:

* Category (electronics, clothes, home)

Use a dropdown.

---

### ğŸŸ¦ **Exercise 3**

Add sorting:

* Sort by â€œpriceâ€
* Sort by â€œnameâ€

Use DataFrame sorting.

---

### ğŸŸ¦ **Exercise 4 (Bonus)**

Add pagination with â€œPreviousâ€ and â€œNextâ€ buttons.

---
