# **Chapter 29 — Implementing Login Forms in Python Frontends**

## 1. Simple Introduction

In many apps, you don’t want everyone to see everything.
You want only **logged-in users** (like staff, doctors, admins, etc.) to access some pages.

To do this, we usually:

1. Show a **login form** (username + password).
2. Send these details to a backend API like `/auth/login`.
3. Backend checks them and returns a **token** (like a digital pass).
4. We **save the token** in the frontend (session).
5. For every future API call, we **attach the token** so the backend knows who we are.

In this chapter, we will build this in a Python frontend (using **Streamlit**).

---

## 2. Real-Life Analogy

Think of a **gym**:

1. You go to the front desk and give your **membership ID**.
2. Staff checks and says “Okay, you are a member”.
3. They give you a **wristband** as a **pass**.
4. Whenever you go to different rooms (weights, swimming pool, etc.), you just show the wristband.

In our app:

* Username + password = membership ID
* `/auth/login` = staff checking your ID
* Token = wristband
* Attaching token in API calls = showing wristband at each room
* Saving token in session state = keeping wristband while you’re inside

---

## 3. Key Concepts (Explained Gently)

### a) Login Form

A simple screen where user types:

* `username`
* `password`

### b) `/auth/login` API

Backend URL that:

* Receives username + password.
* Verifies them.
* Returns either:

  * **Success** → token (e.g., JWT)
  * **Failure** → error message

### c) Token

A string returned on successful login.
We must **store** it and send it with future API calls.

### d) Session State (Frontend)

A place in the frontend to **remember data temporarily** while the user is using the app.

In Streamlit, we use `st.session_state` to store the token.

---

## 4. Step-by-Step Explanation

### Step 1: Build the Login Screen

* Two input fields: username, password.
* One “Login” button.

### Step 2: Call `/auth/login` API

* On button click:

  * Make a POST request to `/auth/login`.
  * Send JSON: `{"username": "...", "password": "..."}`.

### Step 3: Handle Success

* If backend returns token:

  * Save it to `st.session_state["token"]`.
  * Show message: “Login successful”.
  * Optionally move to another part of the app (e.g., dashboard).

### Step 4: Handle Failure

* If backend sends error or status code not 200:

  * Show message: “Invalid username or password” or a generic error.

### Step 5: Use Token in Future API Calls

* When calling other APIs (e.g., `/patients`, `/orders`, `/dashboard`):

  * Read token from `st.session_state["token"]`.
  * Attach it in the headers:

    * `Authorization: Bearer <token>`

### Step 6: Logout

* To logout, simply:

  * Remove the token from `st.session_state`.
  * Optionally send the user back to the login screen.

---

## 5. Example UI Code (Using Streamlit)

Here is a simple example that:

* Shows a login form
* Calls `/auth/login`
* Saves token in `st.session_state`
* Shows how to use the token for another API call

```python
import streamlit as st
import requests

BASE_URL = "http://localhost:8000"

# Initialize session_state token
if "token" not in st.session_state:
    st.session_state.token = None

st.title("Login Demo (Streamlit + /auth/login)")

def call_protected_api():
    """Example: call a protected endpoint using the token."""
    headers = {
        "Authorization": f"Bearer {st.session_state.token}"
    }
    res = requests.get(f"{BASE_URL}/protected/profile", headers=headers)
    if res.status_code == 200:
        st.success("Protected data fetched successfully!")
        st.json(res.json())
    else:
        st.error(f"Failed to fetch protected data: {res.text}")

# If not logged in, show login form
if not st.session_state.token:
    st.subheader("Please log in")

    username = st.text_input("Username")
    password = st.text_input("Password", type="password")

    if st.button("Login"):
        try:
            res = requests.post(f"{BASE_URL}/auth/login", json={
                "username": username,
                "password": password
            })

            if res.status_code == 200:
                data = res.json()
                st.session_state.token = data.get("access_token")
                st.success("Login successful!")
            else:
                st.error("Login failed. Please check your username/password.")
        except Exception as e:
            st.error(f"Error while calling login API: {e}")

else:
    st.success("You are logged in.")

    # Show a button to call a protected API
    if st.button("Call Protected API"):
        call_protected_api()

    # Logout button
    if st.button("Logout"):
        st.session_state.token = None
        st.info("You have been logged out.")
```

Notes:

* We expect `/auth/login` to respond with JSON like:
  `{"access_token": "some-long-token", "token_type": "bearer"}`
* We store `data.get("access_token")` in `session_state`.

---

## 6. Backend API Example (Simple)

Here is a sample FastAPI backend for `/auth/login` and a protected route:

```python
from fastapi import FastAPI, Depends, HTTPException, status
from pydantic import BaseModel
import jwt
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

app = FastAPI()
SECRET_KEY = "mysecret"
ALGORITHM = "HS256"

class LoginRequest(BaseModel):
    username: str
    password: str

security = HTTPBearer()

@app.post("/auth/login")
def login(payload: LoginRequest):
    # In real life, check from database
    if payload.username == "admin" and payload.password == "1234":
        token_data = {"sub": payload.username}
        token = jwt.encode(token_data, SECRET_KEY, algorithm=ALGORITHM)
        return {"access_token": token, "token_type": "bearer"}
    else:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    try:
        decoded = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return decoded["sub"]
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token"
        )

@app.get("/protected/profile")
def read_profile(current_user: str = Depends(get_current_user)):
    return {"message": "Hello!", "user": current_user}
```

Frontend calls:

* `POST /auth/login` to get token.
* `GET /protected/profile` with `Authorization: Bearer <token>`.

---

## 7. How Codex Helps You Here

You can ask Codex to write or improve parts of this flow. For example:

1. **“Generate a Streamlit login page that calls /auth/login and stores the token in session_state.”**
2. **“Add error handling to this Streamlit login form for network failures and invalid credentials.”**
3. **“Create a FastAPI /auth/login endpoint that returns JWT, plus a protected /me endpoint that uses the token.”**
4. **“Refactor this login logic to move API calls into a separate helper function.”**
5. **“Generate test cases for my /auth/login endpoint in FastAPI using pytest.”**

Codex can help you:

* Avoid boilerplate.
* Avoid mistakes in token handling.
* Quickly wire frontend and backend together.

---

## 8. Mini Exercises for Students

1. **Exercise 1:**
   Change the login form so that after successful login, it automatically shows a simple “Welcome, <username>!” message using data from `/protected/profile`.

2. **Exercise 2:**
   Add a small text in your app's header that shows:

   * “Status: Logged in” when token is present
   * “Status: Logged out” when token is missing

3. **Exercise 3:**
   Create another protected API like `/protected/orders` and display the list of orders in Streamlit only when user is logged in.

4. **Exercise 4 (Optional):**
   Store not only the token but also the username in `st.session_state` and show it in the sidebar.

---
