# **Chapter 32 — Using Codex to Add Security-Related Code**

## 1. Simple Introduction

Security code (login, tokens, headers, role checks) is often boring and repetitive.
But it is **very important** and also **easy to break** if we make small mistakes.

Instead of writing all of it by hand, we can **ask Codex** to:

* add JWT login to our **NiceGUI** app
* generate code to **attach tokens** in headers
* **centralize** all API calls in one place, so we don’t repeat logic everywhere

In this chapter, we’ll see **what to ask Codex** and **how to use its output safely**.

---

## 2. Real-Life Analogy

Think of security code like the **locks and keys** in a building:

* Every door needs a lock.
* Every lock must work in the same way (same type of key).
* You don’t want different, weird locks everywhere.

Codex is like a **skilled carpenter** you can call and say:

> “Please install the same kind of lock on all these doors.”

In our app:

* Doors = APIs (like `/patients`, `/orders`, `/dashboard`)
* Lock = JWT check
* Key = token in `Authorization: Bearer <token>` header
* Carpenter (Codex) = tool that writes repeated security code for you

---

## 3. Key Concepts (Explained Gently)

### a) Security-related code

Code that handles:

* Login
* Tokens (JWT)
* Authorization headers
* Role checks (admin vs normal user)

### b) Centralized API call logic

Instead of writing:

```python
requests.get(url, headers={...})
```

everywhere in many files, we create **one helper function** like:

```python
def api_get(path: str): ...
```

All other parts of the app use this function.
So if we change token handling, we change in **one place only**.

### c) Using Codex effectively

We don’t ask Codex:

> “Write security for my app.”

We give **very clear instructions**, like:

* which framework (NiceGUI)
* where login API is (`/auth/login`)
* where token should be stored
* how headers should look

---

## 4. Step-by-Step Explanation

### Step 1: Prepare your existing NiceGUI app

Assume you already have:

* a NiceGUI app
* a simple login page (or plan to add one)
* a backend login API: `/auth/login` → returns `access_token`

### Step 2: Ask Codex to add JWT login

Example prompt:

> “Here is my NiceGUI app code. Add JWT-based login using this backend `/auth/login` API.
> On success, store the access token in a global state or session.
> Show a message when login succeeds or fails.”

Codex will:

* create a login form (username/password)
* call `/auth/login`
* store token

### Step 3: Ask Codex to centralize API logic

Once login works, ask Codex:

> “Create a helper module `api_client.py` with functions `api_get`, `api_post`, etc., that automatically attach the `Authorization: Bearer <token>` header if token is available.”

Codex will:

* create functions wrapping `requests.get/post`
* read token from a shared place (like a global variable or session object)

### Step 4: Replace direct API calls with helper functions

Now you ask Codex:

> “Update all my pages to use `api_get` and `api_post` instead of direct `requests.get/post`, and handle 401/403 errors.”

Codex will adjust your code across files.

### Step 5: Review and test manually

* Check that tokens are **not printed** in logs.
* Test successful login + protected API calls.
* Test expired/invalid token case.

---

## 5. Example UI Code (NiceGUI) – With Centralized API Calls

### `api_client.py` (generated or improved with Codex)

```python
# api_client.py
import requests

BASE_URL = "http://localhost:8000"

# Very simple global token store
token: str | None = None

def set_token(value: str | None):
    global token
    token = value

def _auth_headers():
    if token:
        return {"Authorization": f"Bearer {token}"}
    return {}

def api_post(path: str, json: dict | None = None):
    headers = _auth_headers()
    return requests.post(f"{BASE_URL}{path}", json=json, headers=headers)

def api_get(path: str, params: dict | None = None):
    headers = _auth_headers()
    return requests.get(f"{BASE_URL}{path}", params=params, headers=headers)
```

### `main.py` (NiceGUI app using Codex-style changes)

```python
# main.py
from nicegui import ui
from api_client import api_post, api_get, set_token

def login_page():
    username = ui.input('Username')
    password = ui.input('Password', password=True, password_toggle_button=True)

    def do_login():
        res = api_post('/auth/login', {
            'username': username.value,
            'password': password.value,
        })

        if res.status_code == 200:
            data = res.json()
            set_token(data.get('access_token'))
            ui.notify('Login successful')
            ui.open('/dashboard')
        else:
            ui.notify('Login failed', type='negative')

    ui.button('Login', on_click=do_login)

def dashboard_page():
    async def load_data():
        res = api_get('/protected/data')

        if res.status_code == 200:
            ui.notify('Data loaded')
            ui.label(str(res.json()))
        elif res.status_code == 401:
            ui.notify('Session expired. Please login again.', type='warning')
            set_token(None)
            ui.open('/')
        elif res.status_code == 403:
            ui.notify('Access forbidden', type='negative')
        else:
            ui.notify(f'Error: {res.text}', type='negative')

    ui.label('Dashboard (Protected)')
    ui.button('Load Protected Data', on_click=load_data)
    ui.button('Logout', on_click=lambda: (set_token(None), ui.open('/')))

@ui.page('/')
def index_page():
    login_page()

@ui.page('/dashboard')
def dashboard():
    dashboard_page()

ui.run()
```

**What Codex helped with here:**

* Writing `api_client.py`
* Adding `set_token()` and `_auth_headers()`
* Updating pages to use `api_get`/`api_post`
* Handling 401/403 in one place per page

---

## 6. Backend API Example (Simple)

Your backend (e.g., FastAPI) might look like this:

```python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.security import HTTPBearer
import jwt

app = FastAPI()
SECRET = "mysecret"
ALGO = "HS256"
security = HTTPBearer()

@app.post('/auth/login')
def login(payload: dict):
    if payload.get('username') == 'admin' and payload.get('password') == '1234':
        token = jwt.encode({'sub': 'admin'}, SECRET, algorithm=ALGO)
        return {'access_token': token, 'token_type': 'bearer'}
    raise HTTPException(status_code=401, detail='Invalid credentials')

def get_current_user(credentials=Depends(security)):
    token = credentials.credentials
    try:
        return jwt.decode(token, SECRET, algorithms=[ALGO])['sub']
    except Exception:
        raise HTTPException(status_code=401, detail='Invalid or expired token')

@app.get('/protected/data')
def protected_data(user: str = Depends(get_current_user)):
    return {'user': user, 'data': 'This is protected info'}
```

Codex can also generate and refine this backend code for you.

---

## 7. How Codex Helps You Here (Concrete Prompts)

Here are **ready-to-use prompts** you can give to Codex.

### Prompt 1 – Add JWT login to NiceGUI

> “Here is my NiceGUI app code. Add a login page that calls `/auth/login` (FastAPI) and stores the `access_token` in a shared place. After successful login, redirect to `/dashboard`. Use JWT token as `Authorization: Bearer <token>` for protected requests.”

### Prompt 2 – Centralize API call logic

> “Create a new file `api_client.py` with helper functions `api_get` and `api_post`. They should automatically attach an `Authorization: Bearer <token>` header if a token is stored. Also add `set_token()` to update the token. Use Python requests and a global variable.”

### Prompt 3 – Refactor existing code to use helpers

> “Refactor my NiceGUI pages to stop using `requests.get` and `requests.post` directly. Instead, use `api_get` and `api_post` from `api_client.py`, and handle 401 and 403 responses with user-friendly notifications.”

### Prompt 4 – Strengthen security

> “Review my NiceGUI and FastAPI code for security issues. Remove any logging of tokens or passwords, and ensure that sensitive data is not printed or shown in the UI.”

### Prompt 5 – Add role-based checks

> “Extend the JWT-based login so the token includes a `role` field (e.g., 'admin', 'user'). In the NiceGUI app, hide or disable admin-only buttons when the current role is not 'admin'.”

Codex is best used **iteratively**: show existing code → ask small, clear changes → test → refine.

---

## 8. Mini Exercises for Students

1. **Exercise 1:**
   Ask Codex to create `api_put` and `api_delete` helper functions in `api_client.py` and update one page to use them.

2. **Exercise 2:**
   Ask Codex to add a simple **“current user info”** function that calls `/me` and shows the username and role in the NiceGUI header.

3. **Exercise 3:**
   Modify the `api_client` so that when it gets a 401 response, it automatically clears the token and returns a flag like `{"need_login": True}`. Use this to redirect users to the login page.

4. **Exercise 4 (Optional):**
   Ask Codex to add a simple “Remember Me” checkbox on the login page and store the token in a safer persistent place (e.g., a server-side session), then test how that works.

---
