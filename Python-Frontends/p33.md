### Chapter 33. Error Handling on the Frontend

---

## 1. Simple Introduction

When we build a frontend, we usually imagine that:

* The **internet is always working**
* The **backend is always up**
* The **API always returns perfect data**

In real life, this is **not true**.

Sometimes:

* The **network fails**
* The **backend server is down**
* The **API returns wrong or broken data**

If we don’t handle these nicely, the user sees:

* Red error messages
* Stack traces
* Confusing technical text

Our job on the **frontend** is to:

* Catch these errors
* Show **simple, friendly messages**
* Guide the user on what to do next

---

## 2. Real-Life Analogy

Imagine you go to a **bank counter**:

* You fill a form and give it to the bank staff (frontend → backend).
* The staff goes inside to process it (backend).

Possible problems:

1. The door to the back office is locked → like **network error**.
2. The staff inside is on strike → like **backend down**.
3. They return a paper with half-filled information that doesn’t make sense → like **invalid response**.

A **good bank counter person** will not shout or show you their internal office fight.

Instead they will say things like:

* “Sorry, our internal system is down. Please try again after some time.”
* “Sorry, we could not read your data, can we try again?”

This is exactly what **good frontend error handling** does.

---

## 3. Key Concepts (Explained Gently)

### 3.1 Network Error

When the browser or app **cannot reach** the server.

Examples:

* No internet connection
* Wi-Fi dropped
* DNS issue (website cannot be found)

In code, this often shows as:

* Timeout
* Connection error

---

### 3.2 Backend Down

The server is **reachable**, but it returns errors like:

* HTTP 500 (Internal Server Error)
* HTTP 502 / 503 (Bad gateway / Service unavailable)

For the user, we should not show:

* “Traceback…”
* Internal stack trace

Instead show:

> “The server is currently unavailable. Please try again later.”

---

### 3.3 Invalid Response

The server returns **something**, but it is **not what we expected**.

Examples:

* We expected `{"name": "...", "age": 30}`, but got `{"error": "not found"}`
* We expected a list, but got a single object
* Some fields are missing

Frontend must check:

* “Is this data in the shape I expect?”
* If not, show a friendly message.

---

### 3.4 Friendly Error Message

A **friendly error**:

* Uses simple words
* Says what happened
* Suggests what user can do

Example:

> “We couldn’t load the patient list right now. Please check your internet connection and click ‘Retry’.”

---

### 3.5 Using `try/except` in Python Frontends

In Python-based frontends (Streamlit, Gradio, NiceGUI), we call APIs inside Python code.

We wrap risky code in:

```python
try:
    # risky code
except SomeError:
    # handle nicely in UI
```

This helps us:

* Catch exceptions
* Show clear messages instead of crashing the app

---

## 4. Step-by-Step Explanation

Let’s take a simple case:

> We have a frontend that loads a **patient list** from `/api/patients`.

We want to:

1. Call the backend API
2. Handle network errors
3. Handle backend errors (e.g., 500)
4. Handle invalid responses
5. Show friendly UI messages

---

### Step 1: Basic API Call (Happy Path)

Without error handling, code may look like:

```python
import requests

def fetch_patients():
    response = requests.get("http://localhost:8000/api/patients")
    return response.json()
```

If anything goes wrong, it might:

* Throw an exception
* Show an ugly stack trace in the frontend console

---

### Step 2: Add `try/except` for Network Errors

```python
import requests

def fetch_patients():
    try:
        response = requests.get("http://localhost:8000/api/patients", timeout=5)
        response.raise_for_status()  # raises if status is 4xx/5xx
        return response.json(), None
    except requests.exceptions.ConnectionError:
        return None, "Cannot connect to server. Please check your internet or try again later."
    except requests.exceptions.Timeout:
        return None, "The server is taking too long to respond. Please try again."
    except requests.exceptions.HTTPError as e:
        return None, f"Server returned an error: {e.response.status_code}. Please try again."
    except Exception:
        return None, "Something went wrong. Please try again later."
```

We return **(data, error_message)**:

* If success → `(data, None)`
* If failure → `(None, "Some friendly message")`

---

### Step 3: Validate the Response Shape

Even if `response.json()` works, the data might not be in the right shape.

Example expected:

```json
[
  {"id": 1, "name": "Ram", "age": 45},
  {"id": 2, "name": "Sita", "age": 38}
]
```

We can check:

```python
def validate_patients_data(data):
    if not isinstance(data, list):
        return False
    for item in data:
        if not isinstance(item, dict):
            return False
        if "id" not in item or "name" not in item:
            return False
    return True
```

Then use it:

```python
def fetch_patients():
    try:
        response = requests.get("http://localhost:8000/api/patients", timeout=5)
        response.raise_for_status()
        data = response.json()
        if not validate_patients_data(data):
            return None, "Received data in an unexpected format. Please contact support."
        return data, None
    except requests.exceptions.ConnectionError:
        return None, "Cannot connect to server. Please check your internet or try again later."
    # ... other except blocks as before ...
```

---

### Step 4: Show Friendly Messages in the UI

Now we connect this to a **Python frontend**.

We will use **Streamlit** here (you can do similar in NiceGUI/Gradio).

---

## 5. Example UI Code (Using Streamlit)

### Simple Streamlit UI with Error Handling

```python
import streamlit as st
import requests

API_URL = "http://localhost:8000/api/patients"


def validate_patients_data(data):
    if not isinstance(data, list):
        return False
    for item in data:
        if not isinstance(item, dict):
            return False
        if "id" not in item or "name" not in item:
            return False
    return True


def fetch_patients():
    try:
        response = requests.get(API_URL, timeout=5)
        response.raise_for_status()
        data = response.json()
        if not validate_patients_data(data):
            return None, "Received data in an unexpected format."
        return data, None
    except requests.exceptions.ConnectionError:
        return None, "Cannot connect to server. Please check your internet or try again later."
    except requests.exceptions.Timeout:
        return None, "The server is taking too long to respond. Please try again."
    except requests.exceptions.HTTPError as e:
        return None, f"Server error ({e.response.status_code}). Please try again later."
    except Exception:
        return None, "Unexpected error. Please try again later."


st.title("Patient List")

if st.button("Load Patients"):
    with st.spinner("Loading patients..."):
        data, error = fetch_patients()

    if error:
        st.error(error)
    else:
        st.success("Patients loaded successfully!")
        st.table(data)
```

What this UI does:

1. Shows a **button** “Load Patients”
2. When clicked:

   * Shows a **spinner** (“Loading patients…”)
   * Calls `fetch_patients()`
3. If `error` is not `None`:

   * Show `st.error(error)` → a red friendly box
4. If success:

   * Show a green success message
   * Show the table

No stack traces, no confusing technical text.

---

### Simple Text Diagram

```text
User clicks "Load Patients"
          │
          ▼
   Frontend calls fetch_patients()
          │
          ├─ Success → Show table + "success" message
          │
          └─ Error   → Show friendly error message (st.error)
```

---

## 6. Backend API Example (Simple)

A simple FastAPI backend for `/api/patients`:

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

app = FastAPI()

class Patient(BaseModel):
    id: int
    name: str
    age: int

@app.get("/api/patients", response_model=List[Patient])
def get_patients():
    return [
        Patient(id=1, name="Ram Kumar", age=45),
        Patient(id=2, name="Sita Devi", age=38),
    ]
```

If this server is:

* **Running correctly** → frontend shows the table
* **Stopped** → frontend shows “Cannot connect to server…”
* **Returns wrong data** (if we change the response) → frontend shows “Received data in an unexpected format.”

So the **frontend always stays calm and simple**, even if backend is messy.

---

## 7. How Codex Helps You Here

Codex (or any code assistant) can help a lot with **error handling**.

You can ask it to:

* Wrap your API calls in `try/except`
* Suggest useful error messages
* Add response validation
* Convert ugly tracebacks into friendly UI messages

### Sample Prompts You Can Use

1. **Wrap API call with error handling**

> “Here is my Streamlit code that calls an API. Please wrap the `requests.get` call in proper try/except blocks for network error, timeout, HTTP error, and unknown error. Return `(data, error_message)`.”

2. **Improve error messages for end users**

> “These error messages are too technical. Rewrite them in simple, friendly language for non-technical users: [paste messages].”

3. **Add response validation**

> “I expect the `/api/patients` endpoint to return a list of objects with fields `id`, `name`, and `age`. Please add a simple Python function `validate_patients_data(data)` and update my `fetch_patients()` function to use it and show a friendly error if the shape is wrong.”

4. **Convert print-based errors to UI messages**

> “In this Streamlit app, I am printing errors to console. Please change it so that errors are shown using `st.error()` instead of print, and success messages use `st.success()`.”

5. **Port error handling to different frontend framework**

> “Take this Streamlit code with try/except and error messages, and convert it into a NiceGUI version that shows error messages as dialogs or notifications.”

---

## 8. Mini Exercises for Students

Try these small tasks so the idea becomes real for you.

1. **Network Error Simulation**

   * In your Streamlit app, use the `fetch_patients()` example.
   * Then temporarily change `API_URL` to a wrong URL (`http://localhost:9999/api/patients`).
   * Confirm that you see a **friendly error message**, not a crash.

2. **Invalid Data Handling**

   * Change your backend to return: `{"message": "error"}` instead of a list.
   * Update your `validate_patients_data()` function so it shows:

     > “The server responded, but the data format is wrong. Please contact support.”
   * Observe the behavior on the frontend.

3. **Add a Retry Button**

   * After showing an error, add a **“Retry”** button in Streamlit.
   * When clicked, it should call `fetch_patients()` again.
   * This makes the UI more helpful and user-friendly.

4. **NiceGUI Version (Optional)**

   * Recreate the same “Load Patients with error handling” using **NiceGUI**.
   * Use `ui.notification()` for error/success messages.

Don’t worry if this feels a bit new.
You are learning to make your frontends **polite and robust**, just like a good bank clerk who handles problems calmly and explains them clearly to customers.
