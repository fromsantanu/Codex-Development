# Chapter 22. Custom Hooks – Reusable Logic

## Introduction
- The Reusable Logic page helps the Sunrise Clinic Scheduling Desk team handle the clinic flow without confusion.
- The React front end calls /api/appointments so this screen stays in sync with the backend API.

## Key Concepts
- Hooks are like sticky notes that remind the receptionist what to do when a timer or API update happens.
- Reusable Logic uses hooks just like a nurse relies on a clipboard—simple tools to keep status current at Sunrise Clinic Scheduling Desk.

## Step-by-step Implementation
1. Lay out the Reusable Logic intro card
   - Explanation Start with a friendly section so the Sunrise Clinic desk knows what Reusable Logic is about.
   ```jsx
   function ReusableLogicIntro() {
     return (
       <section className='intro-card'>
         <h2>Reusable Logic at Sunrise Clinic Scheduling Desk</h2>
         <p>Welcome back, front desk! This section explains why Reusable Logic matters today.</p>
       </section>
     );
   }
   ```
   - Codex help: Ask Codex to build the ReusableLogicIntro section with a warm heading and short explanation for Reusable Logic.

2. Bundle logic into a Reusable Logic hook
   - Explanation Custom hooks wrap repeating steps so the clinic team can reuse the same checklist everywhere.
   ```jsx
   function useClinicChecklist() {
     const [checklist] = useState(['Confirm patient', 'Reserve room', 'Notify doctor']);
     return checklist;
   }

   function ReusableLogicChecklist() {
     const checklist = useClinicChecklist();
     return (
       <ul>
         {checklist.map(item => <li key={item}>{item}</li>)}
       </ul>
     );
   }
   ```
   - Codex help: Request Codex to extract the Reusable Logic logic into a custom hook plus the small list component.

3. Call the API for Reusable Logic
   - Explanation Connect to /api/appointments with GET so the sunrise clinic frontend keeps Reusable Logic mirrored with the backend.
   ```jsx
   const [records, setRecords] = useState([]);
   useEffect(() => {
     async function syncData() {
       const response = await fetch('/api/appointments', {
         method: 'GET',
       });
       if (!response.ok) throw new Error('Failed to load Reusable Logic');
       const data = await response.json();
       setRecords(data);
     }
     syncData();
   }, []);
   return <p>Reusable Logic records: {records.length}</p>;
   ```
   - Codex help: Ask Codex to craft the fetch block that calls /api/appointments for Reusable Logic and stores the result.

## How to Use Codex Here
- Generate a React component that fetches Reusable Logic from /api/appointments and lists it in friendly cards.
- Refactor the Reusable Logic component so it splits the header and list parts into child components.
- Add loading and error messages for the Reusable Logic fetch that talks to /api/appointments.

## Mini-Exercise (Optional)
- Add one more hook (like useMemo or another useState) to keep Reusable Logic logic tidy.
