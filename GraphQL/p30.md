# Chapter 30. Choosing Good Field Names (Consistency & Clarity)

---

### 1. Introduction ‚Äì Why names matter

In GraphQL, names are **everywhere**:

* Type names
* Field names
* Argument names

If the names are confusing, the whole API feels confusing.

Good names are like **clear labels on jars in your kitchen**.
If the label is ‚Äúsalt‚Äù, everyone understands.
If the label is ‚Äúwhite powder A‚Äù, people get scared. üòÑ

Our goal:

* Simple
* Consistent
* Easy to guess

---

### 2. Why this matters for developers

If field names are clear:

* Frontend developers can **guess** the API without reading a big document.
* New team members can **read code quickly**.
* You avoid **bugs** from misunderstanding fields.
* Renaming later is **painful** (many files to change), so better to decide well now.

Good field names make your GraphQL API feel like a **well-organized shop**, not a messy storeroom.

---

### 3. Real-life example ‚Äì Customer and orders

Imagine an online shop.

We have **Customer** and **Order**.

Bad naming example:

* `cust_name`
* `ordAmt`
* `dtCreated`
* `isActv`

These are like shop shelves labeled:
‚ÄúC_N‚Äù, ‚ÄúOA‚Äù, ‚ÄúDTC‚Äù, ‚ÄúIA‚Äù ‚Äî nobody knows what they are.

Good naming example:

* `fullName`
* `totalAmount`
* `createdAt`
* `isActive`

Now it feels like labels:
‚ÄúFull Name‚Äù, ‚ÄúTotal Amount‚Äù, ‚ÄúCreated At‚Äù, ‚ÄúIs Active‚Äù ‚Äî very clear.

---

### 4. Code Examples

#### 4.1 Bad vs good schema naming

**Bad GraphQL schema:**

```graphql
type Cust {
  id: ID!
  cust_name: String!
  ph: String
  ords: [Ord!]!
}

type Ord {
  id: ID!
  dtCreated: String!
  ordAmt: Float!
}
```

Problems:

* `Cust` / `Ord` are short and unclear.
* `cust_name` mixes style (snake_case) with others (camelCase?).
* `ph` is too short (phone? photo?).
* `ords` is a weird plural.
* `dtCreated` and `ordAmt` are hard to read.

**Improved GraphQL schema:**

```graphql
type Customer {
  id: ID!
  fullName: String!
  phoneNumber: String
  orders: [Order!]!
}

type Order {
  id: ID!
  createdAt: String!
  totalAmount: Float!
}
```

Why better?

* Type names are **full words**: `Customer`, `Order`.
* Field names use **camelCase**: `fullName`, `phoneNumber`, `createdAt`.
* Names are **self-explanatory**: you know what they mean without comments.
* Plural for lists: `orders` is clear.

---

#### 4.2 REST vs GraphQL ‚Äì naming consistency

**REST example (bad):**

```http
GET /custs/123
GET /cust_orders/123
```

JSON response:

```json
{
  "cust_name": "Anita Sharma",
  "ph": "9876543210",
  "is_actv": true
}
```

**GraphQL example (good):**

```graphql
query {
  customer(id: 123) {
    fullName
    phoneNumber
    isActive
    orders {
      id
      totalAmount
    }
  }
}
```

Here you can see:

* Names are **clean and readable**.
* Same idea can be made much easier to work with just by naming.

---

#### 4.3 Consistent patterns

Some common, **simple patterns** you can follow:

* **Booleans**: start with `is`, `has`, `can`

  * `isActive`, `hasPaid`, `canCancel`
* **Timestamps**: end with `At`

  * `createdAt`, `updatedAt`, `deletedAt`
* **Amounts**: include the unit or meaning

  * `totalAmount`, `discountAmount`, `taxAmount`
* **IDs**: end with `Id` when it‚Äôs a foreign key

  * `customerId`, `doctorId`, `courseId`

Example in schema:

```graphql
type Invoice {
  id: ID!
  customerId: ID!
  totalAmount: Float!
  createdAt: String!
  isPaid: Boolean!
}
```

This feels like a **well-labeled invoice** in a clinic or shop.

---

### 5. Simple Text Diagram ‚Äì Where naming shows up

```text
Frontend component
   |
   |  (uses field names in query)
   v
GraphQL Query
   |
   |  (must match schema field names)
   v
GraphQL Schema
   |
   |  (resolvers map to DB fields)
   v
Database / Microservices
```

If names are bad in the **schema**,
every layer above (queries, frontend code) also becomes harder.

---

### 6. How to Instruct Codex to Help

You can use Codex as a ‚Äú**naming assistant**‚Äù.

Here are some ready-to-use prompts:

1. **Review and improve field names (given in question):**

> ‚ÄúReview this GraphQL schema and suggest clearer, more consistent field names. Explain why each rename is better.‚Äù

2. **Enforce a naming style (camelCase, clear booleans):**

> ‚ÄúCheck this GraphQL schema and make all field names consistent: camelCase for fields, PascalCase for types, and boolean fields starting with is/has/can. Show old vs new names in a table.‚Äù

3. **Align GraphQL names with REST JSON names:**

> ‚ÄúI have this REST JSON response and this GraphQL schema. Suggest GraphQL field names that are clear and close to the JSON names, but more readable. Explain your choices.‚Äù

4. **Fix a messy real project schema:**

> ‚ÄúHere is a part of our real GraphQL schema. Propose better type and field names to make it easier for frontend developers to understand. Keep changes minimal but meaningful. Explain each change in one sentence.‚Äù

You can copy‚Äìpaste these into Codex along with your schema.

---

### 7. Summary

* **Good names = clear labels.** They make your GraphQL API easy to understand and use.
* **Be consistent.** Use simple patterns: camelCase for fields, full words, and clear prefixes like `is` for booleans.
* **Decide early.** Renaming later is costly, so spend a little time now to get field names clean and consistent.

