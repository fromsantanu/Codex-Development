
# Chapter 57. Simple CRUD Apps → Why REST Is Appropriate

## 1. Introduction

In many small projects, you only need to **Create**, **Read**, **Update**, and **Delete** simple data.  
This is called **CRUD**.  
For these kinds of apps, you often do not need the flexibility of GraphQL.  
REST works very well because the tasks are straightforward, like running a small shop with clear counters for each service.  
In this chapter, we will see why REST is usually the easier choice for simple CRUD apps.

---

## 2. Why REST Fits Simple CRUD Work

REST works like a **set of fixed counters** in a small office:

- “Add a new item” → go to the “Add” counter  
- “Update an item” → go to the “Update” counter  
- “Delete something” → go to the “Delete” counter  
- “View list” → go to the “List” counter  

You know exactly which endpoint to call, and the backend logic is simple.

GraphQL is great when you want to take **only specific pieces of data** from many places, like a buffet.  
But for simple CRUD, you don’t need a buffet — a simple menu is enough.

---

## 3. Real-life Example (Shop Inventory App)

Imagine a small shop owner tracking items:

- Add a product  
- List all products  
- Edit product price  
- Delete a product  

This is like maintaining a small notebook.  
Every task is direct.  
REST is perfect because each task maps to one clear API.

### REST Endpoints (very natural mapping)

- `GET /products` → list all  
- `POST /products` → add new  
- `PUT /products/7` → update product 7  
- `DELETE /products/7` → delete product 7  

Easy to understand. Easy to teach. Easy to test.

---

## 4. Code Examples

### A. REST API Example (FastAPI)

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

products = []

class Product(BaseModel):
    id: int
    name: str
    price: float

@app.get("/products")
def list_products():
    return products

@app.post("/products")
def add_product(p: Product):
    products.append(p)
    return {"message": "Product added"}

@app.put("/products/{pid}")
def update_product(pid: int, p: Product):
    for i, item in enumerate(products):
        if item.id == pid:
            products[i] = p
            return {"message": "Product updated"}
    return {"error": "Not found"}

@app.delete("/products/{pid}")
def delete_product(pid: int):
    global products
    products = [p for p in products if p.id != pid]
    return {"message": "Product deleted"}
````

### B. Equivalent GraphQL

It would need:

* Schema
* Types
* Queries
* Mutations
* Resolvers
  Even though the work is simple.

So REST wins on simplicity.

---

## 5. Diagram

```
Frontend
   |
   v
REST Endpoints (Simple CRUD)
   |
   v
Database
```

REST → straight line. Very easy.

GraphQL → powerful but adds extra steps (schema, resolvers, query structure).

---

## 6. How to Instruct Codex

Here are simple prompts you can give Codex:

1. **“Generate a FastAPI REST backend with CRUD APIs for a product list. Keep the code simple.”**

2. **“Write a React or NiceGUI frontend that calls GET/POST/PUT/DELETE endpoints from a small inventory REST API.”**

3. **“Convert this CRUD specification into REST endpoints and generate sample request/response JSON.”**

4. **“Explain how to test each REST endpoint using curl or Python scripts.”**

---

## 7. Summary

1. Simple CRUD apps match REST naturally because each action has one clean endpoint.
2. GraphQL is powerful but unnecessary overhead for very small apps.
3. REST is easier to build, easier to debug, and easier to teach for CRUD-style projects.

---


