# Chapter 36. Role-Based Access

### 1. Simple heading

**Role-Based Access in GraphQL – Doctor, Receptionist, Patient**

---

### 2. Short introduction

Not every user should see the same data.
A **doctor** can see more than a **patient**.
A **receptionist** can manage appointments but maybe not see medical notes.

With GraphQL + JWT, we can store the **user’s role** inside the token.
Then, in each resolver, we check the role and allow or block access.

This is called **role-based access control (RBAC)**.

---

### 3. Use-case story

Think of a **clinic system**:

* **Doctor**

  * Can view full patient record.
  * Can write diagnosis and prescriptions.
* **Receptionist**

  * Can view basic patient profile.
  * Can create appointments.
  * Cannot see doctor’s detailed notes.
* **Patient**

  * Can view their own profile.
  * Can view their own prescriptions.
  * Cannot see other patients’ data.

In real life:

* At a hospital, the **doctor** can open your full file.
* The **reception desk** can see your name, phone number, and appointment time.
* You, as a **patient**, can see your reports via your login.

GraphQL has to behave in the same way:

* Check **who** is calling (from JWT).
* Check **what** they are asking for.
* Decide **allow** or **deny**.

---

### 4. Code examples (small & clear)

We’ll continue the Node + Apollo + JWT style from the login chapter.
Idea is the same in any stack: **token → context → role checks in resolvers**.

#### 4.1 JWT payload with role

When we created the token earlier, we included the role:

```js
// During login (from previous chapter)
const token = jwt.sign(
  { userId: user.id, role: user.role },
  JWT_SECRET,
  { expiresIn: '1h' }
);
```

Example payload inside token:

```json
{
  "userId": 5,
  "role": "DOCTOR",
  "iat": 1710000000,
  "exp": 1710003600
}
```

---

#### 4.2 Adding role to context

A simple middleware to read JWT and set `currentUser` in context:

```js
// context.js
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'supersecret';

export async function createContext({ req }) {
  const authHeader = req.headers.authorization || '';
  const token = authHeader.replace('Bearer ', '');

  if (!token) {
    return { currentUser: null };
  }

  try {
    const payload = jwt.verify(token, JWT_SECRET);
    // payload has: userId, role
    return {
      currentUser: {
        id: payload.userId,
        role: payload.role,
      },
    };
  } catch (err) {
    return { currentUser: null };
  }
}
```

Now in resolvers, we can check `context.currentUser.role`.

---

#### 4.3 Example schema – doctor-only query

```graphql
type Patient {
  id: ID!
  name: String!
  age: Int!
  diagnosis: String
}

type Query {
  # Doctor-only: see all patients
  allPatients: [Patient!]!

  # Patient only: see own profile
  myProfile: Patient
}
```

We will enforce rules in the resolvers:

* `allPatients` → only role `DOCTOR` or maybe `RECEPTIONIST`.
* `myProfile` → only role `PATIENT`, and only their own record.

---

#### 4.4 Helper function for role check

Create a small helper to avoid repeating code:

```js
// authHelpers.js
export function requireRole(currentUser, allowedRoles) {
  if (!currentUser) {
    throw new Error('Not authenticated');
  }

  if (!allowedRoles.includes(currentUser.role)) {
    throw new Error('Not authorized');
  }
}
```

---

#### 4.5 Resolvers with role-based access

```js
// patientResolvers.js
import { requireRole } from './authHelpers.js';

export const resolvers = {
  Query: {
    async allPatients(_, __, { db, currentUser }) {
      // Only DOCTOR or RECEPTIONIST can see all patients
      requireRole(currentUser, ['DOCTOR', 'RECEPTIONIST']);

      return db.patient.findMany();
    },

    async myProfile(_, __, { db, currentUser }) {
      // Only PATIENT role can call this
      requireRole(currentUser, ['PATIENT']);

      // Assuming currentUser.id == patient.id for PATIENT role
      const patient = await db.patient.findUnique({
        where: { id: currentUser.id },
      });

      if (!patient) {
        throw new Error('Patient not found');
      }

      return patient;
    },
  },
};
```

What happens if:

* No token → `currentUser` is `null` → `requireRole` throws “Not authenticated”.
* Wrong role → throws “Not authorized”.
* Correct role → resolver runs normally.

---

#### 4.6 REST vs GraphQL comparison (small)

**REST example**

* Doctor list patients:
  `GET /patients` with header `Authorization: Bearer <token>`
  Backend checks role and either returns data or 403.

**GraphQL example**

```graphql
query {
  allPatients {
    id
    name
    diagnosis
  }
}
```

* Same token in header.
* GraphQL resolver checks role and throws error if not allowed.

The idea is the same. Only the shape of the request is different.

---

### 5. Diagram

```text
[Frontend] -- Authorization: Bearer <JWT> --> [GraphQL Server]
                 |
                 v
           [JWT decoded]
           userId, role
                 |
                 v
         [Resolver called]
                 |
         Check role in context
       /                        \
allowed                       not allowed
  |                              |
  v                              v
run resolver                throw error
(return data)         ("Not authenticated / Not authorized")
```

---

### 6. “How to instruct Codex” prompts

You can use Codex to add role-based access to your own project.

1. **Modify resolvers to check role (the one you gave):**

> “Modify these resolvers to check user role from JWT and block access to admin-only queries.”

2. **Generate helper functions for authorization**

> “Create helper functions for role-based access in my GraphQL server: one function requireAuth to ensure user is logged in, and one function requireRole to ensure the user has one of the allowed roles. Use my existing context.currentUser structure.”

3. **Protect specific fields (e.g., diagnosis)**

> “Update my Patient resolvers so that only DOCTOR role can see the diagnosis field, but other roles can still see name and age. If role is not doctor, return null for diagnosis.”

4. **Clinic roles: doctor vs receptionist vs patient**

> “Given roles DOCTOR, RECEPTIONIST, and PATIENT, suggest role-based access rules for these queries and mutations in my schema, and update the resolver code to enforce them.”

---

### 7. Summary

1. Role-based access means **different roles see different data** (doctor, receptionist, patient).
2. We store the **role in the JWT**, read it into `context.currentUser`, and **check it in resolvers**.
3. Codex can help you **add role checks, create helper functions, and refactor resolvers** to make access control clean and safe in your GraphQL app.

