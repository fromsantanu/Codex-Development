# Chapter 32. Versioning Mindset

*Evolving schema safely*

---

### 1. Introduction – Change without breaking things

In real life, your API **will change**:

* New fields
* New types
* New features

But users (frontend apps, mobile apps) are already using the old version.

So we need a **versioning mindset**:
“How can I **add new things** without **breaking old clients**?”

GraphQL is nice here because, if we are careful,
we can make many changes that are **backward-compatible**
(older clients keep working).

---

### 2. Why this matters

If you break your schema:

* Old mobile apps crash or show errors
* Old frontend builds stop working
* You get urgent calls: “The app stopped working after your deployment!”

If you evolve your schema **safely**:

* Old queries still work as before
* New queries can use new fields
* You can deprecate old fields slowly, with time for migration

Think of it like **renovating a hospital while it is running**.
You cannot close the whole building.
You add new rooms, new equipment, step by step.

---

### 3. Real-life example – Clinic adds new features

You have a clinic app with this type:

```graphql
type Patient {
  id: ID!
  fullName: String!
  phoneNumber: String
}
```

Later, the clinic wants:

1. To store patient’s **email**
2. To record **insurance information** as a new type

You want to add these without breaking existing apps.

Good approach:

* **Add** a new optional field `email` to `Patient`.
* **Add** a new type `Insurance` and an optional field `insurance` on `Patient`.

Existing apps that only ask for `id` and `fullName` will still work.
They don’t even know about `email` and `insurance`.

---

### 4. Code Examples

#### 4.1 Non-breaking changes – adding fields

**Original schema:**

```graphql
type Patient {
  id: ID!
  fullName: String!
  phoneNumber: String
}
```

**New schema (non-breaking):**

```graphql
type Patient {
  id: ID!
  fullName: String!
  phoneNumber: String
  email: String           # new optional field
}
```

Why is this safe?

* Existing queries **do not request `email`** → they still work.
* New clients can start asking for `email`.
* Old clients are not forced to change.

> Rule of thumb:
> **Adding optional fields is safe**.
> **Changing or removing existing fields is risky.**

---

#### 4.2 Non-breaking changes – adding a new type and linking it

We add an `Insurance` type.

**New types:**

```graphql
type Insurance {
  id: ID!
  providerName: String!
  policyNumber: String!
  validTill: String
}
```

And we extend `Patient`:

```graphql
type Patient {
  id: ID!
  fullName: String!
  phoneNumber: String
  email: String
  insurance: Insurance    # new optional relation
}
```

Why is this safe?

* Old queries still work because `insurance` is optional.
* Only clients that ask for `insurance` will get extra data.
* You did not change or remove any existing field.

---

#### 4.3 REST vs GraphQL – versioning mindset

**REST example** – adding a field:

Before:

```http
GET /patients/123

{
  "id": 123,
  "fullName": "Anita Sharma",
  "phoneNumber": "9876543210"
}
```

After:

```http
GET /patients/123

{
  "id": 123,
  "fullName": "Anita Sharma",
  "phoneNumber": "9876543210",
  "email": "anita@example.com"
}
```

If old clients ignore unknown fields, this is **usually fine**.

**GraphQL example** – even safer:

Clients **choose** which fields they want:

```graphql
# Old client
query {
  patient(id: 123) {
    id
    fullName
  }
}
```

Server adds `email` but old clients **do not request it**,
so their response shape **does not change**.

That’s why GraphQL is friendly to **evolution**
if we follow some simple rules.

---

#### 4.4 Deprecating a field (soft removal)

Sometimes you want to **replace** a field,
for example `phone` → `phoneNumber`.

You can:

1. Add `phoneNumber`.
2. Keep `phone` but mark it as **deprecated**.
3. Later remove `phone` after clients migrate.

Example:

```graphql
type Patient {
  id: ID!
  fullName: String!
  phone: String @deprecated(reason: "Use phoneNumber instead")
  phoneNumber: String
}
```

Frontend tools (like GraphQL IDEs) will show a warning.
Developers get time to move to the new field.

---

### 5. Simple Diagram – Safe schema evolution

```text
Time 1 (old)
---------
type Patient {
  id
  fullName
}

Client A: query { patient { id fullName } }

--------- deploy new version ---------

Time 2 (new)
---------
type Patient {
  id
  fullName
  email      # new (optional)
}

Client A: still asks { id fullName } → works
Client B: can ask { id fullName email } → uses new field
```

We **extend** the schema,
we don’t **break** existing queries.

---

### 6. How to Instruct Codex to Help

You can use Codex as a **safety checker** for schema changes.

1. **Main prompt (from your question):**

> “Suggest non-breaking changes to this existing schema to add a new field and a new type, and explain why they are safe.”

You would paste your schema, and maybe say:

> “I want to add email to Patient and add Insurance type.”

Codex can:

* Propose the new type
* Add the field as optional
* Explain why old queries keep working

2. **Ask Codex to review for breaking changes**

> “Here is my current schema and here is my proposed updated schema. Tell me which changes are breaking and suggest how to make them backward-compatible if possible.”

3. **Ask Codex to add deprecation annotations**

> “In this schema, I want to replace ‘phone’ with ‘phoneNumber’. Add the new field and mark the old one as deprecated with a clear reason. Then show example queries using the new field.”

4. **Ask Codex to design a migration plan**

> “For this GraphQL schema, I want to slowly remove the old field ‘age’ and use ‘dateOfBirth’ instead. Suggest a step-by-step plan with schema changes, client changes, and final cleanup. Keep language very simple.”

These prompts help you practice a **versioning mindset**:
add, extend, deprecate, then remove (later).

---

### 7. Summary

* Think of schema changes like **renovating a running hospital**: you must not break daily work.
* Safe moves: **adding optional fields**, **adding new types**, and **deprecating old fields** instead of removing them immediately.
* Use Codex to **review changes, mark deprecations, and suggest non-breaking updates**, so your GraphQL API can grow safely over time.

