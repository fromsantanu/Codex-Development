# 52. Customer Dashboard App (Web + Mobile)

### 1. Introduction

In this chapter, we build a **Customer Dashboard** using GraphQL.
This dashboard will show:

* Customer profile
* Customer orders
* Customer support tickets

We will see:

* How to **design the GraphQL schema**
* How to write **backend resolvers**
* How to build **React frontend pages** for web (and reuse for mobile)

Think of this as a “**one-stop window**” where the customer can see everything about their relationship with the company.

---

### 2. Why this matters

As apps grow, customers want to see many things in **one place**:

* Profile details
* Past and current orders
* Open/closed support tickets

With **REST**, you might need several calls:

* `/api/profile`
* `/api/orders?customerId=123`
* `/api/tickets?customerId=123`

With **GraphQL**, you can often:

```graphql
query {
  customer(id: "123") {
    name
    email
    orders { id total status }
    tickets { id subject status }
  }
}
```

One request → full dashboard data.
This is very useful for **web dashboards** and **mobile apps** where network calls should be fewer and efficient.

---

### 3. Use-case story (real-life example)

Imagine a **shopping app** like a simple Amazon-style store.

* Alice logs into the **web dashboard** on her laptop.
* She wants to see:

  * Her profile: name, email, phone
  * Her last few **orders**
  * Any **open support tickets** she has raised

Later she opens the **mobile app** on her phone.

* The mobile app shows the **same dashboard**, but in a small screen layout.
* Both the web app and mobile app call **the same GraphQL API**.

So we will design:

* A **GraphQL API** that gives all the customer data.
* A **React web page**.
* A **React Native / mobile-friendly idea** (same query, different UI).

---

### 4. Code Examples

We’ll use **Node.js + Apollo Server** in examples, but the idea is the same in any stack.

#### 4.1 GraphQL Schema (SDL)

```graphql
# customer-dashboard.graphql

type Customer {
  id: ID!
  name: String!
  email: String!
  phone: String
  createdAt: String
  orders(limit: Int = 5): [Order!]!
  tickets(limit: Int = 5): [SupportTicket!]!
}

type Order {
  id: ID!
  orderNumber: String!
  totalAmount: Float!
  status: String!
  createdAt: String!
}

type SupportTicket {
  id: ID!
  subject: String!
  status: String!
  createdAt: String!
  lastUpdatedAt: String!
}

type Query {
  # Main “dashboard” query
  customerDashboard(customerId: ID!): Customer
}
```

**Idea in simple words:**

* `Customer` is the **main person**.
* `orders` and `tickets` are **children lists**.
* `customerDashboard(customerId)` is like:
  “Give me everything needed for this customer’s dashboard.”

For reference, **similar REST** might be:

```text
GET /api/customers/123
GET /api/customers/123/orders?limit=5
GET /api/customers/123/tickets?limit=5
```

GraphQL puts this into **one API call**.

#### 4.2 Simple Resolver Structure (Node + Apollo)

Assume you have 3 services or DB access layers:

* `customerService`
* `orderService`
* `ticketService`

```js
// resolvers.js

const resolvers = {
  Query: {
    async customerDashboard(_, { customerId }, { dataSources }) {
      // Fetch basic profile
      const customer = await dataSources.customerService.getCustomerById(customerId);
      return customer;
    },
  },

  Customer: {
    async orders(parent, { limit }, { dataSources }) {
      // parent is the Customer object
      return dataSources.orderService.getOrdersByCustomerId(parent.id, { limit });
    },
    async tickets(parent, { limit }, { dataSources }) {
      return dataSources.ticketService.getTicketsByCustomerId(parent.id, { limit });
    },
  },
};

module.exports = resolvers;
```

**In simple words:**

* `customerDashboard` gets the **main customer**.
* The `Customer` resolvers then fetch `orders` and `tickets` when requested.
* This keeps the design **clean and modular**.

#### 4.3 Example Data Source Stubs

```js
// dataSources/customerService.js
class CustomerService {
  constructor(db) {
    this.db = db;
  }

  async getCustomerById(id) {
    // Very simple example
    return this.db.customers.find((c) => c.id === id);
  }
}

module.exports = CustomerService;
```

Same idea for `OrderService` and `TicketService`.

In a real app, these might call:

* a **SQL database**
* or **REST microservices**, like:

  * `GET /customers/{id}`
  * `GET /orders?customerId=...`
  * `GET /tickets?customerId=...`

#### 4.4 React Web Frontend – Dashboard Page

We’ll make a simple dashboard using React and `fetch` (you can later switch to Apollo Client).

```jsx
// CustomerDashboardPage.jsx
import React, { useEffect, useState } from "react";

const CUSTOMER_DASHBOARD_QUERY = `
  query CustomerDashboard($customerId: ID!) {
    customerDashboard(customerId: $customerId) {
      id
      name
      email
      phone
      orders(limit: 5) {
        id
        orderNumber
        totalAmount
        status
        createdAt
      }
      tickets(limit: 5) {
        id
        subject
        status
        createdAt
      }
    }
  }
`;

export function CustomerDashboardPage({ customerId }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  useEffect(() => {
    async function load() {
      try {
        const res = await fetch("http://localhost:4000/graphql", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: CUSTOMER_DASHBOARD_QUERY,
            variables: { customerId },
          }),
        });

        const json = await res.json();

        if (json.errors) {
          setError(json.errors[0].message);
        } else {
          setData(json.data.customerDashboard);
        }
      } catch (err) {
        setError("Could not load dashboard");
      } finally {
        setLoading(false);
      }
    }

    load();
  }, [customerId]);

  if (loading) return <div>Loading dashboard…</div>;
  if (error) return <div>Error: {error}</div>;
  if (!data) return <div>No data found for this customer.</div>;

  return (
    <div style={{ padding: "1rem" }}>
      <h1>Customer Dashboard</h1>

      <section>
        <h2>Profile</h2>
        <p><strong>Name:</strong> {data.name}</p>
        <p><strong>Email:</strong> {data.email}</p>
        {data.phone && <p><strong>Phone:</strong> {data.phone}</p>}
      </section>

      <section>
        <h2>Recent Orders</h2>
        {data.orders.length === 0 ? (
          <p>No orders found.</p>
        ) : (
          <table>
            <thead>
              <tr>
                <th>Order #</th>
                <th>Total</th>
                <th>Status</th>
                <th>Placed</th>
              </tr>
            </thead>
            <tbody>
              {data.orders.map((o) => (
                <tr key={o.id}>
                  <td>{o.orderNumber}</td>
                  <td>{o.totalAmount}</td>
                  <td>{o.status}</td>
                  <td>{o.createdAt}</td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
      </section>

      <section>
        <h2>Support Tickets</h2>
        {data.tickets.length === 0 ? (
          <p>No support tickets.</p>
        ) : (
          <ul>
            {data.tickets.map((t) => (
              <li key={t.id}>
                <strong>{t.subject}</strong> – {t.status} (since {t.createdAt})
              </li>
            ))}
          </ul>
        )}
      </section>
    </div>
  );
}
```

**Key ideas in simple words:**

* We send a **POST** request with `query` + `variables`.
* We show **loading**, **error**, or **data**.
* We display profile, orders, and tickets in one page.

#### 4.5 Mobile App (React Native) – Same Query, Different UI

In a **React Native** app, you can reuse the **same GraphQL query**, but the UI will be in mobile components:

```jsx
// CustomerDashboardScreen.js (React Native)
import React, { useEffect, useState } from "react";
import { View, Text, ScrollView, ActivityIndicator } from "react-native";

const CUSTOMER_DASHBOARD_QUERY = `
  query CustomerDashboard($customerId: ID!) {
    customerDashboard(customerId: $customerId) {
      name
      email
      orders(limit: 3) { orderNumber status }
      tickets(limit: 3) { subject status }
    }
  }
`;

export function CustomerDashboardScreen({ route }) {
  const { customerId } = route.params;
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function load() {
      const res = await fetch("http://your-api-url/graphql", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: CUSTOMER_DASHBOARD_QUERY,
          variables: { customerId },
        }),
      });
      const json = await res.json();
      setData(json.data.customerDashboard);
      setLoading(false);
    }
    load();
  }, [customerId]);

  if (loading) {
    return <ActivityIndicator />;
  }

  return (
    <ScrollView style={{ padding: 16 }}>
      <Text style={{ fontSize: 20, fontWeight: "bold" }}>Customer Dashboard</Text>
      <Text>Name: {data.name}</Text>
      <Text>Email: {data.email}</Text>

      <Text style={{ marginTop: 16, fontWeight: "bold" }}>Recent Orders</Text>
      {data.orders.map((o, index) => (
        <Text key={index}>
          {o.orderNumber} – {o.status}
        </Text>
      ))}

      <Text style={{ marginTop: 16, fontWeight: "bold" }}>Support Tickets</Text>
      {data.tickets.map((t, index) => (
        <Text key={index}>
          {t.subject} – {t.status}
        </Text>
      ))}
    </ScrollView>
  );
}
```

**Notice:**
Web and mobile use **same GraphQL schema**, **same query**, just **different UI**.

---

### 5. Simple Diagram

Text diagram for the overall flow:

```text
[Web Browser]           [Mobile App]
      \                      /
       \                    /
        \                  /
         --> [GraphQL Server] ----> [Customer Service]
                    |              (profile data)
                    |
                    +------------> [Order Service]
                    |              (orders data)
                    |
                    +------------> [Ticket Service]
                                   (support tickets)
```

Flow in simple steps:

1. Web or mobile sends a **GraphQL query**: `customerDashboard(customerId: "123")`.
2. GraphQL server calls **Customer Service** for profile.
3. It then calls **Order Service** for orders.
4. Then calls **Ticket Service** for tickets.
5. It combines all results into **one JSON response**.
6. Web and mobile apps display the data in their own layouts.

---

### 6. How to instruct Codex to automate this

You (or your students) can use Codex like a helper engineer.

Copy-paste style prompts:

1. **Full design (given in question):**

   > “Design the GraphQL schema, backend resolvers, and React frontend pages for a customer dashboard that shows profile, orders, and support tickets.”

2. **Backend-focused:**

   > “Given this existing REST API for /customers, /orders, and /tickets, generate a GraphQL schema and resolver functions that call these REST endpoints and expose a customerDashboard(customerId) query.”

3. **Frontend-focused (web):**

   > “Generate a React customer dashboard page that calls this GraphQL customerDashboard query using fetch, and displays profile, last 5 orders in a table, and last 5 support tickets in a list. Add loading and error states in simple code.”

4. **Mobile-focused:**

   > “Generate a React Native screen that calls the same customerDashboard GraphQL query and shows profile, recent orders, and tickets in a scrollable layout with basic styling.”

---

### 7. Summary

1. A **Customer Dashboard** is a perfect use-case for GraphQL: one query can return profile, orders, and support tickets together.
2. The **schema** centers on a `Customer` type with child lists (`orders`, `tickets`) and a single entry query `customerDashboard(customerId)`.
3. Both **web** and **mobile** frontends can reuse the **same GraphQL API**, changing only the UI components, which makes development faster and cleaner.

