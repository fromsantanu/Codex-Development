# Chapter 25. What is Apollo Client?

---

### 1. Simple introduction

Apollo Client is a **helper library** for the frontend (mostly React) that makes it easy to:

* Call a GraphQL API
* Manage loading and error states
* Store (cache) the data so you don’t refetch again and again
* Keep your UI and data in sync

You can think of Apollo Client as a **smart “GraphQL remote control”** for your React app.
Instead of manually using `fetch` for every query, you tell Apollo Client what data you want, and it handles most of the hard work.

---

### 2. Why this matters

As your app grows:

* You have **many GraphQL queries** in many components.
* You need to show **loading spinners**, **error messages**, and **data** in a clean way.
* You don’t want to **repeat the same fetch + JSON + error handling code** everywhere.
* You want to **reuse data** (cache) so you don’t make the same request again and again.

Apollo Client helps with all of this:

* One central place for GraphQL configuration (URL, headers, etc.).
* Easy hooks like `useQuery` and `useMutation`.
* Built-in cache to speed things up.

---

### 3. Real-life example (shopping app story)

Imagine you are building a small **online shop**:

* Backend exposes a **GraphQL endpoint**: `/graphql`
* You have a `Product` type with fields: `id`, `name`, `price`, `inStock`
* Frontend is a **React app** that must show:

  * A product list page
  * A product detail page
  * A shopping cart

With plain `fetch`, you would:

* Write fetch code in each component
* Handle loading and errors manually
* Parse JSON manually
* Think about caching yourself

With **Apollo Client**:

* You set up a `client` once (with the API URL).
* Wrap your app in an `ApolloProvider`.
* In each component, you just write:

```js
const { data, loading, error } = useQuery(MY_QUERY);
```

Apollo Client becomes like a **smart receptionist** who:

* Knows where the GraphQL server is
* Knows how to ask (send query) and read answers
* Remembers answers (cache) to avoid repeating questions

---

### 4. Code examples

#### 4.1 Installing Apollo Client

```bash
npm install @apollo/client graphql
# or
yarn add @apollo/client graphql
```

---

#### 4.2 Setting up Apollo Client in React

**`src/apolloClient.js`**

```js
import { ApolloClient, InMemoryCache } from '@apollo/client';

export const client = new ApolloClient({
  uri: 'https://example.com/graphql', // replace with your GraphQL endpoint
  cache: new InMemoryCache(),
});
```

**`src/main.jsx` or `src/index.jsx`**

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ApolloProvider } from '@apollo/client';
import { client } from './apolloClient';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')).render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>
);
```

Now **any child component** of `App` can use GraphQL queries with Apollo.

---

#### 4.3 GraphQL query: list of products

Let’s define a query that asks the backend for products:

```js
import { gql } from '@apollo/client';

export const GET_PRODUCTS = gql`
  query GetProducts {
    products {
      id
      name
      price
      inStock
    }
  }
`;
```

This is like saying:

> “Please give me the list of products, but I only need id, name, price, and inStock fields.”

---

#### 4.4 React page: show list of products (using `useQuery`)

**`src/ProductsPage.jsx`**

```jsx
import React from 'react';
import { useQuery } from '@apollo/client';
import { GET_PRODUCTS } from './queries';

export function ProductsPage() {
  const { data, loading, error } = useQuery(GET_PRODUCTS);

  if (loading) {
    return <p>Loading products...</p>;
  }

  if (error) {
    return <p>Failed to load products: {error.message}</p>;
  }

  if (!data || !data.products || data.products.length === 0) {
    return <p>No products found.</p>;
  }

  return (
    <div>
      <h2>Product List</h2>
      <ul>
        {data.products.map((p) => (
          <li key={p.id}>
            {p.name} – ${p.price} {p.inStock ? '(In stock)' : '(Out of stock)'}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**`src/App.jsx`**

```jsx
import React from 'react';
import { ProductsPage } from './ProductsPage';

function App() {
  return (
    <div>
      <h1>My Shop</h1>
      <ProductsPage />
    </div>
  );
}

export default App;
```

That’s it. You now have:

* Apollo Client configured
* React page that calls a GraphQL query
* Simple handling for loading, error, and empty state

---

#### 4.5 REST vs GraphQL comparison (for this page)

**REST version** (typical):

```http
GET /api/products
→ returns JSON with all product data
```

Frontend:

```js
const response = await fetch('/api/products');
const json = await response.json();
```

**GraphQL + Apollo version**:

```graphql
query GetProducts {
  products {
    id
    name
    price
    inStock
  }
}
```

Frontend:

```js
const { data, loading, error } = useQuery(GET_PRODUCTS);
```

Key idea:

* With REST, you create **many endpoints** for different views.
* With GraphQL, you create **one flexible endpoint**, and let the client specify exactly what it needs.

Apollo Client makes the GraphQL side easy inside React.

---

### 5. Simple diagram

Text diagram of the flow:

```text
React Component (ProductsPage)
        |
        |  useQuery(GET_PRODUCTS)
        v
   Apollo Client
        |
        |  sends "GetProducts" query
        v
  GraphQL Server (/graphql)
        |
        |  returns JSON with products
        v
   Apollo Client Cache
        |
        |  gives data to ProductsPage
        v
React renders list of products
```

---

### 6. How to instruct Codex to automate this

You can use Codex as your **assistant** to write most of this code.

Here are some ready-to-use prompts:

1. **Basic setup prompt (the one you asked for)**

> “Set up Apollo Client in a React app and create one page that shows a list of products using a GraphQL query.
> Use @apollo/client and a simple GET_PRODUCTS query with fields id, name, price, and inStock.
> Include the client setup, ApolloProvider in index.jsx, and a ProductsPage component that displays loading, error, and the list.”

2. **Prompt to add a details page**

> “Extend this React + Apollo Client setup to add a ProductDetail page.
> Use a GraphQL query product(id) and show name, description, price, and inStock.
> Use React Router for navigation between the list and detail pages.”

3. **Prompt to clean up code structure**

> “Refactor this React + Apollo Client code to:
>
> * Move all GraphQL queries into a separate queries.js file.
> * Keep all Apollo-related setup in apolloClient.js.
> * Keep pages like ProductsPage and ProductDetail in a pages/ folder.
>   Show the new folder structure and updated imports.”

4. **Prompt to add simple caching explanation in comments**

> “Add clear comments in plain English inside this Apollo Client setup and ProductsPage component, explaining:
>
> * What the ApolloClient and InMemoryCache do.
> * How useQuery works.
> * How Apollo cache helps avoid repeated network calls.”

---

### 7. Summary

1. **Apollo Client** is a frontend library that makes it easy to call GraphQL APIs from React and manage data (queries, mutations, cache) cleanly.
2. It provides hooks like `useQuery` and `useMutation`, handles loading and errors, and caches responses to reduce repeated requests.
3. With Codex, you can quickly generate the Apollo setup, React components, queries, and even refactor the structure, so you focus more on **what** you want to build, not on boilerplate code.

