# Chapter 41. Query Complexity Limits

---

### 1. Introduction

GraphQL is very flexible.
That is its strength, but also a risk.

A client can:

* Ask for **too many fields**.
* Ask for **deeply nested data**.
* Combine many things into **one big query**.

If you do not control this, one query can:

* Hit the database many times.
* Take a long time.
* Slow down or crash your server.

So we add **query complexity** or **depth limits** to protect the server.

---

### 2. Why this matters

As a backend developer, you want:

* **Fair use** – one client cannot send a “monster query” and block others.
* **Predictable cost** – each request should have a reasonable maximum work.
* **Simple safety net** – even if frontend makes a mistake, backend is safe.

GraphQL query limiting is like **putting a size limit on a restaurant order**:

> “You can order many dishes, but not the whole kitchen in one go.”

---

### 3. Real-life story (Grocery + Categories + Suppliers)

Imagine again an **online grocery app**:

* You have items, categories, suppliers, discounts, reviews, etc.
* A “crazy” query could ask:

```graphql
query {
  groceryItems {
    id
    name
    category {
      id
      name
      parentCategory {
        id
        name
        parentCategory {
          id
          name
          # ... and so on ...
        }
      }
    }
    supplier {
      id
      name
      address {
        city
        country
        # more nested fields...
      }
    }
    reviews {
      user {
        orders {
          items {
            # more deep stuff...
          }
        }
      }
    }
  }
}
```

This can become:

* Very **deep**.
* Very **wide** (many fields).
* Very **expensive**.

We want to say:

> “You can only go this deep”
> or
> “You can only use this much complexity score.”

---

### 4. Code Examples – Depth & Complexity (Node + Apollo)

We’ll use simple Node.js + Apollo Server examples.

There are two common ideas:

1. **Depth limit** – how deep nested fields can go.
2. **Complexity score** – give each field a “cost” and set a maximum.

We’ll show **depth first** (simpler), then a basic **complexity** idea.

> Note: In real projects you might use special libraries like
> `graphql-depth-limit` or `graphql-query-complexity`.
> We keep it conceptually simple here.

---

#### 4.1 Basic Apollo Server setup (for context)

```js
// server.js (simplified)
const { ApolloServer } = require('@apollo/server');
const typeDefs = require('./schema');
const resolvers = require('./resolvers');

const server = new ApolloServer({
  typeDefs,
  resolvers,
});

module.exports = server;
```

Now we add depth/complexity checks **before** running the resolvers.

---

#### 4.2 Simple depth limiting idea

**Goal:** Reject queries that are too deeply nested.

We can:

* Parse the query AST (Abstract Syntax Tree).
* Walk through it and measure depth.
* If depth > MAX_DEPTH → throw an error.

Here is a very simple depth calculator:

```js
// depthLimit.js
const { visit } = require('graphql');

function getQueryDepth(ast) {
  let maxDepth = 0;

  // Recursive helper
  function traverse(selectionSet, depth) {
    if (!selectionSet || !selectionSet.selections) return;

    // Update max depth
    if (depth > maxDepth) {
      maxDepth = depth;
    }

    for (const selection of selectionSet.selections) {
      if (selection.selectionSet) {
        traverse(selection.selectionSet, depth + 1);
      }
    }
  }

  // Visit the AST and start from each operation (query/mutation)
  visit(ast, {
    OperationDefinition(node) {
      traverse(node.selectionSet, 1); // depth starts from 1
    },
  });

  return maxDepth;
}

module.exports = {
  getQueryDepth,
};
```

Simple English:

* We look at the query tree.
* For each node that has children, we go one level deeper.
* We track the maximum depth we see.

---

#### 4.3 Using depth limit in Apollo request pipeline

We can use Apollo’s `plugins` to check depth **before** execution.

```js
// serverWithDepthLimit.js
const { ApolloServer } = require('@apollo/server');
const { parse } = require('graphql');
const { getQueryDepth } = require('./depthLimit');
const typeDefs = require('./schema');
const resolvers = require('./resolvers');

const MAX_DEPTH = 5; // You can choose a value that suits your app

const server = new ApolloServer({
  typeDefs,
  resolvers,
  plugins: [
    {
      async requestDidStart() {
        return {
          async didResolveOperation(requestContext) {
            // Get query string
            const query = requestContext.request.query;

            // Parse query to AST
            const ast = parse(query);

            // Calculate depth
            const depth = getQueryDepth(ast);

            // If too deep, throw an error
            if (depth > MAX_DEPTH) {
              throw new Error(
                `Query is too deep: ${depth}. Max allowed depth is ${MAX_DEPTH}.`
              );
            }
          },
        };
      },
    },
  ],
});

module.exports = server;
```

Comments in simple English:

* `MAX_DEPTH` is our safety limit.
* For each request, we:

  * Parse the query.
  * Measure depth.
  * If depth is larger than allowed, we stop and return an error.

---

#### 4.4 Simple complexity score (very basic)

Depth is good, but sometimes you also care about how many **items** might be returned.

A very simple complexity rule:

* Each field has cost = 1.
* A list field has cost = number of items requested (or a fixed cost).
* Total complexity = sum of all field costs.
* Reject if complexity > MAX_COMPLEXITY.

This is a **toy example** to understand the idea:

```js
// simpleComplexity.js
const { visit } = require('graphql');

function estimateComplexity(ast) {
  let score = 0;

  visit(ast, {
    Field(node) {
      // Base cost for each field
      let fieldCost = 1;

      // If the field has args like "first" or "limit", we can add more cost
      const limitArg =
        node.arguments &&
        node.arguments.find((arg) => arg.name.value === 'limit');

      if (limitArg && limitArg.value && limitArg.value.kind === 'IntValue') {
        const limitValue = parseInt(limitArg.value.value, 10);
        // Very naive: add limitValue to cost
        fieldCost += limitValue;
      }

      score += fieldCost;
    },
  });

  return score;
}

module.exports = {
  estimateComplexity,
};
```

Then we plug it in:

```js
// serverWithComplexityLimit.js
const { ApolloServer } = require('@apollo/server');
const { parse } = require('graphql');
const { estimateComplexity } = require('./simpleComplexity');
const typeDefs = require('./schema');
const resolvers = require('./resolvers');

const MAX_COMPLEXITY = 200;

const server = new ApolloServer({
  typeDefs,
  resolvers,
  plugins: [
    {
      async requestDidStart() {
        return {
          async didResolveOperation(requestContext) {
            const query = requestContext.request.query;
            const ast = parse(query);

            const complexity = estimateComplexity(ast);

            if (complexity > MAX_COMPLEXITY) {
              throw new Error(
                `Query is too complex: ${complexity}. Max allowed is ${MAX_COMPLEXITY}.`
              );
            }
          },
        };
      },
    },
  ],
});

module.exports = server;
```

This is not perfect, but it shows the **pattern**:

* Compute a number (complexity score).
* Compare with a maximum.
* Reject if too high.

In real life, you would use a proper library and a better scoring function.

---

#### 4.5 REST vs GraphQL view

**REST**:

* Each endpoint is usually **fixed**.
* You know roughly what each endpoint returns.
* You can manage limits per endpoint (e.g., `/items?limit=50`).

**GraphQL**:

* One endpoint.
* Clients can build very big queries.
* So you add **depth/complexity limits** to keep the “one endpoint” safe.

---

### 5. Simple Diagram

```text
Client Query
     |
     v
+----------------------+
|  GraphQL Server      |
|                      |
|  1. Parse Query AST  |
|  2. Measure depth /  |
|     complexity       |
|  3. If too big ->    |
|       return error   |
|     else -> run      |
|       resolvers      |
+----------------------+
     |
     v
Database / Services
```

---

### 6. How to Instruct Codex to Automate This

Here are prompts you can use directly with Codex.

1. **Main prompt from this chapter**

> **Prompt 1**
> “Add basic query complexity or depth limiting to this GraphQL server, with clear comments.”

2. **Depth limiting with specific library**

> **Prompt 2**
> “Using Node.js and Apollo Server, add a max query depth limit of 5 to this GraphQL server. Use the graphql-depth-limit library and comment each step in simple English.”

3. **Complexity scoring with a library**

> **Prompt 3**
> “Add a simple query complexity check using graphql-query-complexity to this Apollo Server setup. Set a max complexity of 200 and show how to return a friendly error when it is exceeded. Comment each step.”

4. **Grocery app specific**

> **Prompt 4**
> “For this grocery GraphQL schema (items, categories, suppliers), implement max query depth and max complexity in the server. Explain in comments how each part works and why it protects the backend.”

5. **Audit + fix**

> **Prompt 5**
> “Look at this existing GraphQL server code and suggest where to add depth and complexity limits. Then modify the code to include these limits with simple commented functions.”

---

### 7. Summary

1. GraphQL is powerful, but clients can send **very heavy queries** if we do not limit them.
2. We can set **max depth** and **max complexity** to stop overly deep or expensive queries before they hit our database.
3. Codex can help by **adding these limits**, wiring libraries, and explaining each step with simple comments.

