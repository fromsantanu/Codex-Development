# 45. Mocking DB Calls (Isolated Tests)

---

### 1. Introduction

When you test resolvers, you do **not** want to call the real database.
Real DB calls make tests:

* slow
* hard to set up
* sometimes inconsistent

Mocking means:
We **replace the real DB functions** with **fake functions** that return simple, fixed data.
This allows resolvers to be tested in complete isolation.

---

### 2. Why this matters

Mocking helps you:

* Test resolver logic without worrying about real SQL connections.
* Catch bugs early (wrong arguments, wrong return shapes).
* Run tests quickly on any machine.
* Build confidence when refactoring.

For agentic or backend-heavy systems, mocking is essential for fast feedback loops.

---

### 3. Real-life example

Think of a **hospital reception desk**:

* The receptionist (resolver) asks the records room (database) for patient info.
* In testing, the records room is **closed**, so we instead give the receptionist a **fake drawer** with a few fake files.

This helps us check:

* Does the receptionist pick the correct file?
* Does he respond properly if a file is missing?

The fake drawer = **mocked database layer**.

---

### 4. Code examples

We will mock the database module using **pytest’s monkeypatch** tool.

#### 4.1. Resolver code to test

```python
# resolvers.py

import db_layer  # real module

def resolve_patient(_, info, id: int):
    patient = db_layer.get_patient_by_id(id)
    if not patient:
        return {"error": "Patient not found"}
    return patient

def resolve_all_patients(_, info):
    return db_layer.get_all_patients()
```

---

### 4.2. Mocking the DB layer in tests

We replace:

* `db_layer.get_patient_by_id`
* `db_layer.get_all_patients`

with our own fake versions.

```python
# test_mock_db.py
import pytest
import resolvers
```

#### Test 1: Mock `get_patient_by_id`

```python
def test_resolve_patient_with_mock(monkeypatch):
    # Fake patient
    fake_patient = {"id": 10, "name": "Rita", "age": 32}

    # Fake DB function
    def fake_get_patient(id):
        assert id == 10
        return fake_patient

    # Replace DB function
    monkeypatch.setattr(
        "resolvers.db_layer.get_patient_by_id",
        fake_get_patient
    )

    # Run resolver
    result = resolvers.resolve_patient(None, None, id=10)

    # Assertions
    assert result["name"] == "Rita"
    assert result["age"] == 32
```

---

#### Test 2: Mock "not found" case

```python
def test_resolve_patient_not_found(monkeypatch):
    # Fake DB function returns None
    def fake_get_patient(id):
        return None

    monkeypatch.setattr(
        "resolvers.db_layer.get_patient_by_id",
        fake_get_patient
    )

    result = resolvers.resolve_patient(None, None, id=99)

    assert result == {"error": "Patient not found"}
```

---

#### Test 3: Mock list of patients

```python
def test_resolve_all_patients(monkeypatch):
    fake_list = [
        {"id": 1, "name": "A"},
        {"id": 2, "name": "B"},
    ]

    def fake_get_all():
        return fake_list

    monkeypatch.setattr(
        "resolvers.db_layer.get_all_patients",
        fake_get_all
    )

    result = resolvers.resolve_all_patients(None, None)

    assert len(result) == 2
    assert result[0]["name"] == "A"
```

---

### 5. Simple text diagram

Normal runtime:

```
Resolver → Real DB Layer → SQL/Mongo → Data
```

Mocked runtime in test:

```
Resolver → Fake DB Layer → Fake Data → Assertion
```

The resolver behaves exactly the same, but DB is replaced.

---

### 6. How to instruct Codex to automate this

Here are useful copy–paste prompts:

1. **Basic mock setup**

   > “Show how to mock the database layer in tests so I can test resolvers without real DB access.”

2. **Generate mocked tests**

   > “Given these resolver functions, generate pytest tests that mock db_layer using monkeypatch.”

3. **Improve mocking patterns**

   > “Refactor these tests to use pytest fixtures for repeated mocking, with simple explanations.”

4. **Add failure scenarios**

   > “Extend these mocked tests to include error cases like missing patient, empty list, and DB exception.”

---

### 7. Summary

* Mocking replaces real DB calls with fake functions.
* This makes tests fast, predictable, and easy to write.
* With mocking, resolvers can be tested in full isolation, ensuring clean backend logic.

