# Chapter 28. Reusing Queries Across Screens

---

### 1. Simple introduction

In a real app, you often need the **same GraphQL query** on many screens.

Example:

* Students list on dashboard
* Students list on admin page
* Students dropdown in “Create Course” form

If each screen defines the query again, your code becomes:

* Repeated
* Hard to maintain
* Easy to break when the backend changes

A better way:

* Put all GraphQL queries in **separate shared files**
* Keep them in a **graphql/ or queries/** folder
* Export them from a single **index file**

Then any screen can import queries cleanly from one place.

---

### 2. Why this matters

Benefits of shared query files:

* **One source of truth** – if you change a query, you change it only once.
* **Cleaner components** – components only import queries, they don’t define them.
* **Easier refactoring** – you can see all queries in one folder.
* **Better teamwork** – your team knows where to look for queries.

Think of it like:

* One **central recipe book** (shared queries folder)
* Many **chefs** (components) reading recipes from the same book

If you improve a recipe once, all chefs get the new version.

---

### 3. Real-life example (school app with many screens)

Imagine a **school management system**:

* `DashboardPage` – shows top 5 students
* `StudentsPage` – shows all students
* `ClassDetailsPage` – shows students in a specific class
* `CreateCourseForm` – shows students in a dropdown to assign as “class representative”

All of them need some form of **student data**.

Instead of writing `gql` in every file, you:

* Create a `graphql/` folder
* Put `studentQueries.js` inside it
* Export all student-related queries from there
* Create `index.js` to export everything cleanly

Now your screens just do:

```js
import { GET_STUDENTS } from '../graphql';
```

Simple and neat.

---

### 4. Code examples

We’ll build a small structure step by step.

#### 4.1 Folder structure

A simple structure:

```text
src/
  graphql/
    students.js
    courses.js
    index.js
  components/
    DashboardStudents.jsx
    StudentsPage.jsx
  App.jsx
```

You can adjust names, but the idea is:

* Group queries **by domain** (`students`, `courses`, etc.)
* Have an `index.js` to re-export all useful things.

---

#### 4.2 Student queries in a shared file

**`src/graphql/students.js`**

```js
import { gql } from '@apollo/client';

export const GET_STUDENTS = gql`
  query GetStudents {
    students {
      id
      name
      email
    }
  }
`;

export const GET_STUDENT_BY_ID = gql`
  query GetStudentById($id: ID!) {
    student(id: $id) {
      id
      name
      email
      age
    }
  }
`;

export const CREATE_STUDENT = gql`
  mutation CreateStudent($input: CreateStudentInput!) {
    createStudent(input: $input) {
      id
      name
      email
    }
  }
`;
```

All student-related queries and mutations are now in **one file**.

---

#### 4.3 Course queries in another file

**`src/graphql/courses.js`**

```js
import { gql } from '@apollo/client';

export const GET_COURSES = gql`
  query GetCourses {
    courses {
      id
      title
      description
    }
  }
`;

export const GET_COURSE_WITH_STUDENTS = gql`
  query GetCourseWithStudents($courseId: ID!) {
    course(id: $courseId) {
      id
      title
      students {
        id
        name
        email
      }
    }
  }
`;
```

All course-related queries live together.

---

#### 4.4 Index file to export everything cleanly

**`src/graphql/index.js`**

```js
export * from './students';
export * from './courses';
```

Now, any component can import **any** query from this one place:

```js
import { GET_STUDENTS, CREATE_STUDENT, GET_COURSES } from '../graphql';
```

Very clean.

---

#### 4.5 Using shared queries in components

**Dashboard list using shared query**

```jsx
// src/components/DashboardStudents.jsx
import React from 'react';
import { useQuery } from '@apollo/client';
import { GET_STUDENTS } from '../graphql';

export function DashboardStudents() {
  const { data, loading, error } = useQuery(GET_STUDENTS);

  if (loading) return <p>Loading students...</p>;
  if (error) return <p>Error: {error.message}</p>;

  const students = data?.students ?? [];

  return (
    <div>
      <h3>Students (Dashboard)</h3>
      <ul>
        {students.slice(0, 5).map((s) => (
          <li key={s.id}>{s.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**Admin page using the *same* shared query**

```jsx
// src/components/StudentsPage.jsx
import React from 'react';
import { useQuery } from '@apollo/client';
import { GET_STUDENTS } from '../graphql';

export function StudentsPage() {
  const { data, loading, error } = useQuery(GET_STUDENTS);

  if (loading) return <p>Loading students...</p>;
  if (error) return <p>Error: {error.message}</p>;

  const students = data?.students ?? [];

  return (
    <div>
      <h2>All Students</h2>
      <table>
        <thead>
          <tr>
            <th>Name</th><th>Email</th>
          </tr>
        </thead>
        <tbody>
          {students.map((s) => (
            <tr key={s.id}>
              <td>{s.name}</td>
              <td>{s.email}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

Both components depend on `GET_STUDENTS`, but the query lives in **one** place.

---

#### 4.6 REST vs GraphQL perspective

This idea is useful for both:

* With REST, you might have a `api/` folder with `studentsApi.js`, `coursesApi.js`, etc.
* With GraphQL, you have a `graphql/` folder with `students.js`, `courses.js`, etc.

Example:

**REST:**

```js
// api/studentsApi.js
export async function fetchStudents() {
  const res = await fetch('/api/students');
  return res.json();
}
```

**GraphQL:**

```js
// graphql/students.js
export const GET_STUDENTS = gql`...`;
```

In both cases, your components **import from central files**, not from all over the place.

---

### 5. Simple diagram

```text
            [ Components ]
          /       |        \
         /        |         \
Dashboard   StudentsPage   CoursePage
   |           |              |
   |           |              |
   v           v              v
         [ graphql/index.js ]
          /             \
         /               \
  students.js         courses.js
     |                    |
     v                    v
  GET_STUDENTS        GET_COURSES
       \                 /
        \               /
         v             v
         [ GraphQL Server ]
```

All components go through the **shared graphql folder**, instead of defining queries themselves.

---

### 6. How to instruct Codex to automate this

Here are some ready prompts you can use.

1. **Main prompt (as you asked)**

> “Organize my GraphQL queries into a separate folder and generate an index file to export them cleanly.
> Group queries by domain (students, courses, etc.) into separate files, and create a graphql/index.js that re-exports everything so components can import from '../graphql'.”

2. **Prompt to refactor existing inline queries**

> “Scan this React project and move all inline gql queries and mutations into a graphql/ folder.
> Create one file per domain (students.js, courses.js, auth.js, etc.), and replace inline definitions in components with imports from these files.
> Make sure all imports are updated.”

3. **Prompt to add TypeScript typings (optional)**

> “Convert my graphql query files to TypeScript.
> Generate type definitions for the query variables and responses, and show how components can use these typed queries with Apollo Client.”

4. **Prompt to document the structure**

> “Generate a short README section that explains the graphql/ folder structure, how to add new queries, and how to import them in components.
> Keep the explanation simple and use small code snippets.”

5. **Prompt to add an ESLint rule suggestion (optional)**

> “Suggest ESLint rules or project conventions to prevent defining gql queries directly inside components, encouraging developers to always put them in the graphql/ folder.”

---

### 7. Summary

1. Reusing queries across screens is easier when you keep them in **shared GraphQL files** inside a dedicated folder like `src/graphql/`.
2. An `index.js` file can re-export everything, so components import from a **single clean entry point** like `../graphql`.
3. Codex can help you **move existing inline queries** into this shared folder, generate an index file, update imports, and even document the structure for your team.

