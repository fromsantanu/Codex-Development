# Chapter 31. Structuring Schema for Real Projects

*Grouping types logically*

---

### 1. Introduction – From toy examples to real apps

In small demos, we write **one file** with everything:

* all types
* all queries
* all mutations

This is fine for **hello-world**.

But in a **real project** (clinic app, school system, shop),
you quickly get:

* many entities (Patient, Doctor, Appointment, Invoice, Medicine, etc.)
* many queries and mutations
* many developers working together

If you keep everything in **one big schema file**, it becomes like a **cupboard where all clothes are thrown in one shelf**.
Hard to find anything.

We need a **clean structure**: group related types and operations together.

---

### 2. Why this matters

Good schema structure helps you:

* Understand the project faster (where is “Appointment” defined?)
* Avoid merge conflicts (two devs editing same giant file)
* Separate features (patient module, billing module, pharmacy module)
* Reuse pieces across microservices or other projects

Think of it like **departments in a hospital**:
OPD, Pharmacy, Billing, Lab.
Each has its own area, but they all work together.

---

### 3. Real-life example – Clinic app

Imagine you are building a **clinic management system**.

Entities:

* `Patient`
* `Doctor`
* `Appointment`
* `Prescription`
* `Invoice`
* `Medicine`

Instead of one `schema.graphql` with everything, we can group:

* **patient** module: Patient type + patient queries/mutations
* **doctor** module: Doctor type + doctor queries/mutations
* **appointment** module: Appointment type + appointment queries/mutations
* **billing** module: Invoice type + payment-related operations
* **pharmacy** module: Medicine + Prescription-related types

This is like a clinic building diagram:

```text
Clinic App (GraphQL Schema)
  ├── Patient area
  ├── Doctor area
  ├── Appointment area
  ├── Billing area
  └── Pharmacy area
```

Each “area” = a logical group of related types and operations.

---

### 4. Code Examples

#### 4.1 Simple “modular” GraphQL schema structure

**Folder structure:**

```text
graphql/
  schema.graphql           # root types (Query, Mutation) & imports
  patient/
    patient.types.graphql
    patient.queries.graphql
    patient.mutations.graphql
  doctor/
    doctor.types.graphql
    doctor.queries.graphql
  appointment/
    appointment.types.graphql
    appointment.queries.graphql
    appointment.mutations.graphql
  billing/
    billing.types.graphql
    billing.queries.graphql
  pharmacy/
    pharmacy.types.graphql
    pharmacy.queries.graphql
```

You don’t have to follow exactly this,
but the idea is: **group by feature/domain**, not “everything in one file”.

---

#### 4.2 Example: Patient module

**`graphql/patient/patient.types.graphql`**

```graphql
type Patient {
  id: ID!
  fullName: String!
  dateOfBirth: String
  gender: String
  phoneNumber: String
  createdAt: String!
}

input CreatePatientInput {
  fullName: String!
  dateOfBirth: String
  gender: String
  phoneNumber: String
}

input UpdatePatientInput {
  fullName: String
  dateOfBirth: String
  gender: String
  phoneNumber: String
}
```

**`graphql/patient/patient.queries.graphql`**

```graphql
extend type Query {
  patient(id: ID!): Patient
  patients(
    search: String
    limit: Int = 20
    offset: Int = 0
  ): [Patient!]!
}
```

**`graphql/patient/patient.mutations.graphql`**

```graphql
extend type Mutation {
  createPatient(input: CreatePatientInput!): Patient!
  updatePatient(id: ID!, input: UpdatePatientInput!): Patient!
  deletePatient(id: ID!): Boolean!
}
```

We use `extend type Query` and `extend type Mutation`
so that **many modules** can add their own queries and mutations.

---

#### 4.3 Root schema file

**`graphql/schema.graphql`**

```graphql
schema {
  query: Query
  mutation: Mutation
}

type Query {
  _empty: String
}

type Mutation {
  _empty: String
}
```

Then your build/tooling (Apollo, GraphQL Yoga, etc.) will **merge** all files:

* patient queries/mutations
* doctor queries/mutations
* appointment, billing, pharmacy, etc.

Each module “extends” Query and Mutation.

---

#### 4.4 REST vs GraphQL – structure difference

In REST, we might group by URL prefix:

* `/patients/...`
* `/doctors/...`
* `/appointments/...`

In GraphQL, we group by **schema module**:

* `patient/` folder
* `doctor/` folder
* `appointment/` folder

But the idea is similar:
you keep related things **together**, not scattered.

---

#### 4.5 Resolvers structure (example in Node.js)

You can also group **resolvers** by feature.

**Folder structure:**

```text
src/
  graphql/
    index.ts
    patient/
      patient.resolvers.ts
    doctor/
      doctor.resolvers.ts
    appointment/
      appointment.resolvers.ts
    billing/
      billing.resolvers.ts
```

**Example `patient.resolvers.ts` (very simple):**

```ts
export const patientResolvers = {
  Query: {
    patient: async (_parent, { id }, { dataSources }) => {
      return dataSources.patientAPI.getPatientById(id);
    },
    patients: async (_parent, args, { dataSources }) => {
      return dataSources.patientAPI.listPatients(args);
    },
  },
  Mutation: {
    createPatient: async (_parent, { input }, { dataSources }) => {
      return dataSources.patientAPI.createPatient(input);
    },
    updatePatient: async (_parent, { id, input }, { dataSources }) => {
      return dataSources.patientAPI.updatePatient(id, input);
    },
    deletePatient: async (_parent, { id }, { dataSources }) => {
      return dataSources.patientAPI.deletePatient(id);
    },
  },
};
```

**In `index.ts`:**

```ts
import { patientResolvers } from "./patient/patient.resolvers";
import { doctorResolvers } from "./doctor/doctor.resolvers";
import { appointmentResolvers } from "./appointment/appointment.resolvers";

export const resolvers = [
  patientResolvers,
  doctorResolvers,
  appointmentResolvers,
  // ...billingResolvers, pharmacyResolvers, etc.
];
```

Same idea: **group by domain/feature**.

---

### 5. Simple Diagram – Grouped schema for clinic app

```text
        GraphQL Server
               |
               v
      +-----------------+
      |   Root Schema   |
      |  (Query, Mut.)  |
      +-----------------+
        /     |      \
       /      |       \
      v       v        v
 Patient    Doctor   Appointment
 Module     Module     Module
(types,     (types,    (types,
queries,    queries,   queries,
mutations)  mutations) mutations)

 ... Billing Module, Pharmacy Module, etc.
```

Frontend apps (web, mobile) call **ONE GraphQL endpoint**,
but inside that endpoint, your schema is well organized.

---

### 6. How to Instruct Codex to Help

You can ask Codex to **design the structure** for you.

1. **Main prompt (from your question):**

> “Given this list of entities for a clinic app, propose a GraphQL schema structure and file/folder layout.”

You would paste something like:

* Patient, Doctor, Appointment, Prescription, Invoice, Medicine, LabTest…

Codex can reply with:

* Suggested type names
* Suggested modules (folders)
* Example file names and content

2. **Ask Codex to break a big schema into modules**

> “Here is my large schema.graphql file for a clinic app. Split it into logical modules (patient, doctor, appointment, billing, pharmacy) with separate files. Use extend type Query and extend type Mutation where needed.”

3. **Ask Codex to generate resolver folder structure**

> “Propose a TypeScript/Node folder structure for resolvers for this GraphQL schema. Group resolvers by feature (patient, doctor, appointment). Generate simple index.ts that merges them.”

4. **Ask Codex to align REST and GraphQL structure**

> “I have these REST endpoints for a clinic system. Suggest a GraphQL schema module structure that matches these business areas: patient, doctor, appointment, billing, lab. Show example type and query definitions for each module.”

These prompts help you **move from flat demos to real, structured projects**.

---

### 7. Summary

* Real projects need **organized schemas**, not one giant file.
* Group types, queries, and mutations by **business area** (patient, doctor, appointment, billing, etc.).
* Use Codex to **plan the schema modules and folder layout**, and to split a big schema into clean, logical pieces.

