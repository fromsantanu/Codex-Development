# Chapter 26. Managing Cache Automatically

---

### 1. Simple introduction

When you use Apollo Client, it keeps a **local copy of your data** in memory.
This is called the **cache**.

* The cache is like a **mini-database inside your frontend**.
* It remembers data from your queries.
* It lets your UI update **instantly**, without waiting for another network call.

Two key ideas:

1. **Normalization** – Apollo stores each object (e.g., Product) only once, keyed by its `id`.
2. **Cache updates** – After a mutation (like `createProduct`), you can **update the cache** so the UI changes immediately.

---

### 2. Why this matters

Without cache:

* Every time a page opens, you might **refetch** the same data.
* After you create a new product, you might have to **manually refetch** the list.
* Different components might show **old values**.

With Apollo cache:

* The first query **fills** the cache.
* Other components **reuse** this data.
* When you update the cache, **all components** that depend on it re-render automatically.

Result:
Your UI feels **fast**, **smooth**, and **consistent**, with **less code**.

---

### 3. Real-life example (shop creating new products)

Imagine an **admin dashboard** for an online shop:

* Page shows a **list of products**.
* There is a **form**: “Add New Product”.
* When admin submits the form:

  * Backend creates the product.
  * UI should **immediately show** the new product in the list.

Two approaches:

* **Naive way**: After mutation → call `refetch()` or reload the page.
* **Better way (with Apollo cache)**:
  Tell Apollo:
  “Hey, we just got a new product from `createProduct`. Please **insert it into the cached list** used by `GET_PRODUCTS` query.”

The user sees the new product **instantly**, and no extra request is needed.

---

### 4. Code examples

We’ll assume:

* A `Product` type in GraphQL.
* A `GET_PRODUCTS` query.
* A `createProduct` mutation.

#### 4.1 GraphQL schema (simplified)

```graphql
type Product {
  id: ID!
  name: String!
  price: Float!
  inStock: Boolean!
}

type Query {
  products: [Product!]!
}

input CreateProductInput {
  name: String!
  price: Float!
  inStock: Boolean!
}

type Mutation {
  createProduct(input: CreateProductInput!): Product!
}
```

---

#### 4.2 Example resolvers (Node-style, very simple)

```js
const products = []; // pretend DB

const resolvers = {
  Query: {
    products: () => products,
  },
  Mutation: {
    createProduct: (_, { input }) => {
      const newProduct = {
        id: String(products.length + 1),
        ...input,
      };
      products.push(newProduct);
      return newProduct;
    },
  },
};

export default resolvers;
```

In a real app, you would use a database, but the idea is the same.

---

#### 4.3 Frontend: queries and mutations

**`src/queries.js`**

```js
import { gql } from '@apollo/client';

export const GET_PRODUCTS = gql`
  query GetProducts {
    products {
      id
      name
      price
      inStock
    }
  }
`;

export const CREATE_PRODUCT = gql`
  mutation CreateProduct($input: CreateProductInput!) {
    createProduct(input: $input) {
      id
      name
      price
      inStock
    }
  }
`;
```

---

#### 4.4 Products list page (using cached data)

**`src/ProductsPage.jsx`**

```jsx
import React from 'react';
import { useQuery } from '@apollo/client';
import { GET_PRODUCTS } from './queries';

export function ProductsPage() {
  const { data, loading, error } = useQuery(GET_PRODUCTS);

  if (loading) return <p>Loading products...</p>;
  if (error) return <p>Error: {error.message}</p>;

  const products = data?.products ?? [];

  if (products.length === 0) {
    return <p>No products found.</p>;
  }

  return (
    <div>
      <h2>Product List</h2>
      <ul>
        {products.map((p) => (
          <li key={p.id}>
            {p.name} – ${p.price} {p.inStock ? '(In stock)' : '(Out of stock)'}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

This list is powered by Apollo’s cache after the first query.

---

#### 4.5 Creating a product and updating the cache

Now the important part: **after `createProduct`**, we want:

* The new product to appear in `ProductsPage` automatically.
* No full refetch, no page reload.

We use the `update` function in `useMutation`.

**`src/CreateProductForm.jsx`**

```jsx
import React, { useState } from 'react';
import { useMutation } from '@apollo/client';
import { CREATE_PRODUCT, GET_PRODUCTS } from './queries';

export function CreateProductForm() {
  const [name, setName] = useState('');
  const [price, setPrice] = useState('0');
  const [inStock, setInStock] = useState(true);

  const [createProduct, { loading, error }] = useMutation(
    CREATE_PRODUCT,
    {
      update(cache, { data }) {
        const newProduct = data?.createProduct;
        if (!newProduct) return;

        // Read existing products from cache
        const existing = cache.readQuery({ query: GET_PRODUCTS });

        const existingProducts = existing?.products ?? [];

        // Write back a new array with the newly created product
        cache.writeQuery({
          query: GET_PRODUCTS,
          data: {
            products: [...existingProducts, newProduct],
          },
        });
      },
    }
  );

  async function handleSubmit(e) {
    e.preventDefault();

    await createProduct({
      variables: {
        input: {
          name,
          price: parseFloat(price),
          inStock,
        },
      },
    });

    // Clear the form (optional)
    setName('');
    setPrice('0');
    setInStock(true);
  }

  return (
    <form onSubmit={handleSubmit}>
      <h3>Create New Product</h3>

      <div>
        <label>
          Name:{' '}
          <input
            value={name}
            onChange={(e) => setName(e.target.value)}
            required
          />
        </label>
      </div>

      <div>
        <label>
          Price:{' '}
          <input
            type="number"
            step="0.01"
            value={price}
            onChange={(e) => setPrice(e.target.value)}
            required
          />
        </label>
      </div>

      <div>
        <label>
          In Stock:{' '}
          <input
            type="checkbox"
            checked={inStock}
            onChange={(e) => setInStock(e.target.checked)}
          />
        </label>
      </div>

      <button type="submit" disabled={loading}>
        {loading ? 'Creating...' : 'Create Product'}
      </button>

      {error && <p>Error creating product: {error.message}</p>}
    </form>
  );
}
```

Key lines inside `update`:

```js
update(cache, { data }) {
  const newProduct = data?.createProduct;

  const existing = cache.readQuery({ query: GET_PRODUCTS });
  const existingProducts = existing?.products ?? [];

  cache.writeQuery({
    query: GET_PRODUCTS,
    data: {
      products: [...existingProducts, newProduct],
    },
  });
}
```

This tells Apollo:

> “Take the old `products` list from the cache and add `newProduct`. Use that as the new value.”

Because `ProductsPage` uses `GET_PRODUCTS`, it will **automatically re-render** with the new list.

---

#### 4.6 Cache normalization (simple explanation)

Apollo uses a key like `Product:1`, `Product:2`, etc., based on:

* `__typename` (e.g., `"Product"`)
* `id` field

When different queries return the **same product**, Apollo stores **one copy** in the cache and links to it from many places.

Real-life analogy:

* You have one **master record** for each product in a card catalog.
* Different lists (by category, by price, by brand) all **point to the same card**.
* If you update the card once, all lists that refer to it are automatically “updated”.

That’s normalization: **each real-world object has one master entry** in the cache.

---

### 5. Simple diagram

```text
[ GraphQL Server ]
        ^
        | createProduct mutation
        v
[ Apollo Client ]
   - Cache (normalized)
      - Product:1
      - Product:2
      - Product:3 (new!)
        ^
        | update() function adds new product
        |
   - GET_PRODUCTS query data
        ^
        | ProductsPage reads from cache
        v
[ React UI ]  ---> List refreshed automatically
```

---

### 6. How to instruct Codex to automate this

You can ask Codex to generate most of this cache logic for you.

Here are practical prompts:

1. **Main prompt (as you required)**

> “Show how to use Apollo cache to update the UI after a createProduct mutation, with a clear code example.
> Use a GET_PRODUCTS query for the product list and a CREATE_PRODUCT mutation.
> Show the useMutation hook with an update function that adds the new product into the existing products list in the cache.”

2. **Prompt to add normalization explanation in comments**

> “Add comments to this Apollo Client example explaining:
>
> * What the cache is.
> * How normalization works (Product objects stored by id).
> * Why updating the cache in the update function refreshes all components using GET_PRODUCTS.”

3. **Prompt to show alternative using cache.modify**

> “Refactor this cache update logic to use cache.modify instead of readQuery/writeQuery.
> Show a simple example where cache.modify adds the new product id to the products field, and explain it in plain English comments.”

4. **Prompt to integrate form + list on one page**

> “Combine the CreateProductForm and ProductsPage into a single React page.
> Use Apollo Client so that when a new product is created, the list updates immediately via the cache update function and no refetch is called.”

---

### 7. Summary

1. Apollo’s **cache** is like a local mini-database that stores query results and keeps your UI and data in sync.
2. **Normalization** means each object (like a Product) is stored once by id, so updates automatically flow to all places that use it.
3. After a mutation (like `createProduct`), you can use the `update` function (or `cache.modify`) to **insert the new item into cached lists**, giving instant UI updates without extra network calls.

