
# Chapter 4. Where GraphQL Fits in Web Architecture

## 1. Introduction  
GraphQL sits in the middle of your system.  
The frontend talks to the GraphQL server.  
The GraphQL server talks to your databases or microservices.  
You can think of GraphQL as a smart receptionist who knows where to collect each piece of information.  
This keeps the frontend simple and keeps the backend organised.

---

## 2. Why This Matters  
- Frontend deals with only **one endpoint**.  
- Backend teams can keep microservices separate without confusing the UI team.  
- GraphQL hides the complexity of multiple data sources.  
- Clean architecture → faster development and fewer bugs.

---

## 3. Real-Life Example (Hospital Reception Desk)  
In a hospital, the reception desk knows which department to call:

- For reports → lab  
- For old records → archives  
- For medicines → pharmacy  

Frontend = patient  
GraphQL = reception  
Microservices/DB = departments  

The patient talks only to the reception desk, not to every department.

---

## 4. Code Example (Very Simple Illustration)

### A. Query from Frontend  
```graphql
query {
  customer(id: 5) {
    name
    orders {
      id
      total
    }
  }
}
````

### B. Resolver Structure

```js
Query: {
  customer: (_, { id }, { services }) => {
    return services.customerService.getCustomer(id);
  }
}
```

GraphQL decides which service to call.

---

## 5. Diagram

```
   Browser (Frontend)
          |
          v
   GraphQL Server
   -----------------
   |   Resolver     |
   -----------------
   /        |        \
  v         v         v
Customer   Orders    Inventory
Service    Service   Service
      (or Database Connections)
```

Another simple view:

```
Frontend → GraphQL → Microservices/DB
```

---

## 6. Data Flow (5–6 Simple Steps)

1. Browser sends a GraphQL query to **/graphql**.
2. GraphQL server reads the query and checks which fields are needed.
3. It calls the correct resolver functions.
4. Each resolver talks to a database or a microservice.
5. Data comes back to the GraphQL server.
6. GraphQL sends only the requested fields back to the browser.

---

## 7. How to Instruct Codex (Copy-Paste Prompts)

**Prompt 1**
“Draw a simple text diagram showing browser, GraphQL server, and backend services. Then explain data flow in 5–6 simple steps.”

**Prompt 2**
“Codex, generate a simple resolver layer that calls two microservices inside one query.”

**Prompt 3**
“Codex, show how a single GraphQL query can combine data from CustomerService and OrderService.”

**Prompt 4**
“Codex, create a small demo GraphQL architecture diagram and give a 5-step data flow explanation.”

---

## 8. Summary

* GraphQL sits between frontend and backend services.
* Frontend uses one endpoint; backend stays modular.
* GraphQL decides which service to call using resolvers.
* Clear, simple design that works well with microservices.

---


