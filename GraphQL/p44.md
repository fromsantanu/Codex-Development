# 44. Unit Testing Resolvers (Simple Tests)

---

### 1. Introduction

Resolvers are just functions.
Like any function, they can have bugs.

Unit testing means:

* We test one small piece at a time.
* We do **not** hit the real database or network.
* We check: “Given this input, did we get the correct output?”

Here we will see how to test resolvers using **pytest** and a **mock** database.

---

### 2. Why this matters

Why should a backend developer care?

* Your GraphQL schema may look perfect, but if resolvers are wrong, the **API lies**.
* If you refactor code later, tests tell you if you broke something.
* With good tests, you can change database or microservices with more confidence.
* For agentic or backend-heavy systems, tests are your **safety net**.

---

### 3. Real-life example (simple story)

Imagine a **clinic system**:

* The **frontend** asks:
  `patient(id: 5) { name age }`
* The **resolver** goes to the database and returns patient data.

This is like:

* The **receptionist (resolver)** goes to the **file room (database)** to fetch a patient file.
* In tests, we do **not** want to go to the real file room.
  We create a **fake file room** and check if the receptionist brings the right file.

That fake file room = **mock database**.

---

### 4. Code examples

We’ll use:

* Python
* Simple resolver functions
* `pytest`
* A “mock” database layer that we can replace in tests

#### 4.1. Example resolver functions (Python)

Let’s say we have two resolvers:

* `resolve_patient` – get one patient by id
* `resolve_patients` – list all patients

```python
# resolvers.py

from typing import List, Dict, Any

# In real code this would be a DB module (e.g., SQLAlchemy session)
import db_layer


def resolve_patient(_, info, id: int) -> Dict[str, Any]:
    """Return one patient by id."""
    patient = db_layer.get_patient_by_id(id)
    return patient


def resolve_patients(_, info) -> List[Dict[str, Any]]:
    """Return list of all patients."""
    patients = db_layer.get_all_patients()
    return patients
```

Here:

* `db_layer.get_patient_by_id` and `db_layer.get_all_patients` talk to the real DB.
* In tests, we will **replace** (`mock`) these functions with fake ones.

---

#### 4.2. Using pytest and mocking the DB layer

We want to:

* Call `resolve_patient` and `resolve_patients`
* Provide **fake** return values from `db_layer`
* Check that resolvers return expected data

We can use `monkeypatch` from `pytest` to mock.

```python
# test_resolvers.py

import pytest
import resolvers


def test_resolve_patient(monkeypatch):
    # 1. Prepare fake patient data
    fake_patient = {"id": 1, "name": "Alice", "age": 30}

    # 2. Define a fake function to replace db_layer.get_patient_by_id
    def fake_get_patient_by_id(patient_id):
        assert patient_id == 1  # ensure resolver calls with correct ID
        return fake_patient

    # 3. Apply the monkeypatch
    monkeypatch.setattr("resolvers.db_layer.get_patient_by_id", fake_get_patient_by_id)

    # 4. Call the resolver
    result = resolvers.resolve_patient(None, None, id=1)

    # 5. Check the result
    assert result == fake_patient
    assert result["name"] == "Alice"
    assert result["age"] == 30


def test_resolve_patients(monkeypatch):
    # 1. Prepare fake list
    fake_patients = [
        {"id": 1, "name": "Alice", "age": 30},
        {"id": 2, "name": "Bob", "age": 40},
    ]

    # 2. Fake function for get_all_patients
    def fake_get_all_patients():
        return fake_patients

    # 3. Apply monkeypatch
    monkeypatch.setattr("resolvers.db_layer.get_all_patients", fake_get_all_patients)

    # 4. Call resolver
    result = resolvers.resolve_patients(None, None)

    # 5. Check result
    assert result == fake_patients
    assert len(result) == 2
    assert result[0]["name"] == "Alice"
```

Key ideas:

* We **don’t** start a GraphQL server. We just call the resolver function directly.
* `monkeypatch.setattr("resolvers.db_layer.get_patient_by_id", fake_get_patient_by_id)`
  means: “During this test, if someone calls `resolvers.db_layer.get_patient_by_id`,
  actually call `fake_get_patient_by_id` instead.”

---

#### 4.3. How this relates to GraphQL

In a real GraphQL server (Graphene, Ariadne, etc.):

* These functions would be attached to `Query` fields.
* The GraphQL engine would call them.

For **unit tests**:

* We skip the engine.
* We test: “If resolver is given some arguments, does it talk to the DB layer correctly and return correct shape?”

This is fast and simple.

---

### 5. Simple text diagram

**Normal runtime:**

```text
GraphQL Query
    ↓
Resolver function (e.g., resolve_patient)
    ↓
Real DB layer (SQL, Mongo, REST call)
    ↓
Real data → back to client
```

**In unit test:**

```text
Test (pytest)
    ↓
Resolver function
    ↓
Mock DB layer (fake functions, fixed data)
    ↓
Fake data → checked by assertions
```

We only care about the middle part: **“Does resolver behave correctly?”**

---

### 6. How to instruct Codex to automate this

You can ask Codex to help write and improve these tests.

Copy–paste style prompts:

1. **Basic test generation**

   > “Generate pytest unit tests for these resolver functions, mocking the database layer.”

2. **Adapting to your project structure**

   > “Here are my GraphQL resolver functions in Python. Write pytest tests that mock the db_layer module using monkeypatch, with clear comments.”

3. **Adding edge cases**

   > “Extend these pytest tests to cover edge cases: patient not found, empty patient list, and database error. Return user-friendly errors from the resolvers.”

4. **Refactoring existing tests**

   > “Refactor these pytest tests for my GraphQL resolvers to remove duplication. Extract common mock setup into fixtures and explain each change in simple English.”

---

### 7. Summary

* Resolvers are just functions, so they are perfect for **unit testing**.
* We mock the **database layer** to test resolver logic without real DB calls.
* `pytest` with `monkeypatch` (or other mocking tools) lets us create fast, simple tests that protect our GraphQL API from silent bugs.

