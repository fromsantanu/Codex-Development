# 56. Super-app API (web + mobile + kiosk)

### 1. Introduction

Here we design a **GraphQL API** that works for:

* **Web app** (big screen, full dashboard)
* **Mobile app** (small screen, limited data)
* **Kiosk** (touch screen at the shop / clinic)

All three should:

* Talk to the **same backend**
* Use **one GraphQL schema**
* Ask for **different shapes of data** based on their needs

Think of it like **one kitchen** serving:

* dine-in (web)
* takeaway (mobile)
* drive-through (kiosk)

The recipes (data) are the same. The **serving style** changes.

---

### 2. Why this matters

Modern “**super-apps**” often have many clients:

* User web portal
* Customer mobile app
* Physical kiosk at the location (clinic, mall, station)

If you use only REST, people sometimes create:

* `/web/home`
* `/mobile/home`
* `/kiosk/home`

This leads to:

* Repeated logic
* More maintenance
* Confusion over which API to use

With **GraphQL**:

* You design **one schema** with flexible types.
* Each client (web, mobile, kiosk) asks **only what it needs**.
* You can still **tune** behaviour with a `clientType` or similar argument.

---

### 3. Use-case story (real-life example)

Imagine a **service booking app** (like a small “super-app”):

Services:

* salon
* spa
* doctor consultations

**Web app**:

* Shows full **dashboard**
* List of **upcoming bookings**
* Past bookings
* Offers

**Mobile app**:

* Needs to be **fast and light**
* Just show: next 1–3 bookings, quick “Book Again” buttons

**Kiosk** in the clinic / salon:

* No login typing (maybe phone number + OTP)
* Show today’s bookings at **this location only**
* Let user check-in with one tap

All three use **the same GraphQL API**, but they call it in **different ways**.

---

### 4. Code Examples

We’ll propose a **schema** and show **queries** for web, mobile, and kiosk.

#### 4.1 GraphQL Schema (SDL)

```graphql
# super_app.graphql

enum ClientType {
  WEB
  MOBILE
  KIOSK
}

type User {
  id: ID!
  name: String!
  phone: String
  email: String
  # Mobile might not need all fields every time
}

type Service {
  id: ID!
  name: String!
  description: String
  durationMinutes: Int!
  basePrice: Float!
}

type Location {
  id: ID!
  name: String!
  address: String
}

enum BookingStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
  CHECKED_IN
}

type Booking {
  id: ID!
  user: User!
  service: Service!
  location: Location!
  startTime: String!
  status: BookingStatus!
}

# Simple "home summary" customized by client type
type HomeSummary {
  user: User
  upcomingBookings: [Booking!]!
  suggestedServices: [Service!]!
  # For kiosks we might also include:
  location: Location
}

type Query {
  # One flexible entry point for different clients
  homeSummary(
    client: ClientType!
    userId: ID
    locationId: ID
    limitUpcoming: Int = 3
  ): HomeSummary!

  services(locationId: ID): [Service!]!
  bookingsByUser(userId: ID!, upcomingOnly: Boolean = true): [Booking!]!
  bookingsByLocation(locationId: ID!, date: String): [Booking!]!
}
```

**Design decisions (in simple language):**

1. **One schema for all clients**

   * We do **not** create `WebHomeSummary`, `MobileHomeSummary`, `KioskHomeSummary`.
   * We use one `HomeSummary` and **clients pick fields**.

2. **`client: ClientType!` argument**

   * Tells the server **who is asking** (web / mobile / kiosk).
   * The resolver can adjust **how much data** or **which suggestions** to include.
   * But the **shape** stays stable, so versioning is easier.

3. **Optional and list fields**

   * `user` might be `null` on kiosk for some flows (e.g. before login).
   * `locationId` is useful for kiosk (show data for one location).
   * `limitUpcoming` helps **mobile** ask for fewer bookings (lighter response).

4. **Keep presentation out of API**

   * We return *data*, not UI layouts (“2 columns”, “card size” etc.).
   * Web, mobile, kiosk decide how to **display** the same data.

---

#### 4.2 Example Resolver Logic (pseudo-code)

**HomeSummary** resolver (Node-style pseudocode):

```js
const resolvers = {
  Query: {
    async homeSummary(_, args, context) {
      const { client, userId, locationId, limitUpcoming } = args;

      let user = null;
      let location = null;
      let upcomingBookings = [];
      let suggestedServices = [];

      if (userId) {
        user = await context.services.userService.getUserById(userId);
      }

      if (locationId) {
        location = await context.services.locationService.getLocationById(locationId);
      }

      // Upcoming bookings
      if (userId) {
        const allUpcoming = await context.services.bookingService.getUpcomingByUser(userId);
        // For mobile, maybe limit more aggressively
        const maxCount = client === "MOBILE" ? Math.min(limitUpcoming, 3) : limitUpcoming;
        upcomingBookings = allUpcoming.slice(0, maxCount);
      } else if (client === "KIOSK" && locationId) {
        // Kiosk might show people booked for today at this location
        upcomingBookings = await context.services.bookingService.getTodayByLocation(locationId);
      }

      // Suggested services: we can tweak based on client
      if (client === "WEB") {
        suggestedServices = await context.services.serviceService.getPopularServices({ limit: 10 });
      } else if (client === "MOBILE") {
        suggestedServices = await context.services.serviceService.getQuickBookServices({ limit: 5 });
      } else if (client === "KIOSK" && locationId) {
        suggestedServices = await context.services.serviceService.getServicesByLocation(locationId);
      }

      return {
        user,
        upcomingBookings,
        suggestedServices,
        location,
      };
    },
  },
};
```

**Key idea:**
Same **query name**, different **behaviour** according to `client` and arguments.

---

#### 4.3 Queries for Web, Mobile, and Kiosk

##### 4.3.1 Web Home Query

```graphql
query WebHome($userId: ID!) {
  homeSummary(client: WEB, userId: $userId, limitUpcoming: 5) {
    user {
      name
      email
      phone
    }
    upcomingBookings {
      id
      startTime
      status
      service {
        name
      }
      location {
        name
      }
    }
    suggestedServices {
      id
      name
      description
      basePrice
    }
  }
}
```

Web asks for:

* More **details** (email, phone, description)
* More **bookings** (e.g., 5)

---

##### 4.3.2 Mobile Home Query

```graphql
query MobileHome($userId: ID!) {
  homeSummary(client: MOBILE, userId: $userId) {
    user {
      name
    }
    upcomingBookings {
      id
      startTime
      service {
        name
      }
    }
    suggestedServices {
      id
      name
    }
  }
}
```

Mobile asks for:

* Very **compact** data
* Only **what fits** nicely on the small screen

---

##### 4.3.3 Kiosk Home Query

```graphql
query KioskHome($locationId: ID!) {
  homeSummary(client: KIOSK, locationId: $locationId) {
    location {
      name
      address
    }
    upcomingBookings {
      id
      startTime
      status
      user {
        name
        phone
      }
      service {
        name
      }
    }
    suggestedServices {
      id
      name
    }
  }
}
```

Kiosk asks for:

* Bookings for **this location**
* Enough user info to confirm identity at the counter
* Simple list of services to choose from

---

### 5. Simple Diagram

```text
         [Web App]        [Mobile App]        [Kiosk]
             \               |               /
              \              |              /
               \             |             /
                 --> [GraphQL Super-App API] <---
                           (homeSummary)
                     /           |          \
                    /            |           \
            [User Service]   [Booking Service]   [Service/Location Service]
```

Flow:

1. Client (web / mobile / kiosk) sends **homeSummary** query with a `client` value.
2. GraphQL API calls **user**, **booking**, and **service/location** services as needed.
3. It builds a **HomeSummary** object.
4. Each client **chooses fields** it wants to show.

---

### 6. How to instruct Codex to automate this

You can ask Codex to design and explain this for you.

Main prompt (given by you):

> “Propose a GraphQL schema that can support web, mobile, and kiosk clients for a service app, and explain design decisions.”

Some more detailed prompts:

1. **Schema design:**

   > “Design a GraphQL schema for a service booking super-app that supports web, mobile, and kiosk clients. Use a ClientType enum and a homeSummary query that returns user, upcomingBookings, suggestedServices, and location. Explain each important design decision in simple language.”

2. **Resolvers and microservices:**

   > “Generate resolver pseudo-code for the homeSummary query that calls user, booking, and service/location microservices, and behaves slightly differently for WEB, MOBILE, and KIOSK client types.”

3. **Client-specific queries:**

   > “Generate three example GraphQL queries: one for the web home page, one for the mobile home screen, and one for the kiosk screen, all using the same homeSummary query but requesting different fields.”

4. **Frontend sample (optional):**

   > “Create a simple React component called SuperAppHome that calls the homeSummary GraphQL query for a MOBILE client and renders a compact home screen with user name, next 3 bookings, and quick actions for suggested services.”

---

### 7. Summary

1. A **super-app API** can serve web, mobile, and kiosk clients using **one GraphQL schema** and a flexible query like `homeSummary`.
2. The `client: ClientType!` argument lets the server **tune behaviour**, while clients still pick **only the fields** they need.
3. This keeps the **backend consistent**, avoids duplicated REST endpoints, and gives each client the **right amount of data** in a clean, future-friendly way.

