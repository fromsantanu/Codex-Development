# Chapter 8. Mutations — Changing Data

---

## A. Introduction

So far we only **asked** for data with **queries**.
Now we will **change** data with **mutations**.

In GraphQL, a **Mutation** is used when you want to:

* **Add** something new (create)
* **Update** something (edit)
* **Delete** something (remove)

You can think of mutations like **forms** in a web app:

* “Add new student” form
* “Edit student details” form
* “Delete student” button

---

## B. Why this matters

As a backend developer, mutations are important because:

* They define **how the outside world can change your data**.
* They act like **public methods** of your system (safe, controlled).
* They keep your API **clean** and your data **safe** (only allowed changes).

Frontends will call these mutations to save data from forms and actions.

---

## C. Real-life Example – School Admin Desk

At the school admin desk, staff might:

* Add a new student to the register.
* Update a student’s email or name.
* Remove a student who left the school.

In GraphQL:

* “Add student” → `addStudent` mutation
* “Update student” → `updateStudent` mutation
* “Delete student” → `deleteStudent` mutation

Mutations are simply **named actions** that change the system.

---

## D. Code Examples

We will extend our **student–course** schema.

### 1. Input Types for Mutations

Instead of passing many arguments directly, we can use **input types**.
Input types are like “form objects” you send into a mutation.

```graphql
# Input type for creating a new student
input AddStudentInput {
  name: String!
  email: String!
}

# Input type for updating an existing student
input UpdateStudentInput {
  id: ID!          # Which student to update
  name: String     # Optional new name
  email: String    # Optional new email
}
```

### 2. Mutation Definitions (add, update, delete)

```graphql
type Mutation {
  # Add a new student
  addStudent(input: AddStudentInput!): Student!

  # Update an existing student
  updateStudent(input: UpdateStudentInput!): Student!

  # Delete a student by ID
  deleteStudent(id: ID!): Boolean!
  # Returns true if delete was successful
}
```

Now we have **three basic operations**:

* `addStudent`
* `updateStudent`
* `deleteStudent`

---

### 3. Sample Mutation Calls (from the client)

#### 3.1 Add a new student

```graphql
mutation {
  addStudent(input: {
    name: "Amit Singh"
    email: "amit@example.com"
  }) {
    id
    name
    email
  }
}
```

Result might look like:

```json
{
  "data": {
    "addStudent": {
      "id": "stu_101",
      "name": "Amit Singh",
      "email": "amit@example.com"
    }
  }
}
```

#### 3.2 Update a student

Only change what you need (e.g., email).

```graphql
mutation {
  updateStudent(input: {
    id: "stu_101"
    email: "amit.singh@newmail.com"
  }) {
    id
    name
    email
  }
}
```

#### 3.3 Delete a student

```graphql
mutation {
  deleteStudent(id: "stu_101")
}
```

Result:

```json
{
  "data": {
    "deleteStudent": true
  }
}
```

---

### 4. REST vs GraphQL for Mutations

**REST style**

```http
POST   /students          # add student
PUT    /students/stu_101  # update student
DELETE /students/stu_101  # delete student
```

**GraphQL style**
(Still one endpoint, different operations defined in schema.)

```graphql
mutation AddStudent {
  addStudent(input: { name: "Amit", email: "amit@example.com" }) {
    id
  }
}

mutation UpdateStudent {
  updateStudent(input: { id: "stu_101", email: "amit@new.com" }) {
    id
    email
  }
}

mutation DeleteStudent {
  deleteStudent(id: "stu_101")
}
```

---

### 5. Example Resolver Sketch

Just to see how it connects to backend code:

```js
const resolvers = {
  Mutation: {
    addStudent: (_, { input }, ctx) => {
      // input has name and email
      return ctx.db.createStudent(input.name, input.email);
    },
    updateStudent: (_, { input }, ctx) => {
      // input has id and maybe name/email
      return ctx.db.updateStudent(input.id, {
        name: input.name,
        email: input.email,
      });
    },
    deleteStudent: (_, { id }, ctx) => {
      return ctx.db.deleteStudent(id); // returns true/false
    },
  },
};
```

* The mutation name maps to a **function**.
* The function receives `input` and does DB operations.

---

## E. Simple Diagram

```text
Frontend (Form/Button)
        |
        v
   GraphQL Mutation
        |
        v
   GraphQL Server
        |
        v
   Mutation Resolver
        |
        v
   Database (insert/update/delete)
        |
        v
 Response (new/updated state or success flag)
```

---

## F. How to Instruct Codex

Here are some prompts you can give to Codex.

### F.1 Create basic student mutations

> “Create GraphQL mutation definitions for adding, updating, and deleting a student, including simple input types. Use a Student type with id, name, and email. Add comments in plain English.”

### F.2 Add mutations to existing schema

> “Here is my current student-course GraphQL schema:
>
> ```graphql
> [PASTE SCHEMA HERE]
> ```
>
> Extend it by adding:
>
> * AddStudentInput
> * UpdateStudentInput
> * addStudent, updateStudent, deleteStudent mutations.
>   Use ID, String, and Boolean where appropriate and add comments for each field.”

### F.3 Generate example mutation queries

> “Using this student mutation schema:
>
> ```graphql
> [PASTE MUTATION PART HERE]
> ```
>
> Generate example GraphQL mutation operations to:
>
> * Add a new student
> * Update only the email of a student
> * Delete a student
>   Show the expected JSON responses as well.”

### F.4 Resolver skeletons for mutations

> “Write JavaScript resolver functions for these GraphQL mutations:
> addStudent, updateStudent, deleteStudent.
> Assume there is a ctx.db object with createStudent, updateStudent, and deleteStudent methods.
> Add clear comments explaining each resolver step in simple language.”

---

## G. Summary

1. **Mutations** are used to **change data** in GraphQL: add, update, and delete.
2. **Input types** help group related fields (like form data) into clean arguments.
3. Codex can generate mutation definitions, example operations, and resolver code, making it easy to build safe, well-structured write APIs.

