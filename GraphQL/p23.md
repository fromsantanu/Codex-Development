# 23. Handling Loading, Errors & Empty State

### (Spinners and Messages for GraphQL UIs)

---

### 1. Short Introduction

When your UI calls a GraphQL API, three common situations happen:

1. **Loading** – request is still in progress.
2. **Error** – something went wrong (network, server, GraphQL error).
3. **Empty state** – request worked, but there is **no data** (e.g., zero students).

If you don’t handle these, users see:

* A blank screen
* An ugly browser error
* Or stale old data

In this chapter, we learn how to add:

* A **loading spinner / message**
* A **clear error message**
* A friendly **“no data”** message

---

### 2. Why This Matters

For real apps (clinic, school, shop):

* Internet can be slow
* API may fail sometimes
* Sometimes there really is **no record** yet (e.g., “no patients today”)

If your UI shows nothing, users think **“App is broken”**.

Good UX always:

* Shows **something** while waiting
* Tells the user **what went wrong**
* Makes “no data” feel normal (“No students found. Try adding one.”)

This makes your app feel **professional** and **trustworthy**.

---

### 3. Real-Life Example – Appointment List

Imagine a **hospital receptionist** app:

* It loads today’s appointment list from GraphQL.
* Possible situations:

1. The server takes time → show **spinner** (“Loading appointments…”).
2. The server fails → show **error text** (“Could not load appointments. Please try again.”).
3. No appointments → show **empty state** (“No appointments for today.”).
4. Normal case → show the **table** of appointments.

Same idea for any list: students, orders, bills, patients, etc.

---

### 4. Code Examples

We’ll use React + GraphQL, but the idea is same in any frontend.

#### 4.1 Basic Component *without* proper states (for context)

```jsx
// BadExample.jsx
import React, { useEffect, useState } from "react";

const GRAPHQL_URL = "http://localhost:4000/graphql";

const STUDENTS_QUERY = `
  query {
    students {
      id
      name
      email
    }
  }
`;

export default function BadStudentList() {
  const [students, setStudents] = useState([]);

  useEffect(() => {
    async function load() {
      const res = await fetch(GRAPHQL_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query: STUDENTS_QUERY }),
      });
      const result = await res.json();
      setStudents(result.data.students);
    }
    load();
  }, []);

  // Problem: No loading, no error, no empty state
  return (
    <div>
      <h3>Students</h3>
      <ul>
        {students.map(s => (
          <li key={s.id}>{s.name} – {s.email}</li>
        ))}
      </ul>
    </div>
  );
}
```

Issues:

* At first render, `students` is `[]` → looks like “no students”, but actually **still loading**.
* If GraphQL fails, user still sees an empty list, no message.

---

#### 4.2 Good Component – Loading, Error, Empty

```jsx
// StudentListWithStates.jsx
import React, { useEffect, useState } from "react";

const GRAPHQL_URL = "http://localhost:4000/graphql";

const STUDENTS_QUERY = `
  query {
    students {
      id
      name
      email
    }
  }
`;

export default function StudentListWithStates() {
  const [students, setStudents] = useState([]);
  const [loading, setLoading] = useState(true);
  const [errorMsg, setErrorMsg] = useState("");

  useEffect(() => {
    async function load() {
      try {
        setLoading(true);
        setErrorMsg("");

        const res = await fetch(GRAPHQL_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: STUDENTS_QUERY }),
        });

        if (!res.ok) {
          throw new Error(`HTTP error ${res.status}`);
        }

        const result = await res.json();

        if (result.errors && result.errors.length > 0) {
          throw new Error(result.errors[0].message);
        }

        setStudents(result.data.students || []);
      } catch (err) {
        setErrorMsg(err.message || "Something went wrong while loading students.");
      } finally {
        setLoading(false);
      }
    }

    load();
  }, []);

  // 1) Loading state
  if (loading) {
    return (
      <div>
        <h3>Students</h3>
        <div>Loading… (spinner can go here)</div>
      </div>
    );
  }

  // 2) Error state
  if (errorMsg) {
    return (
      <div>
        <h3>Students</h3>
        <div style={{ color: "red" }}>
          Error: {errorMsg}
        </div>
      </div>
    );
  }

  // 3) Empty state
  if (students.length === 0) {
    return (
      <div>
        <h3>Students</h3>
        <div>No students found. Try adding a new student.</div>
      </div>
    );
  }

  // 4) Normal state (data loaded)
  return (
    <div>
      <h3>Students</h3>
      <ul>
        {students.map(s => (
          <li key={s.id}>
            {s.name} – {s.email}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

Key ideas:

* `loading` is `true` at the start and set to `false` after `try` finishes.
* `errorMsg` is blank on success, contains text if an error happens.
* If `students.length === 0`, show a friendly “no data” message.

You can replace the “Loading…” text with a spinner component from libraries (Material UI, Ant Design, etc.).

---

#### 4.3 Very Simple Spinner Example (no library)

```jsx
function SimpleSpinner() {
  return (
    <div style={{ padding: "8px" }}>
      <span role="img" aria-label="loading">⏳</span> Loading...
    </div>
  );
}
```

Then use:

```jsx
if (loading) {
  return (
    <div>
      <h3>Students</h3>
      <SimpleSpinner />
    </div>
  );
}
```

This is enough for many internal tools.

---

#### 4.4 NiceGUI Example – Loading, Error, Empty

```python
# nicegui_states_example.py
from nicegui import ui
import httpx
import asyncio

GRAPHQL_URL = 'http://localhost:4000/graphql'

STUDENTS_QUERY = """
query {
  students {
    id
    name
    email
  }
}
"""

async def fetch_students():
  async with httpx.AsyncClient() as client:
    response = await client.post(
      GRAPHQL_URL,
      json={'query': STUDENTS_QUERY},
      timeout=10.0,
    )
    data = response.json()
    if 'errors' in data:
      raise Exception(data['errors'][0]['message'])
    return data['data']['students'] or []

@ui.page('/')
async def main():
  ui.label('Students (GraphQL + NiceGUI)')

  status = ui.label('Loading students...')
  table = ui.table(
    columns=[
      {'name': 'id', 'label': 'ID', 'field': 'id'},
      {'name': 'name', 'label': 'Name', 'field': 'name'},
      {'name': 'email', 'label': 'Email', 'field': 'email'},
    ],
    rows=[],
  )

  try:
    students = await fetch_students()
    if not students:
      status.text = 'No students found. Please add some.'
    else:
      table.rows = students
      status.text = f'Loaded {len(students)} students.'
  except Exception as e:
    status.text = f'Error: {e}'

ui.run()
```

Here:

* At first: “Loading students…”
* On success with data: “Loaded N students.”
* On success with no data: “No students found.”
* On error: “Error: …”

---

### 5. Diagram – States for One Component

```text
Start
  |
  v
[loading = true]
  |
  |  call GraphQL
  v
+------------------------+
|        Result          |
+------------------------+
   |         |         |
   |         |         |
 Error     Empty     Data
   |         |         |
   v         v         v
Show      Show      Show
error     "no       table /
text      data"     list
          text
```

One API call → One of three visible states (error, empty, normal).
Loading is a temporary state before you decide which branch.

---

### 6. How to Instruct Codex to Automate This

You can let Codex upgrade your existing components.

1. **Improve an existing component with all three states**

   > “Improve this component by adding loading spinner, error message, and ‘no data’ message in simple, readable code.”

2. **Ask for very clear, beginner-friendly code**

   > “Take this React component that calls a GraphQL API and refactor it to use useState for loading, error, and data, with clear if-blocks for each state. Keep the code simple and easy to read.”

3. **NiceGUI version**

   > “Given this NiceGUI page that calls a GraphQL query, add a label for loading, and update it to show an error message if the request fails, or ‘No data found’ if the list is empty.”

4. **Refactor repeated state handling**

   > “Extract the repeated loading/error/empty state logic from these components into a helper function or custom hook, and update the components to use it.”

---

### 7. Summary

1. Every data-fetching UI should handle **loading**, **error**, and **empty** states clearly.
2. Use simple flags (`loading`, `errorMsg`, `items.length === 0`) and show the right message or spinner.
3. Codex can refactor your existing components to add these states and keep the code clean and readable.

