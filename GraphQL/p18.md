# Chapter 18. Avoiding Tight Coupling

### (Why you should **not** expose internal database details directly)

---

## 1. Simple Introduction

When you design a GraphQL API, it is tempting to expose your database tables directly:

* `users` table → `User` type
* `orders` table → `Order` type
* `payments` table → `Payment` type

But this creates a **tight coupling** between your API and your internal database structure.

Meaning:

* If your tables change → your API breaks
* If you rename a column → your frontend breaks
* If you restructure tables → clients need to update their code

A good API should hide internal details and expose only the **useful, stable shape** of data.

GraphQL should be a **clean storefront**, not a mirror of your warehouse shelves.

---

## 2. Why This Matters

Your backend will change over time:

* New tables
* Columns renamed
* Merged or split tables
* Internal refactoring

If your GraphQL schema exposes DB fields directly, every internal change becomes a **public breaking change**.

A loosely coupled schema:

* Remains stable over years
* Hides internal complexity
* Protects your frontend from backend redesign
* Lets backend devs refactor DB freely

Just like a restaurant menu:
You don’t expose the kitchen layout, only the dishes.

---

## 3. Real-Life Example Story

Imagine a hotel.

The hotel staff maintain:

* Internal files
* Cleaning schedules
* Staff assignments
* Supply management

Guests should **never** see those files.

Guests only need:

* Check-in info
* Room details
* Booking confirmation
* Bill summary

If you show your internal files directly to guests, changing anything internally will confuse them.

GraphQL should behave the same way:

* Frontend is the “guest.”
* Database is the “internal files.”
* GraphQL schema is the “reception counter.”

Only show what is meaningful.
Hide the messy backend.

---

## 4. Code Example — Fixing a Tightly Coupled Schema

### 4.1 A Bad Example (Too Tightly Coupled)

Below is a schema that exposes DB table columns directly:

```graphql
type User {
  user_id: Int!
  user_name: String!
  user_email: String!
  created_at: String!
  updated_at: String!
  is_deleted: Boolean!
}

type Order {
  order_id: Int!
  user_id: Int!
  order_total: Float!
  order_status: String!
  created_at: String!
  updated_at: String!
}
```

Problems:

1. Field names match DB column names.
2. `created_at`, `updated_at`, `is_deleted` are internal fields.
3. `user_id` is repeated everywhere.
4. No structure for higher-level data.
5. Hard to change database later.

---

## 4.2 Improved Schema (Loosely Coupled)

```graphql
type User {
  id: ID!
  name: String!
  email: String!
  orders: [Order!]!
}

type Order {
  id: ID!
  total: Float!
  status: String!
}
```

Changes:

* `user_id` → hidden internally
* `order_id` → now simply `id`
* Removed timestamps that frontend doesn’t need
* Removed internal delete flags
* Connected User → Orders using resolver logic, not DB keys
* Clean, human-friendly fields
* Backend can freely rename DB columns

---

## 4.3 Resolver Logic (Backend hides DB details)

```js
User: {
  orders: async (parent, args, context) => {
    return context.db.orders.findAll({
      where: { user_id: parent.id } // DB detail stays here
    });
  }
}
```

Frontend sees simple clean fields.
Backend handles the messy parts.

---

## 5. Simple Text Diagram

### Bad API (exposes database):

```
Frontend → GraphQL → shows database table directly → DB
```

### Good API (hides database):

```
Frontend → GraphQL → clean schema → resolvers → DB (internal)
```

GraphQL becomes a **protective layer**, not a mirror.

---

## 6. How to Instruct Codex to Automate This

Here are prompts students can paste into Codex.

---

### Prompt 1 — Suggest Improvements

> “Codex, suggest improvements to this GraphQL schema to make it less tightly coupled to the database structure. Explain each change and why it makes the API more stable.”

---

### Prompt 2 — Rename Fields to Human-Friendly Labels

> “Codex, rewrite this schema using generic field names (id, name, email) instead of database-like names (user_id, user_name). Explain why these changes reduce coupling.”

---

### Prompt 3 — Remove Internal Fields

> “Codex, modify this schema by removing fields like created_at, updated_at, deleted_flag, unless they are truly needed. Explain which fields should remain and why.”

---

### Prompt 4 — Add Higher-Level Fields

> “Codex, add new meaningful fields (like fullName, lastOrder, orderCount) that are useful for the frontend. Explain how these fields help hide database complexity.”

---

## 7. Summary

1. Avoid exposing database column names directly in your GraphQL types.
2. Keep the schema **clean, human-friendly, and stable**, regardless of backend redesign.
3. Hide DB details inside resolvers, not in the public API.

