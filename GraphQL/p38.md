# Chapter 38. Rate Limiting & API Keys (Simple)

### 1. Simple heading

**Rate Limiting & API Keys – Basic Protection for Your GraphQL API**

---

### 2. Short introduction

Even if your login and roles are perfect, someone can still:

* Call your API too many times
* Write a script that hammers your server
* Use your API from places you don’t trust

To reduce this risk, we add:

1. **Rate limiting** – “Only X requests per minute from this user/IP/key.”
2. **API keys** – “Only people with a valid key can use this API.”

Think of it like:

* **Rate limit** = “Only 1 plate per person in 10 minutes.”
* **API key** = “You must show this special membership card to enter.”

---

### 3. Use-case story

Imagine you built a **clinic GraphQL API**:

* Doctors use it from the clinic’s web app.
* You also allow a **third-party app** to fetch some public data (e.g., clinic information, list of departments).

If someone writes a bot to call your API 1000 times per second:

* Your server may slow down.
* Your database may get overloaded.
* Other real users may suffer.

So you decide:

* Every **API key** can call only, say, **60 requests per minute**.
* If they cross the limit, they get a **“Too many requests, please slow down”** error.

Rate limiting + API key = basic but powerful shield.

---

### 4. Code examples (small & clear)

We’ll use a **Node + Express + Apollo Server** style example.
Concept is the same in any stack: we add a **middleware** before GraphQL.

#### 4.1 Simple API key check in middleware

We will:

* Read an `x-api-key` header.
* Compare it to a list of allowed keys.
* If not valid → block the request.

```js
// apiKeyMiddleware.js
const VALID_KEYS = new Set([
  'CLINIC_WEB_APP_KEY_123',
  'MOBILE_APP_KEY_456',
]);

export function apiKeyMiddleware(req, res, next) {
  const apiKey = req.headers['x-api-key'];

  if (!apiKey || !VALID_KEYS.has(apiKey)) {
    return res.status(401).json({ error: 'Invalid or missing API key' });
  }

  // Attach key to request for later (useful for rate limiting)
  req.apiKey = apiKey;
  next();
}
```

Then in your server setup:

```js
import express from 'express';
import { apiKeyMiddleware } from './apiKeyMiddleware.js';
import { expressMiddleware } from '@apollo/server/express4';
import { server } from './apolloServer.js'; // your Apollo instance

const app = express();

app.use(express.json());

// API key check runs before GraphQL
app.use('/graphql', apiKeyMiddleware, expressMiddleware(server));

app.listen(4000, () => {
  console.log('Server running on http://localhost:4000/graphql');
});
```

Now any request **without** a valid `x-api-key` will be blocked.

---

#### 4.2 Very simple in-memory rate limiter (per API key)

We will:

* Keep a small in-memory map: `{ apiKey → { count, windowStart } }`.
* For each request:

  * If we are in the same time window (e.g., last 60 seconds), increase count.
  * If count > LIMIT → block.
  * If window has passed → reset count and windowStart.

> Note: This is **not production-grade** (it breaks if server restarts or you scale to multiple instances), but it’s easy to understand and good as a learning example.

```js
// rateLimitMiddleware.js

const WINDOW_MS = 60 * 1000;      // 60 seconds
const MAX_REQUESTS = 60;          // 60 requests per minute per API key
const buckets = new Map();        // key: apiKey, value: { count, windowStart }

export function rateLimitMiddleware(req, res, next) {
  const apiKey = req.apiKey; // set by apiKeyMiddleware

  // Just in case
  if (!apiKey) {
    return res.status(401).json({ error: 'Missing API key for rate limiting' });
  }

  const now = Date.now();
  let bucket = buckets.get(apiKey);

  if (!bucket) {
    // First request for this key
    bucket = { count: 1, windowStart: now };
    buckets.set(apiKey, bucket);
    return next();
  }

  // Check if current window is still valid
  if (now - bucket.windowStart < WINDOW_MS) {
    // Same window
    bucket.count += 1;
    if (bucket.count > MAX_REQUESTS) {
      return res.status(429).json({ error: 'Too many requests, please slow down.' });
    }
  } else {
    // New window
    bucket.count = 1;
    bucket.windowStart = now;
  }

  next();
}
```

Hook it into Express:

```js
import { apiKeyMiddleware } from './apiKeyMiddleware.js';
import { rateLimitMiddleware } from './rateLimitMiddleware.js';

app.use('/graphql',
  apiKeyMiddleware,
  rateLimitMiddleware,
  expressMiddleware(server)
);
```

Now:

* A client with one API key can make up to **60 GraphQL calls per minute**.
* If they go over, they get status **429** with a friendly message.

---

#### 4.3 GraphQL side – nothing changes in schema

Good news: your **GraphQL schema and resolvers stay the same**.

For example, your Query can be:

```graphql
type Query {
  patients: [Patient!]!
  me: User
}
```

Resolvers:

```js
export const resolvers = {
  Query: {
    patients: (_, __, { db }) => db.patient.findMany(),
    me: (_, __, { currentUser }) => currentUser,
  },
};
```

The **rate limiting** and **API key** logic stays in the **middleware layer**, not inside each resolver.
So your GraphQL code stays clean.

---

#### 4.4 REST vs GraphQL – same idea

**REST**:

* You might limit `GET /patients` to 60 calls per minute per API key.

**GraphQL**:

* You limit `/graphql` POST calls per API key in the same way.
* Inside the body, the client sends `query { patients { id name } }`, but middleware doesn’t care about the query text.
* It only counts total requests per key.

So the protection pattern is the same, only the endpoint is different.

---

### 5. Diagram

```text
Client (with x-api-key)
        |
        | HTTP request to /graphql
        v
[API Key Middleware]
   - Check x-api-key
   - If invalid → 401
        |
        v
[Rate Limit Middleware]
   - Track requests per API key
   - If over limit → 429
        |
        v
[GraphQL Server]
   - Run schema + resolvers
   - Return data
```

---

### 6. “How to instruct Codex” prompts

Here are copy-paste prompts for Codex.

1. **Basic rate limiting example (given in your hint)**

> “Show a simple example of adding rate limiting to a GraphQL server using middleware, explained step by step.”

2. **Combine API key + rate limiting**

> “Generate Express middleware for a GraphQL server that first checks a list of valid API keys from environment variables, and then applies per-key rate limiting with an in-memory store. Add clear error messages for invalid key and too many requests.”

3. **Make it stack-specific**

> “Using Apollo Server with Express, show how to wire apiKeyMiddleware and rateLimitMiddleware in front of the /graphql endpoint, with comments explaining each step for beginners.”

4. **Improve to production ideas (for later)**

> “Suggest how to move this simple in-memory rate limiter to a Redis-based shared store, and generate example code for Node.js. Explain what changes in a multi-instance deployment.”

---

### 7. Summary

1. **API keys** are like membership cards; only calls with a valid key can use your GraphQL API.
2. **Rate limiting** is like a speed limit; it stops any one client from sending too many requests in a short time.
3. Both are usually added as **middleware before GraphQL**, so your schema and resolvers stay clean while the API remains protected.

