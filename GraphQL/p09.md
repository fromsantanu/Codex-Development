# Chapter 9. Subscriptions — Real-Time Updates

---

## 1. Simple Heading

**Subscriptions – Getting Live Updates in GraphQL**

---

## 2. Short Introduction

So far we have:

* **Queries** → ask for data (read once).
* **Mutations** → change data (write).

Now we add:

* **Subscriptions** → get **live updates** when something changes.

A subscription is like saying:

> “Please tell me whenever a new message comes.”

The server then **pushes** new data to you automatically.

---

## 3. Use-Case Story – Chat Room or Live Score

Think of a **chat app**:

* You open a chat room.
* You want to see new messages as soon as they are sent, without refreshing.

Or a **cricket live score** app:

* You want the score to update as soon as a run or wicket happens.

In both cases, you do not want to call the server again and again.
Instead, you say:

> “Subscribe me to new messages / new score updates.”

This is exactly what **GraphQL Subscriptions** do.

---

## 4. Code Examples

We’ll use a **chat app** as our main example.

### 4.1 Message Type

First, define a simple `Message` type:

```graphql
# A chat message
type Message {
  id: ID!
  text: String!
  sender: String!   # e.g., user name
  createdAt: String! # ISO date-time as string
}
```

### 4.2 Subscription Type: onNewMessage

Now we define a **subscription** that sends new messages:

```graphql
type Subscription {
  # This subscription is triggered whenever a new message is sent
  onNewMessage: Message!
}
```

So our schema will now have:

```graphql
type Query {
  # For example: get past messages
  messages: [Message!]!
}

type Mutation {
  # For example: send a new message
  sendMessage(text: String!, sender: String!): Message!
}

type Subscription {
  onNewMessage: Message!
}
```

* `Query` → read messages history
* `Mutation` → send a message
* `Subscription` → get notified when a new message is created

---

### 4.3 Sample Subscription Query (Client Side)

This is what the **client** (e.g., web app) sends to start listening:

```graphql
subscription {
  onNewMessage {
    id
    text
    sender
    createdAt
  }
}
```

After this subscription starts:

* The server will **push** a `Message` object every time a new message arrives.
* The client can show it in the chat window immediately.

---

### 4.4 Sample Chat Flow

1. User opens chat page.
2. Client starts subscription:

```graphql
subscription {
  onNewMessage {
    id
    text
    sender
  }
}
```

3. Another user sends a message using:

```graphql
mutation {
  sendMessage(text: "Hello everyone!", sender: "Amit") {
    id
    text
    sender
  }
}
```

4. The server:

* Saves the message in DB.
* Triggers `onNewMessage` for all subscribed clients.
* All open clients instantly receive:

```json
{
  "data": {
    "onNewMessage": {
      "id": "msg_101",
      "text": "Hello everyone!",
      "sender": "Amit"
    }
  }
}
```

5. Each client app adds the new message to the message list.

No refresh. No polling. **Real-time**.

---

### 4.5 Simple Resolver / Server Sketch (Conceptual)

This is not full code, just a **rough idea**.

In many GraphQL servers (e.g., with Node.js + Apollo), you have a **PubSub** or event system.

```js
const { PubSub } = require('graphql-subscriptions');
const pubsub = new PubSub();

const resolvers = {
  Query: {
    messages: (_, __, ctx) => ctx.db.getAllMessages(),
  },

  Mutation: {
    sendMessage: async (_, { text, sender }, ctx) => {
      const message = await ctx.db.createMessage({ text, sender });
      // Notify all subscribers
      pubsub.publish('NEW_MESSAGE', { onNewMessage: message });
      return message;
    },
  },

  Subscription: {
    onNewMessage: {
      subscribe: () => pubsub.asyncIterator('NEW_MESSAGE'),
    },
  },
};
```

* `sendMessage` mutation publishes event `NEW_MESSAGE`.
* `onNewMessage` subscription listens to `NEW_MESSAGE`.
* All subscribed clients get the new message.

Under the hood, this usually uses **WebSockets** (persistent connection).

---

## 5. Simple Diagram

```text
User A (sender)      User B (listener)      User C (listener)
      |                      |                      |
      |  sendMessage()       |                      |
      |  (mutation)          |                      |
      v                      |                      |
  GraphQL Server (with PubSub + WebSockets)         |
      |                      ^                      ^
      |-- push onNewMessage ->|----------------------|
      |-- push onNewMessage ------------------------>|
      |
   Database
```

* User A sends a mutation to create a new message.
* Server saves it and **pushes onNewMessage** to all subscribed users (B, C, etc.).

---

## 6. “How to Instruct Codex” Prompts

Here are some ready prompts you can give to Codex.

### 6.1 Basic subscription example (as requested)

> “Show a simple GraphQL subscription example for ‘onNewMessage’ in a chat app, with schema and a sample client query. Include:
>
> * Message type
> * Query for messages
> * Mutation for sendMessage
> * Subscription onNewMessage
>   Use clear comments in plain English.”

### 6.2 Full server + client sketch

> “Generate a simple Node.js (Apollo Server) example that implements a GraphQL chat subscription called onNewMessage. Include:
>
> * GraphQL schema (Message, Query, Mutation, Subscription)
> * Resolvers using PubSub
> * A sample subscription query that a client would run.”

### 6.3 Turn REST polling into GraphQL subscription

> “I currently have a REST API for chat where the frontend polls /messages every 2 seconds. Suggest how to replace this with a GraphQL subscription onNewMessage. Show the schema, the subscription query, and a short explanation in simple language.”

### 6.4 Use for live scores

> “Using the same pattern as a chat onNewMessage subscription, create a GraphQL schema snippet for a liveCricketScore subscription. The score type should include runs, wickets, overs, and battingTeam. Show a sample client subscription query as well.”

---

## 7. Summary

1. **Subscriptions** in GraphQL give **real-time updates**, like chat messages or live scores.
2. A subscription such as `onNewMessage` lets the server **push new data** to all subscribed clients whenever a new message is created.
3. Codex can generate full examples (schema, resolvers, client queries) to help you build and understand real-time GraphQL features quickly.

