# 21. Writing Queries in UI Components

### (Embedding Queries as Strings or Using Hooks)

---

### 1. Short Introduction

When you build a frontend that talks to a GraphQL server, you must place your **query strings** somewhere in your React code.

There are two common ways:

1. **Keep the GraphQL query inside the component as a string**
2. **Move the GraphQL query out into a separate variable or hook** (cleaner and easier to maintain)

Both methods work fine.
But as your app grows, keeping everything inside the UI component becomes messy.

This chapter shows how to structure your queries cleanly, so your UI code stays simple and readable.

---

### 2. Why This Matters

When your project becomes bigger:

* You will have many GraphQL queries and mutations.
* If you keep all queries inside UI components, the component becomes long and confusing.
* Moving queries to **separate variables**, **separate files**, or **custom hooks** keeps your UI clean.

Think of it like a school record room:

* If all files are thrown into one shelf, it becomes hard to find what you need.
* If files are kept in clearly labeled folders, everything becomes easier.

Same rule applies to your UI components and queries.

---

### 3. Use-Case Story – Student Dashboard

Imagine a **college dashboard** again.

* You have one React component: `StudentList.jsx`
* The backend exposes this query:

```graphql
query {
  students {
    id
    name
    email
  }
}
```

If you put the entire query inside the component:

* The component becomes long.
* Your team may need to reuse this query later.
* It’s hard to test.

Instead:

* Keep UI code in the component.
* Move query string into a separate constant or custom hook.

---

### 4. Code Examples

#### 4.1 Method 1 — Query embedded inside the component (works, but messy)

```jsx
import React, { useEffect, useState } from "react";

const GRAPHQL_URL = "http://localhost:4000/graphql";

export default function StudentList() {
  const [students, setStudents] = useState([]);

  // Query is inside component
  const query = `
    query {
      students {
        id
        name
        email
      }
    }
  `;

  useEffect(() => {
    async function load() {
      const res = await fetch(GRAPHQL_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query }),
      });
      const result = await res.json();
      setStudents(result.data.students);
    }
    load();
  }, []);

  return (
    <div>
      <h3>Student List</h3>
      {students.map((s) => (
        <div key={s.id}>{s.name} – {s.email}</div>
      ))}
    </div>
  );
}
```

This is fine for small projects.
But for larger apps, this will get messy very quickly.

---

#### 4.2 Method 2 — Move the query string to a separate variable

```jsx
// queries/studentQueries.js
export const STUDENT_LIST_QUERY = `
  query {
    students {
      id
      name
      email
    }
  }
`;
```

Now use it inside the component:

```jsx
// StudentList.jsx
import React, { useEffect, useState } from "react";
import { STUDENT_LIST_QUERY } from "./queries/studentQueries";

const GRAPHQL_URL = "http://localhost:4000/graphql";

export default function StudentList() {
  const [students, setStudents] = useState([]);

  useEffect(() => {
    async function load() {
      const res = await fetch(GRAPHQL_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query: STUDENT_LIST_QUERY }),
      });
      const result = await res.json();
      setStudents(result.data.students);
    }
    load();
  }, []);

  return (
    <div>
      <h3>Student List</h3>
      {students.map((s) => (
        <div key={s.id}>{s.name} – {s.email}</div>
      ))}
    </div>
  );
}
```

Benefits:

* Queries live in one place.
* Components become smaller.
* Easier to reuse.

---

#### 4.3 Method 3 — Using a custom hook

You can create a hook that returns the data, loading state, and errors.

```jsx
// hooks/useStudents.js
import { useEffect, useState } from "react";
import { STUDENT_LIST_QUERY } from "../queries/studentQueries";

const GRAPHQL_URL = "http://localhost:4000/graphql";

export function useStudents() {
  const [students, setStudents] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function load() {
      setLoading(true);

      const res = await fetch(GRAPHQL_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query: STUDENT_LIST_QUERY }),
      });

      const result = await res.json();
      setStudents(result.data.students);
      setLoading(false);
    }

    load();
  }, []);

  return { students, loading };
}
```

Using it in UI:

```jsx
// StudentList.jsx
import React from "react";
import { useStudents } from "./hooks/useStudents";

export default function StudentList() {
  const { students, loading } = useStudents();

  if (loading) return <div>Loading...</div>;

  return (
    <div>
      <h3>Student List (using hook)</h3>
      {students.map((s) => (
        <div key={s.id}>{s.name} – {s.email}</div>
      ))}
    </div>
  );
}
```

This is clean and easy to maintain.

---

### 5. Diagram – Organizing Queries

```text
React App
   |
   |-- UI Components (StudentList.jsx)
   |
   |-- hooks/
   |       |-- useStudents.js
   |
   |-- queries/
           |-- studentQueries.js
```

Benefits:

* UI components stay focused on presentation.
* Hooks handle data fetching.
* Query strings are reusable.

---

### 6. How to Instruct Codex to Automate This

Use these prompts with Codex when refactoring or building UI code:

1. **Move query string to separate variable**

   > “Refactor this React component to move the GraphQL query into a separate variable and keep the code clean.”

2. **Move queries to a separate file**

   > “Extract the GraphQL query from this component and place it in a new file called studentQueries.js, then update the import.”

3. **Create a custom hook**

   > “Create a React hook called useStudents that runs the students GraphQL query using fetch and returns { students, loading, error }.”

4. **Refactor messy code**

   > “Refactor this React component by separating UI logic and GraphQL fetch logic into different files.”

---

### 7. Summary

1. You can embed GraphQL queries inside components, but it becomes messy when the project grows.
2. A cleaner way is to move queries into **separate variables**, **separate files**, or **custom hooks**.
3. This keeps UI components small, readable, and easy to maintain.

