````md
# Chapter 11. Writing a Schema File

---

## 1. Introduction

In GraphQL, the **schema** is the official **menu card**.  
It clearly tells:

- What data types exist (Student, Course, etc.)
- What fields they have (name, email, title, credits, etc.)
- What queries and mutations are allowed

There are two common ways to write this menu:

1. **SDL (Schema Definition Language)** – usually in a `.graphql` file  
2. **Code-first** – you write schema using code (JavaScript / Python classes)

We will focus mainly on **SDL** because it is easier to read and share.

---

## 2. Why This Matters

- The schema is the **contract** between frontend and backend.
- All teams (UI, backend, mobile) can open the schema and know:
  - What can we ask?
  - What data will we get?
- A clean schema file makes it easy to:
  - Evolve your system
  - Add new fields
  - Avoid confusion and bugs

Think of it like a **printed menu** in a restaurant:  
everyone knows what dishes exist and what is inside each dish.

---

## 3. Real-Life Example: College System

Imagine a simple college system with:

- **Student**
  - id
  - name
  - email
- **Course**
  - id
  - title
  - credits

Relationships:

- A student can join many courses.
- A course can have many students.

In real life:

- A **student** is like a customer.
- A **course** is like a product.
- The schema is the **catalog** that describes both.

---

## 4. Code Examples

We’ll see:

1. SDL schema file: `schema.graphql`
2. Code-first example (just a taste)
3. Connecting the schema file to the server (high level)

---

### 4.1 SDL Schema File (schema.graphql)

This is the text file you might keep at `./schema.graphql`.

```graphql
# schema.graphql

# Basic types
type Student {
  id: ID!
  name: String!
  email: String!
  courses: [Course!]!
}

type Course {
  id: ID!
  title: String!
  credits: Int!
  students: [Student!]!
}

# Entry points
type Query {
  # Get one student by ID
  student(id: ID!): Student

  # Get all students
  students: [Student!]!

  # Get one course by ID
  course(id: ID!): Course

  # Get all courses
  courses: [Course!]!
}

# For changes (create/update/delete)
type Mutation {
  addStudent(name: String!, email: String!): Student!
  addCourse(title: String!, credits: Int!): Course!
}
````

Key ideas:

* **Types**: `Student`, `Course`
* **Fields**: each type has fields like `name`, `title`, etc.
* **Relations**: `Student.courses` and `Course.students` link both sides.
* **Query type**: how clients read data.
* **Mutation type**: how clients change data.

---

### 4.2 Code-First Example (Node + Apollo, brief)

Just to show how it looks if you write schema in code instead of in a `.graphql` file.

```js
// schema.js (code-first style example)

const typeDefs = `#graphql
  type Student {
    id: ID!
    name: String!
    email: String!
    courses: [Course!]!
  }

  type Course {
    id: ID!
    title: String!
    credits: Int!
    students: [Student!]!
  }

  type Query {
    student(id: ID!): Student
    students: [Student!]!
    course(id: ID!): Course
    courses: [Course!]!
  }

  type Mutation {
    addStudent(name: String!, email: String!): Student!
    addCourse(title: String!, credits: Int!): Course!
  }
`;

module.exports = { typeDefs };
```

Here the schema is written **inside JavaScript**, but it’s still **SDL**.
Some libraries also let you describe types using classes or decorators,
but the basic idea is the same: define types, fields, and operations.

---

### 4.3 REST vs GraphQL View

**REST version (for same system) might be:**

```http
GET /students
GET /students/123
GET /students/123/courses

GET /courses
GET /courses/456
GET /courses/456/students
```

**GraphQL version (single endpoint /graphql):**

```graphql
query {
  student(id: "123") {
    name
    email
    courses {
      title
      credits
    }
  }
}
```

The schema file tells GraphQL what `student` and `course` mean
and which fields are allowed in these queries.

---

## 5. Simple Diagram

A small diagram to show where the schema file fits.

```text
          +------------------------+
          |     schema.graphql     |
          |  (types, queries, etc) |
          +-----------+------------+
                      |
                      v
            GraphQL Server (Apollo / Python)
                      |
                      v
           Resolvers → Database / Services
```

* The **schema file** defines the structure.
* The **server** uses the schema to understand queries.
* **Resolvers** supply the actual data.

---

## 6. How to Instruct Codex

You can ask Codex to generate schema files directly from a high-level description.

### Example Prompt 1

```text
Codex, given this high-level description of entities:

- Student: id, name, email, list of courses
- Course: id, title, credits, list of students

Generate a schema.graphql file in SDL format. 
Include Query type to get one and many students/courses, 
and simple Mutation type to add a student and add a course.
```

### Example Prompt 2

```text
Codex, create a GraphQL SDL schema for a student-course system.

Types:
- Student(id: ID!, name: String!, email: String!, courses: [Course!]!)
- Course(id: ID!, title: String!, credits: Int!, students: [Student!]!)

Add:
- Query: students, student(id), courses, course(id)
- Mutations: addStudent, addCourse

Return only the schema.graphql content.
```

### Example Prompt 3 (REST → GraphQL)

```text
Codex, I currently have REST endpoints:
/students, /students/{id}, /courses, /courses/{id}

Please suggest a GraphQL schema.graphql file in SDL that covers these 
operations for Student and Course, including basic fields and relations.
```

---

## 7. Summary

1. The **schema file** (`schema.graphql`) is the **official menu card** of your GraphQL API.
2. You can write schemas in **SDL** files or in **code-first** style, but the ideas are the same: types, fields, queries, mutations.
3. Codex can generate or improve your schema file from a simple, high-level description of your entities and relationships.

---

```
```

