# Chapter 27. Centralizing API Calls in Frontend

---

### 1. Simple introduction

In many React apps, we start by **calling GraphQL directly inside components** using `useQuery` and `useMutation`.

After some time:

* The same query is copied in many places.
* The same loading/error logic is repeated.
* It becomes hard to change one API call without touching many files.

A better way is to **centralize API calls** in:

* **Reusable hooks** (like `useStudents()`),
* or **service files** (like `studentService.ts`).

Then your UI components become **simpler**: they just call the hook and show the data.

---

### 2. Why this matters

Centralizing API calls helps you:

* **Avoid duplicate code** – one place for each query/mutation.
* **Keep components clean** – they focus on layout and rendering.
* **Change behavior in one place** – e.g., add logging, extra headers, or new fields.
* **Test more easily** – hooks/services can be tested without the whole UI.

For example:

* Without centralization: 5 components each use `useQuery(GET_STUDENTS)` with slightly different logic.
* With centralization: all 5 components call `useStudents()`.

If you later change the query (e.g., add `age`), you change it in **one** place.

---

### 3. Real-life example (school app story)

Imagine a **school management app**:

* Many pages need **students list**:

  * Dashboard (show top 5 students)
  * Admin page (show all students)
  * Class page (show students of one class)

If every page writes this:

```js
const { data, loading, error } = useQuery(GET_STUDENTS);
```

with its own copy of `GET_STUDENTS`, the code becomes messy.

Instead, you can create:

* `useStudents()` – to fetch list of students.
* `useCreateStudent()` – to create a new student and update cache.

Now, all components reuse these hooks.

---

### 4. Code examples

We’ll use a **Student** example.

#### 4.1 GraphQL queries and mutations

**`src/graphql/studentQueries.js`**

```js
import { gql } from '@apollo/client';

export const GET_STUDENTS = gql`
  query GetStudents {
    students {
      id
      name
      email
    }
  }
`;

export const CREATE_STUDENT = gql`
  mutation CreateStudent($input: CreateStudentInput!) {
    createStudent(input: $input) {
      id
      name
      email
    }
  }
`;
```

---

#### 4.2 Naive approach (repeating in components)

Example: **DashboardStudents.jsx**

```jsx
import { useQuery } from '@apollo/client';
import { GET_STUDENTS } from '../graphql/studentQueries';

export function DashboardStudents() {
  const { data, loading, error } = useQuery(GET_STUDENTS);

  if (loading) return <p>Loading students...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <ul>
      {data.students.map((s) => (
        <li key={s.id}>{s.name}</li>
      ))}
    </ul>
  );
}
```

Example: **AdminStudentsPage.jsx** (similar code again)

```jsx
import { useQuery } from '@apollo/client';
import { GET_STUDENTS } from '../graphql/studentQueries';

export function AdminStudentsPage() {
  const { data, loading, error } = useQuery(GET_STUDENTS);

  if (loading) return <p>Loading students...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <table>
      <thead>
        <tr>
          <th>Name</th><th>Email</th>
        </tr>
      </thead>
      <tbody>
        {data.students.map((s) => (
          <tr key={s.id}>
            <td>{s.name}</td>
            <td>{s.email}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

Here, the **query and basic states** are repeated.

---

#### 4.3 Centralized reusable hooks

We create hooks that wrap Apollo’s `useQuery` and `useMutation`.

**`src/hooks/useStudents.js`**

```js
import { useQuery, useMutation } from '@apollo/client';
import { GET_STUDENTS, CREATE_STUDENT } from '../graphql/studentQueries';

export function useStudents() {
  const { data, loading, error, refetch } = useQuery(GET_STUDENTS);

  return {
    students: data?.students ?? [],
    loading,
    error,
    refetch,
  };
}

export function useCreateStudent() {
  const [createStudentMutation, { loading, error }] = useMutation(CREATE_STUDENT, {
    // Optional: update cache here if you want
    update(cache, { data }) {
      const newStudent = data?.createStudent;
      if (!newStudent) return;

      const existing = cache.readQuery({ query: GET_STUDENTS });
      const existingStudents = existing?.students ?? [];

      cache.writeQuery({
        query: GET_STUDENTS,
        data: {
          students: [...existingStudents, newStudent],
        },
      });
    },
  });

  async function createStudent(input) {
    const result = await createStudentMutation({ variables: { input } });
    return result.data?.createStudent;
  }

  return {
    createStudent,
    loading,
    error,
  };
}
```

Now the **hook file**:

* Knows about `GET_STUDENTS` and `CREATE_STUDENT`.
* Handles cache updates.
* Returns clean data and helper functions.

---

#### 4.4 Components using the hooks

**Dashboard using `useStudents()`**

```jsx
// src/components/DashboardStudents.jsx
import React from 'react';
import { useStudents } from '../hooks/useStudents';

export function DashboardStudents() {
  const { students, loading, error } = useStudents();

  if (loading) return <p>Loading students...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <ul>
      {students.map((s) => (
        <li key={s.id}>{s.name}</li>
      ))}
    </ul>
  );
}
```

**Admin page using the same hook**

```jsx
// src/pages/AdminStudentsPage.jsx
import React from 'react';
import { useStudents } from '../hooks/useStudents';

export function AdminStudentsPage() {
  const { students, loading, error } = useStudents();

  if (loading) return <p>Loading students...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <h2>All Students</h2>
      <table>
        <thead>
          <tr>
            <th>Name</th><th>Email</th>
          </tr>
        </thead>
        <tbody>
          {students.map((s) => (
            <tr key={s.id}>
              <td>{s.name}</td>
              <td>{s.email}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

**Create student form using `useCreateStudent()`**

```jsx
// src/components/CreateStudentForm.jsx
import React, { useState } from 'react';
import { useCreateStudent } from '../hooks/useStudents';

export function CreateStudentForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  const { createStudent, loading, error } = useCreateStudent();

  async function handleSubmit(e) {
    e.preventDefault();
    await createStudent({ name, email });
    setName('');
    setEmail('');
  }

  return (
    <form onSubmit={handleSubmit}>
      <h3>Create New Student</h3>

      <div>
        <label>
          Name:{' '}
          <input
            value={name}
            onChange={(e) => setName(e.target.value)}
            required
          />
        </label>
      </div>

      <div>
        <label>
          Email:{' '}
          <input
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </label>
      </div>

      <button type="submit" disabled={loading}>
        {loading ? 'Creating...' : 'Create Student'}
      </button>

      {error && <p>Error: {error.message}</p>}
    </form>
  );
}
```

Now components are:

* Small.
* Focused on **UI and layout**, not API details.

---

#### 4.5 REST vs GraphQL angle here

This pattern (centralizing API calls) is useful for **both** REST and GraphQL.

* With REST, you might create hooks like `useFetchStudents()` that call `/api/students`.
* With GraphQL, you create hooks like `useStudents()` that call the GraphQL endpoint with `GET_STUDENTS`.

Example comparison:

**REST-style hook:**

```js
async function fetchStudents() {
  const res = await fetch('/api/students');
  return res.json();
}
```

**GraphQL-style hook with Apollo:**

```js
export function useStudents() {
  const { data, loading, error } = useQuery(GET_STUDENTS);
  return { students: data?.students ?? [], loading, error };
}
```

The **idea is the same**:
keep API logic inside **hooks/services**, not scattered in components.

---

### 5. Simple diagram

```text
[ Components ]  -->  useStudents(), useCreateStudent()
     |                             ^
     |                             |
     v                             |
[ Hooks Layer ]  -------------------
     |
     |  useQuery(GET_STUDENTS)
     |  useMutation(CREATE_STUDENT)
     v
[ Apollo Client ]  <-->  [ GraphQL Server ]
```

The **hooks layer** is your “API service” for the frontend.

---

### 6. How to instruct Codex to automate this

Here are ready prompts you can copy-paste for Codex.

1. **Main prompt (as you requested)**

> “Refactor these repeated GraphQL calls into reusable React hooks like useStudents() and useCreateStudent().
> Move all Apollo useQuery and useMutation logic into a hooks file.
> Make the hooks return clean data, loading, error, and helper functions like createStudent().”

2. **Prompt to add cache update logic into hooks**

> “Update the useCreateStudent() hook so that after the createStudent mutation, it updates the Apollo cache for the GET_STUDENTS query and adds the new student to the list.
> Add clear comments explaining what the cache update is doing.”

3. **Prompt to organize folder structure**

> “Suggest a simple folder structure for a React + Apollo Client project where all GraphQL queries and reusable hooks are centralized.
> Show an example tree with folders: graphql/, hooks/, components/, pages/, and update imports accordingly.”

4. **Prompt to add TypeScript typing (optional)**

> “Convert these React hooks useStudents() and useCreateStudent() to TypeScript.
> Add types for Student, CreateStudentInput, and the hook return values.
> Keep the code simple and easy to read.”

5. **Prompt to add tests (optional)**

> “Generate Jest tests for the useStudents() hook using @testing-library/react-hooks and a mocked Apollo Client.
> Test loading, success, and error states.”

---

### 7. Summary

1. Centralizing API calls into **reusable hooks/services** keeps your components clean and avoids repeating GraphQL logic everywhere.
2. Hooks like `useStudents()` and `useCreateStudent()` can wrap Apollo’s `useQuery`/`useMutation`, handle cache updates, and expose a simple interface to the UI.
3. Codex can help you **refactor** existing scattered calls into a proper hooks layer, suggest folder structures, add TypeScript types, and even generate tests for your hooks.

