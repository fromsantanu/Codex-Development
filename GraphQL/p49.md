# 49. SSL, Domain & Environment Variables (.env Usage)

---

### 1. Introduction

In this chapter, we learn three important things:

* **Domain Name** → a simple, human-friendly address for your API
* **SSL / HTTPS** → makes data between client and server safe
* **Environment Variables** → a clean place to store secrets like DB URLs, API keys, and passwords

Think of it like setting up a shop:

* Domain is the **nameboard** outside your store.
* SSL is the **security guard** checking that nobody steals data.
* Environment variables are the **locker** where you keep keys and money — not on the shop counter.

We will keep the steps simple and practical.

---

### 2. Why This Matters

Every real project needs:

* A clean domain name such as:
  `https://api.myapp.com/graphql`
* HTTPS so browsers trust your app.
* Secrets stored safely outside code — no DB passwords inside GitHub.

If you follow this chapter, your GraphQL app becomes **production-ready**.

---

### 3. Real-life Example

Imagine a **clinic GraphQL system**:

* DB URL: `postgres://user:pass@db-server:5432/clinicdb`
* JWT secret: `super-secret-key`
* Domain: `api.clinic-care.in`

If you hardcode these into code:

```js
const DB_URL = "postgres://user:pass@db-server:5432/clinicdb";
```

anyone reading your repo knows your password.

Instead, you keep them in a hidden file `.env` and load them from variables.

Then the same server becomes safe and easy to deploy anywhere.

---

### 4. Code Examples

We’ll assume a Node + Apollo GraphQL setup, but the idea is same for Python or Go.

---

#### 4.1 Installing dotenv

```bash
npm install dotenv
```

---

#### 4.2 Using environment variables inside your server

```js
// src/config.js
import dotenv from "dotenv";
dotenv.config();

export default {
  port: process.env.PORT || 4000,
  dbUrl: process.env.DB_URL,
  jwtSecret: process.process.env.JWT_SECRET,
  nodeEnv: process.env.NODE_ENV || "development"
};
```

---

#### 4.3 Using the config in index.js

```js
import config from "./config.js";

const start = async () => {
  const { url } = await startStandaloneServer(server, {
    listen: { port: config.port }
  });

  console.log(`GraphQL running at ${url}`);
  console.log(`Connected to DB: ${config.dbUrl}`);
};
```

---

#### 4.4 Sample `.env` file

(This file **must not be pushed to GitHub**.)

```
PORT=4000
DB_URL=postgres://clinic_user:clinic_pass@localhost:5432/clinicdb
JWT_SECRET=mytopsecretkey123
NODE_ENV=production
```

---

#### 4.5 Using environment variables in Docker

Add this to your `docker-compose.yml`:

```yaml
services:
  graphql:
    build: .
    env_file:
      - .env
    ports:
      - "4000:4000"
```

Now your container automatically receives all the secrets.

---

#### 4.6 Domain + DNS Setup (simple explanation)

After buying a domain:

1. Go to domain provider (Namecheap, GoDaddy, etc.).
2. Add an **A Record**:

```
Type: A  
Name: api  
Value: <your VPS public IP>
TTL: Auto
```

Now visiting `api.yourdomain.com` points to your VPS.

---

#### 4.7 Enabling SSL with Certbot (Let’s Encrypt)

Install Certbot:

```bash
sudo apt install certbot python3-certbot-nginx -y
```

Run:

```bash
sudo certbot --nginx -d api.yourdomain.com
```

Certbot will:

* Detect Nginx
* Add HTTPS settings
* Install certificates
* Setup auto-renew

A simple HTTPS Nginx config looks like this:

```nginx
server {
    listen 443 ssl;
    server_name api.yourdomain.com;

    ssl_certificate /etc/letsencrypt/live/api.yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/api.yourdomain.com/privkey.pem;

    location /graphql {
        proxy_pass http://127.0.0.1:4000/graphql;
        proxy_set_header Host $host;
    }
}
```

---

### 5. Text Diagram

```
Browser → https://api.myapp.com/graphql
      ↓ SSL protects data
   Nginx (SSL termination)
      ↓ forwards internally
GraphQL Server (Docker)
      ↓
  Database / Microservices
```

And secrets flow safely like this:

```
.env file → docker-compose.yml → environment variables → GraphQL server config
```

---

### 6. How to Instruct Codex

You can ask Codex to do all heavy lifting for you.

Here are simple prompts:

---

#### Prompt 1 — Move secrets to environment variables

> “Refactor my GraphQL config to read `PORT`, `DB_URL`, and `JWT_SECRET` from environment variables using dotenv. Provide updated config.js and a sample .env file.”

---

#### Prompt 2 — Add `.env` support into Docker

> “Modify my Dockerfile and docker-compose.yml so the GraphQL server loads environment variables from .env. Add comments explaining each step.”

---

#### Prompt 3 — Generate a full SSL setup guide

> “Write a very simple guide to enable SSL on my Nginx server using Let’s Encrypt and Certbot. The domain is api.myapp.com. Keep instructions beginner-friendly.”

---

#### Prompt 4 — Domain + DNS tutorial

> “Explain how to point api.myapp.com to my VPS using DNS A records, and show how to test if DNS is working.”

---

### 7. Summary

* A **domain** makes your API easy to access.
* **SSL** protects all traffic and builds trust.
* **Environment variables** keep secrets safe and separate from code.
* `.env` + Docker + Nginx + Certbot = a clean, production-ready setup.

With these steps, your GraphQL server becomes secure, professional, and ready for real users.

