# 47. Logging & Tracing

**See Which GraphQL Queries Are Expensive**

---

### 1. Introduction

When you run a GraphQL server, different queries take different amounts of time.
Some are fast (simple lookups), and some are slow (heavy joins, external API calls).

Logging and tracing help you:

* Know **which query was run**
* Know **how long it took**
* Spot slow or expensive operations early
* Improve performance before customers complain

We will add simple timing logs around each GraphQL request.

---

### 2. Why this matters

Without logs, you are **guessing** why your API feels slow.

With logs:

* You can see slow queries immediately.
* You can fix bad resolvers or slow DB queries.
* You have real numbers instead of assumptions.
* You can scale your system better.

For microservices, logs become even more important because different services may slow down your main GraphQL server. Good tracing helps you see the whole picture.

---

### 3. Real-life example

Think of a hospital:

* A doctor wants to know which patients take **longer time** to check.
* The hospital records how long each appointment takes.
* If one patient always takes 45 minutes, the doctor schedules extra time for that case.

Logging does the same for GraphQL:

* We measure how long each query took.
* If something is unusually slow, we know **which part needs attention**.

---

### 4. Code Examples (Very Simple)

Below are examples in Node (Apollo) and Python (Ariadne).
Both follow the same idea:

**Start timer → run query → end timer → log result**

---

### 4.1. Node.js — Apollo Server Logging

```javascript
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import express from 'express';

const server = new ApolloServer({
  typeDefs,
  resolvers,
  plugins: [
    {
      async requestDidStart() {
        const requestStartTime = Date.now();

        return {
          async willSendResponse(requestContext) {
            const requestEndTime = Date.now();
            const requestDurationMs = requestEndTime - requestStartTime;

            const queryName = requestContext.operationName || "UnnamedQuery";

            console.log(`[LOG] Query: ${queryName} took ${requestDurationMs} ms`);
          }
        };
      }
    }
  ]
});

await server.start();

const app = express();
app.use('/graphql', expressMiddleware(server));

app.listen(4000, () => {
  console.log("Running at http://localhost:4000/graphql");
});
```

Key ideas:

* `operationName` gives query/mutation name
* `Date.now()` gives milliseconds
* Logs print after request finishes

---

### 4.2. Python — Ariadne ASGI Logging

```python
import time
from ariadne import QueryType, make_executable_schema
from ariadne.asgi import GraphQL

type_defs = """
    type Query {
        hello: String!
    }
"""

query = QueryType()

@query.field("hello")
def resolve_hello(_, info):
    return "Hello"

schema = make_executable_schema(type_defs, query)

async def logging_middleware(request, next_handler):
    start_time = time.time()

    response = await next_handler(request)

    end_time = time.time()
    duration_ms = (end_time - start_time) * 1000

    operation_name = request.json.get("operationName", "UnnamedQuery")

    print(f"[LOG] Query: {operation_name} took {duration_ms:.2f} ms")

    return response

app = GraphQL(
    schema,
    middlewares=[logging_middleware],
    debug=True
)
```

Key ideas:

* Wrap the GraphQL request inside a timer
* Use the request body to find the operation name
* Print duration in milliseconds

---

### 5. Simple Diagram

```
Incoming Query
      ↓
Start timer (T1)
      ↓
Run all resolvers
      ↓
End timer (T2)
      ↓
Calculate duration (T2 - T1)
      ↓
Log query name + duration
```

This helps you quickly spot slow queries.

---

### 6. How to Instruct Codex

Here are ready-made prompts:

1. **Add simple logging**

   > “Add simple logging for every GraphQL request and its duration in this server code. Use very clear variable names.”

2. **Add resolver-level timing**

   > “Wrap each resolver in timing logs so I can see which resolver is slow. Use readable comments.”

3. **Add logging to existing project**

   > “Insert performance logs into my GraphQL server. Keep it simple: timestamp, query name, and duration.”

4. **Create README section**

   > “Generate a short README section explaining how logging and tracing work in this GraphQL server.”

---

### 7. Summary

* Logging helps you see which GraphQL queries are slow.
* You measure start time and end time to find duration.
* Tools like Apollo Server and Ariadne make this very easy.
* With good tracing, backend performance becomes predictable and easier to improve.

