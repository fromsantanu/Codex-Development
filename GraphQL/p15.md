# Chapter 15. One GraphQL API Talking to Many Services (Gateway Pattern)

---

## 1. Simple Introduction

In real projects, your data rarely lives in one place.
You may have:

* A **Customer service** (REST API)
* An **Order service** (REST API)
* Maybe later, a **Payment service**, **Inventory service**, etc.

GraphQL can sit in front of all of them like a **smart receptionist**.

* The client calls **one** GraphQL endpoint.
* The GraphQL server then calls **many** backend services.
* It combines the results and sends **one clean response** to the client.

This is called the **Gateway pattern**.

---

## 2. Why This Matters

As your system grows:

* You get **many microservices**.
* Frontends (web, mobile, dashboards) don‚Äôt want to call 5‚Äì10 services directly.
* Each service has its own URL, format, and rules.

So you put **GraphQL as a gateway**:

* Frontend ‚Üí **GraphQL** ‚Üí many REST / gRPC / DB services
* Frontend stays **simple**.
* Backend can change internally; GraphQL hides complexity.

This is great for:

* Microservice architectures
* Backend for Frontend (BFF) setups
* Multiple frontends (web, mobile, reporting tools) using the same gateway

---

## 3. Real-Life Example Story

Imagine a **shopping website**:

* One REST service `/customers` stores customer profiles.
* Another REST service `/orders` stores all orders.

In a pure REST world, the frontend might do:

1. `GET /customers/123`
2. `GET /orders?customerId=123`

It has to know **both** endpoints and how to join the data.

With GraphQL as a **gateway**:

* Frontend sends **one** GraphQL query:
  ‚ÄúGive me customer 123 and all their orders.‚Äù
* The GraphQL server:

  * Calls `/customers/123`
  * Calls `/orders?customerId=123`
  * Joins them into a single `Customer` object with an `orders` field
* Frontend gets a **clean, ready-to-use** JSON.

Like a receptionist who calls different departments (accounts, shipping, support) and then gives you a **single answer**.

---

## 4. Code Examples

We‚Äôll use **Node.js + Apollo Server** for the example.

### 4.1 GraphQL Schema ‚Äì Customer with Orders

```graphql
# schema.graphql
type Customer {
  id: ID!
  name: String!
  email: String!
  orders: [Order!]!
}

type Order {
  id: ID!
  total: Float!
  status: String!
}

type Query {
  customer(id: ID!): Customer
}
```

What this means:

* `Customer` type has an `orders` field.
* `orders` does **not** come from the customer service directly.
* We will **compute** it by calling the Order service in the resolver.

---

### 4.2 REST Services (Mocked)

Imagine we already have two REST services:

* **Customer service**

  * `GET /customers/:id` ‚áí returns one customer

  Example response:

  ```json
  {
    "id": "123",
    "name": "Alice",
    "email": "alice@example.com"
  }
  ```

* **Order service**

  * `GET /orders?customerId=123` ‚áí returns list of orders for that customer

  Example response:

  ```json
  [
    { "id": "o1", "total": 100.5, "status": "PAID", "customerId": "123" },
    { "id": "o2", "total": 49.99, "status": "SHIPPED", "customerId": "123" }
  ]
  ```

We will **not** change these services.
GraphQL will just **call them**.

---

### 4.3 GraphQL Server (Gateway) ‚Äì Node + Apollo

```js
// index.js
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';
import fs from 'fs';
import fetch from 'node-fetch';

const typeDefs = fs.readFileSync('./schema.graphql', 'utf8');

const resolvers = {
  Query: {
    // This resolver calls the REST /customers service
    customer: async (_, { id }) => {
      const res = await fetch(`http://localhost:3001/customers/${id}`);
      if (!res.ok) {
        throw new Error('Customer service error');
      }
      const customer = await res.json();
      return customer;
    },
  },
  Customer: {
    // This field-level resolver calls the REST /orders service
    orders: async (parent) => {
      // parent is the Customer object returned above
      const customerId = parent.id;
      const res = await fetch(
        `http://localhost:3002/orders?customerId=${customerId}`
      );
      if (!res.ok) {
        throw new Error('Order service error');
      }
      const orders = await res.json();
      return orders;
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

const start = async () => {
  const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
  });
  console.log(`üöÄ GraphQL gateway ready at ${url}`);
};

start();
```

Key idea:

* `Query.customer` resolver calls **Customer REST service**.
* `Customer.orders` resolver calls **Order REST service**.
* GraphQL **merges** them into one object.

---

### 4.4 Client GraphQL Query (Frontend)

From frontend (React, Vue, mobile, etc.), we just call:

```graphql
query GetCustomerWithOrders {
  customer(id: "123") {
    id
    name
    email
    orders {
      id
      total
      status
    }
  }
}
```

The frontend **does not care** that behind the scenes:

* One call goes to `/customers/123`
* Another to `/orders?customerId=123`

It sees only **one** endpoint: `/graphql`.

---

### 4.5 REST vs GraphQL View

**REST way (frontend logic):**

```text
GET /customers/123
GET /orders?customerId=123
// frontend joins data itself
```

**GraphQL gateway way:**

```text
POST /graphql
{ customer(id: "123") { id name email orders { id total status } } }
```

Frontend gets **ready-made** data.

---

### 4.6 (Optional) Simple Python Client Calling GraphQL

Even from Python (for another service or script), you can call the gateway:

```python
import requests

query = """
query GetCustomerWithOrders($id: ID!) {
  customer(id: $id) {
    id
    name
    email
    orders {
      id
      total
      status
    }
  }
}
"""

variables = {"id": "123"}

resp = requests.post(
    "http://localhost:4000/graphql",
    json={"query": query, "variables": variables},
)

print(resp.json())
```

This shows how **other services** can also use the GraphQL gateway.

---

## 5. Simple Diagram

Text diagram of the **gateway pattern**:

```text
        Frontend / Client
                |
                v
        +------------------+
        |  GraphQL Gateway |
        +------------------+
          /            \
         /              \
        v                v
+----------------+   +----------------+
| Customer REST  |   |  Order REST    |
|  /customers    |   |  /orders       |
+----------------+   +----------------+
```

Data flow:

1. Frontend ‚Üí GraphQL: `customer(id: "123") { ... orders { ... } }`
2. GraphQL ‚Üí Customer REST: `/customers/123`
3. GraphQL ‚Üí Order REST: `/orders?customerId=123`
4. GraphQL combines data ‚Üí returns single JSON to frontend.

---

## 6. How to Instruct Codex to Automate This

Here are some ready-made prompts you (or your students) can paste into Codex.

1. **Generate a basic gateway schema**

   > ‚ÄúCodex, generate a GraphQL schema (SDL) for a Customer and Order system where Customer has an orders field. Include a Query type with customer(id: ID!).‚Äù

2. **Create a GraphQL gateway server calling two REST services**

   > ‚ÄúCodex, generate a Node.js Apollo Server that reads schema.graphql and exposes a customer(id) query. The customer resolver should call `http://localhost:3001/customers/:id` and the Customer.orders field resolver should call `http://localhost:3002/orders?customerId=:id`. Use fetch and include simple error handling.‚Äù

3. **Add a sample client query**

   > ‚ÄúCodex, write an example GraphQL query named GetCustomerWithOrders that asks for customer id, name, email, and their orders (id, total, status).‚Äù

4. **Python integration example**

   > ‚ÄúCodex, generate a small Python script using requests that calls the GraphQL gateway at [http://localhost:4000/graphql](http://localhost:4000/graphql) with the GetCustomerWithOrders query and prints the JSON response.‚Äù

---

## 7. Summary

1. A **GraphQL gateway** can sit in front of many services and give clients **one clean endpoint**.
2. Resolvers act like **waiters**, calling different backend services and **merging** their answers into a single GraphQL type.
3. This pattern is perfect for **microservices**, so your frontend remains simple while your backend can grow and evolve behind the GraphQL wall.

