# 54. E-commerce Admin Panel — Products, Categories, Orders

### 1. Introduction

In this chapter, we build a simple **E-commerce Admin Panel** using GraphQL.

Entities:

* **Category** – groups of products (e.g., “Mobiles”, “Clothes”)
* **Product** – items you sell
* **Order** – customer’s purchase (one or more products)

We will:

* Design the **GraphQL schema**
* Add simple **resolvers**
* Build a **basic React admin UI** to manage products, categories, and view orders

Think of this as the **back-office screen** for a small online shop.

---

### 2. Why this matters

Every e-commerce system needs an **admin side** to:

* Add / update / delete **products**
* Organize products into **categories**
* View **orders** to pack and ship items

With **REST**, you may have:

* `GET /categories`, `POST /categories`
* `GET /products`, `POST /products`
* `GET /orders`, `GET /orders/:id`

And you manually connect them in the frontend.

With **GraphQL**, the admin UI can say:

```graphql
query {
  products {
    id
    name
    price
    category {
      name
    }
  }
}
```

Or:

```graphql
query {
  order(id: "o1") {
    id
    status
    items {
      product {
        name
        price
      }
      quantity
    }
  }
}
```

One GraphQL endpoint → flexible queries → faster frontend development.

---

### 3. Use-case story (real-life example)

Imagine a small **online shop**:

* Riya runs a shop selling T-shirts, shoes, and bags.
* She uses an **Admin Panel** to:

  * Create **categories**: “T-Shirts”, “Shoes”, “Bags”
  * Add **products** under each category
  * Check **orders** as they come in and mark them as “Shipped”

Riya wants one simple screen where she can:

* See the list of products (with category names)
* Quickly open an order and see product names, quantity, and total

GraphQL makes it easy for the frontend to **ask exactly what it needs** in one go.

---

### 4. Code Examples

We’ll use **Node + Apollo Server** for backend and **React** for frontend.

#### 4.1 GraphQL Schema (SDL)

```graphql
# ecommerce.graphql

type Category {
  id: ID!
  name: String!
  description: String
  products: [Product!]!
}

type Product {
  id: ID!
  name: String!
  price: Float!
  inStock: Boolean!
  categoryId: ID!
  category: Category
}

type OrderItem {
  productId: ID!
  quantity: Int!
  product: Product
}

type Order {
  id: ID!
  createdAt: String!
  status: String! # PENDING, PAID, SHIPPED
  items: [OrderItem!]!
}

type Query {
  categories: [Category!]!
  products: [Product!]!
  product(id: ID!): Product
  orders: [Order!]!
  order(id: ID!): Order
}

input CategoryInput {
  name: String!
  description: String
}

input ProductInput {
  name: String!
  price: Float!
  inStock: Boolean!
  categoryId: ID!
}

input OrderItemInput {
  productId: ID!
  quantity: Int!
}

input OrderInput {
  items: [OrderItemInput!]!
}

type Mutation {
  addCategory(input: CategoryInput!): Category!
  addProduct(input: ProductInput!): Product!
  updateProduct(id: ID!, input: ProductInput!): Product!
  addOrder(input: OrderInput!): Order!
  updateOrderStatus(id: ID!, status: String!): Order!
}
```

**In simple words:**

* `Category` has many `products`.
* `Product` belongs to one `Category`.
* `Order` has `items` (each item has a product + quantity).
* Admin can **create** categories, products, orders, and **update** product and order status.

---

#### 4.2 Simple In-Memory “Database”

For demo only (real projects use SQL / Mongo etc.):

```js
// db.js
const categories = [];
const products = [];
const orders = [];

let idCounter = 1;

module.exports = {
  categories,
  products,
  orders,
  nextId: () => String(idCounter++),
};
```

---

#### 4.3 Resolvers (Backend Logic)

```js
// resolvers.js
const { categories, products, orders, nextId } = require("./db");

const resolvers = {
  Query: {
    categories: () => categories,
    products: () => products,
    product: (_, { id }) => products.find((p) => p.id === id),
    orders: () => orders,
    order: (_, { id }) => orders.find((o) => o.id === id),
  },

  Mutation: {
    addCategory: (_, { input }) => {
      const category = { id: nextId(), ...input };
      categories.push(category);
      return category;
    },

    addProduct: (_, { input }) => {
      const product = { id: nextId(), ...input };
      products.push(product);
      return product;
    },

    updateProduct: (_, { id, input }) => {
      const index = products.findIndex((p) => p.id === id);
      if (index === -1) throw new Error("Product not found");
      products[index] = { id, ...input };
      return products[index];
    },

    addOrder: (_, { input }) => {
      const order = {
        id: nextId(),
        createdAt: new Date().toISOString(),
        status: "PENDING",
        items: input.items,
      };
      orders.push(order);
      return order;
    },

    updateOrderStatus: (_, { id, status }) => {
      const order = orders.find((o) => o.id === id);
      if (!order) throw new Error("Order not found");
      order.status = status;
      return order;
    },
  },

  Category: {
    products: (parent) => products.filter((p) => p.categoryId === parent.id),
  },

  Product: {
    category: (parent) => categories.find((c) => c.id === parent.categoryId) || null,
  },

  OrderItem: {
    product: (parent) => products.find((p) => p.id === parent.productId) || null,
  },
};

module.exports = resolvers;
```

This connects:

* `Category.products`
* `Product.category`
* `OrderItem.product`

So the frontend can ask nested queries easily.

---

### 4.4 React Admin UI (Basic)

Let’s build a very simple **admin panel**:

* Page 1: **Products list** (with category name)
* Page 2: **Orders list** (with basic details)

We’ll use plain `fetch` for GraphQL calls.

#### 4.4.1 Queries (frontend)

```js
// adminQueries.js
export const LIST_PRODUCTS_QUERY = `
  query {
    products {
      id
      name
      price
      inStock
      category {
        id
        name
      }
    }
  }
`;

export const LIST_ORDERS_QUERY = `
  query {
    orders {
      id
      createdAt
      status
      items {
        quantity
        product {
          name
          price
        }
      }
    }
  }
`;
```

---

#### 4.4.2 Products Page

```jsx
// ProductsPage.jsx
import React, { useEffect, useState } from "react";
import { LIST_PRODUCTS_QUERY } from "./adminQueries";

export function ProductsPage() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  useEffect(() => {
    async function load() {
      try {
        const res = await fetch("http://localhost:4000/graphql", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: LIST_PRODUCTS_QUERY }),
        });
        const json = await res.json();
        if (json.errors) {
          setError(json.errors[0].message);
        } else {
          setProducts(json.data.products);
        }
      } catch (err) {
        setError("Could not load products");
      } finally {
        setLoading(false);
      }
    }
    load();
  }, []);

  if (loading) return <div>Loading products…</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h2>Products</h2>
      <table border="1" cellPadding="4">
        <thead>
          <tr>
            <th>Name</th>
            <th>Category</th>
            <th>Price</th>
            <th>In stock?</th>
          </tr>
        </thead>
        <tbody>
          {products.map((p) => (
            <tr key={p.id}>
              <td>{p.name}</td>
              <td>{p.category ? p.category.name : "-"}</td>
              <td>{p.price}</td>
              <td>{p.inStock ? "Yes" : "No"}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

Later you can add:

* “Add Product” form (using a GraphQL mutation)
* “Edit Product” form

---

#### 4.4.3 Orders Page

```jsx
// OrdersPage.jsx
import React, { useEffect, useState } from "react";
import { LIST_ORDERS_QUERY } from "./adminQueries";

function calculateTotal(order) {
  return order.items.reduce((sum, item) => {
    const price = item.product ? item.product.price : 0;
    return sum + price * item.quantity;
  }, 0);
}

export function OrdersPage() {
  const [orders, setOrders] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  useEffect(() => {
    async function load() {
      try {
        const res = await fetch("http://localhost:4000/graphql", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: LIST_ORDERS_QUERY }),
        });
        const json = await res.json();
        if (json.errors) {
          setError(json.errors[0].message);
        } else {
          setOrders(json.data.orders);
        }
      } catch (err) {
        setError("Could not load orders");
      } finally {
        setLoading(false);
      }
    }
    load();
  }, []);

  if (loading) return <div>Loading orders…</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div style={{ marginTop: "2rem" }}>
      <h2>Orders</h2>
      {orders.length === 0 ? (
        <p>No orders yet.</p>
      ) : (
        <table border="1" cellPadding="4">
          <thead>
            <tr>
              <th>Order ID</th>
              <th>Created</th>
              <th>Status</th>
              <th>Items (summary)</th>
              <th>Total</th>
            </tr>
          </thead>
          <tbody>
            {orders.map((o) => (
              <tr key={o.id}>
                <td>{o.id}</td>
                <td>{o.createdAt}</td>
                <td>{o.status}</td>
                <td>
                  {o.items.map((item, index) => (
                    <div key={index}>
                      {item.quantity} × {item.product ? item.product.name : "Unknown"}
                    </div>
                  ))}
                </td>
                <td>{calculateTotal(o)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}
```

---

#### 4.4.4 Simple Admin Shell

```jsx
// AdminApp.jsx
import React, { useState } from "react";
import { ProductsPage } from "./ProductsPage";
import { OrdersPage } from "./OrdersPage";

export function AdminApp() {
  const [tab, setTab] = useState("products");

  return (
    <div style={{ padding: "1rem" }}>
      <h1>E-commerce Admin Panel</h1>
      <div style={{ marginBottom: "1rem" }}>
        <button onClick={() => setTab("products")}>Products</button>
        <button onClick={() => setTab("orders")}>Orders</button>
      </div>

      {tab === "products" && <ProductsPage />}
      {tab === "orders" && <OrdersPage />}
    </div>
  );
}
```

Now you have a very basic **admin panel**:

* Switch tabs between **Products** and **Orders**
* Both use **GraphQL** under the hood.

---

### 5. Diagram

Simple diagram of this setup:

```text
[Admin Browser with React UI]
            |
            v
      (GraphQL query)
            |
      [GraphQL Server]
            |
    +-------+-------+
    |               |
[Category Store] [Product Store]
                     |
                     v
                  [Order Store]
```

Flow:

1. Admin UI makes a **GraphQL request** (e.g., `products`, `orders`).
2. GraphQL server reads/updates data from the in-memory stores (later a real DB).
3. Response goes back as **nested JSON** that matches the React UI needs.

---

### 6. How to instruct Codex to automate this

You can use Codex to build almost everything from this idea.

Ready-to-use prompts:

1. **Main prompt (as given):**

   > “Create schema, resolvers, and basic admin UI for products, categories, and orders using GraphQL and React.”

2. **Backend-focused prompt:**

   > “Using Node.js and Apollo Server, create a GraphQL schema and resolvers for an e-commerce admin backend with Category, Product, and Order. Use in-memory arrays as storage and include sample seed data.”

3. **React admin panel prompt:**

   > “Generate a React admin panel that talks to this GraphQL backend. Add a Products page (table with name, price, category, stock) and an Orders page (table with order id, status, item summary, and total). Use fetch for GraphQL calls and keep the code simple.”

4. **Mutation / forms prompt:**

   > “Add a simple ‘Add Product’ form to the Products page that calls an addProduct GraphQL mutation, and refreshes the list after a successful save. Use clear field names and basic validation.”

---

### 7. Summary

1. An **E-commerce Admin Panel** needs to manage **categories**, **products**, and **orders** in one place.
2. GraphQL makes it easy to fetch **nested data**, like product with category or order with its items, using one flexible endpoint.
3. A small **React admin UI** can talk to this GraphQL server and give shop owners a clear, simple back-office to run their business.

