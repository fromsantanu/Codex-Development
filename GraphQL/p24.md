# 24. Updating UI After Mutations

### (Re-fetch or Update Local State)

---

### 1. Short Introduction

When you run a **mutation** in GraphQL (add, update, delete):

* The **backend** data changes.
* But your **React state** does not change by itself.

If you don’t handle this, the user clicks “Add Student” and:

* The server saves the student…
* …but the list on screen still looks old.

In this chapter we learn two simple ways:

1. **Re-fetch** the list from the server.
2. **Update local state** (add/remove/change items in memory).

---

### 2. Why This Matters

For any business app (clinic, shop, school):

* User adds a record → they expect to see it **immediately**.
* User edits a record → they expect to see the **new data**.
* User deletes a record → it should **disappear** from the list.

If the page does not update:

* User refreshes the browser.
* User gets confused (“Did it work?”).
* App feels slow and unreliable.

Good UI always keeps the **screen in sync** with the **backend**.

---

### 3. Use-Case Story – Student List + Add Student

Imagine a page:

* Top: **form** to add a student (name, email).
* Bottom: **list** of students.

When you click “Save”:

1. React calls a **GraphQL mutation** (`addStudent`).
2. Server returns the **new student**.
3. You have two options:

   * **Re-fetch** the whole list from GraphQL.
   * Or **push the new student into local state** (no full reload).

We’ll focus on **updating local state**, because you asked:

> “After running this mutation, update the local list of items without reloading the whole page.”

---

### 4. Code Examples

We will build one small React page:

* It **loads** students.
* It **shows** them in a list.
* It has a **form** to add a student.
* After the mutation, it **updates local state**.

#### 4.1 GraphQL pieces (backend idea)

Just for context:

```graphql
query {
  students {
    id
    name
    email
  }
}

mutation AddStudent($input: AddStudentInput!) {
  addStudent(input: $input) {
    id
    name
    email
  }
}
```

---

#### 4.2 Full React Code – Load, Mutate, Update Local List

```jsx
// StudentPage.jsx
import React, { useEffect, useState } from "react";

const GRAPHQL_URL = "http://localhost:4000/graphql";

// Query: get all students
const STUDENTS_QUERY = `
  query {
    students {
      id
      name
      email
    }
  }
`;

// Mutation: add a new student
const ADD_STUDENT_MUTATION = `
  mutation AddStudent($input: AddStudentInput!) {
    addStudent(input: $input) {
      id
      name
      email
    }
  }
`;

export default function StudentPage() {
  const [students, setStudents] = useState([]);
  const [loading, setLoading] = useState(true);
  const [errorMsg, setErrorMsg] = useState("");

  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [saving, setSaving] = useState(false);

  // 1. Load students initially
  useEffect(() => {
    async function loadStudents() {
      try {
        setLoading(true);
        setErrorMsg("");

        const res = await fetch(GRAPHQL_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: STUDENTS_QUERY }),
        });

        if (!res.ok) {
          throw new Error(`HTTP error ${res.status}`);
        }

        const result = await res.json();
        if (result.errors && result.errors.length > 0) {
          throw new Error(result.errors[0].message);
        }

        setStudents(result.data.students || []);
      } catch (err) {
        setErrorMsg(err.message || "Could not load students.");
      } finally {
        setLoading(false);
      }
    }

    loadStudents();
  }, []);

  // 2. Handle form submit (run mutation)
  async function handleAddStudent(e) {
    e.preventDefault();

    if (!name.trim() || !email.trim()) return;

    try {
      setSaving(true);
      setErrorMsg("");

      const res = await fetch(GRAPHQL_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query: ADD_STUDENT_MUTATION,
          variables: {
            input: { name, email },
          },
        }),
      });

      if (!res.ok) {
        throw new Error(`HTTP error ${res.status}`);
      }

      const result = await res.json();
      if (result.errors && result.errors.length > 0) {
        throw new Error(result.errors[0].message);
      }

      const newStudent = result.data.addStudent;

      // 3. Update local state (IMPORTANT PART)
      // Instead of reloading page or re-fetching query,
      // we just add the new student to the existing array.
      setStudents((oldStudents) => [...oldStudents, newStudent]);

      // Clear form fields
      setName("");
      setEmail("");
    } catch (err) {
      setErrorMsg(err.message || "Could not add student.");
    } finally {
      setSaving(false);
    }
  }

  // Rendering

  if (loading) {
    return <div>Loading students…</div>;
  }

  return (
    <div style={{ padding: "16px" }}>
      <h2>Students</h2>

      {errorMsg && (
        <div style={{ color: "red", marginBottom: "8px" }}>
          Error: {errorMsg}
        </div>
      )}

      {/* Add Student Form */}
      <form onSubmit={handleAddStudent} style={{ marginBottom: "16px" }}>
        <div>
          Name:{" "}
          <input
            value={name}
            onChange={(e) => setName(e.target.value)}
            required
          />
        </div>
        <div>
          Email:{" "}
          <input
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <button type="submit" disabled={saving}>
          {saving ? "Saving…" : "Add Student"}
        </button>
      </form>

      {/* List of students */}
      {students.length === 0 ? (
        <div>No students yet. Add the first one above.</div>
      ) : (
        <ul>
          {students.map((s) => (
            <li key={s.id}>
              {s.name} – {s.email}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

**What is happening after mutation?**

```jsx
const newStudent = result.data.addStudent;

// IMPORTANT:
setStudents((oldStudents) => [...oldStudents, newStudent]);
```

This line:

* Takes the **old array** of students.
* Adds the **new student** at the end.
* Updates the state → React re-renders → list shows the new student.

No page reload, no extra GraphQL query.

---

#### 4.3 Alternative: Re-fetch the list instead of updating local state

Sometimes you prefer to **always trust the server** and re-load the list:

```jsx
// after successful mutation:
await reloadStudents(); // call the same function used in useEffect
```

* This makes sure the UI shows exactly what is in the DB.
* But it adds one more network call.

You can choose based on your needs:

* **Small apps**: re-fetching is simpler.
* **Bigger apps**: updating local state can be faster.

---

#### 4.4 Example of Updating on Delete (same idea)

```jsx
async function handleDeleteStudent(id) {
  // assume deleteStudent mutation already called and succeeded

  setStudents((oldStudents) =>
    oldStudents.filter((s) => s.id !== id)
  );
}
```

Again, we **remove** the student from the local list, and React redraws the UI.

---

### 5. Simple Diagram

```text
User clicks "Add"
     |
     v
Run GraphQL mutation (addStudent)
     |
     v
Server returns new student
     |
     v
Update local state:
  students = oldStudents + newStudent
     |
     v
React re-renders
     |
     v
User sees updated list
```

No page refresh needed.
Only state changes.

---

### 6. How to Instruct Codex to Automate This

Use Codex to write or refactor your components.

1. **Update local list after mutation (your exact request)**

   > “After running this mutation, update the local list of items without reloading the whole page. Show the full React code.”

2. **Refactor from re-fetch to local update**

   > “This React component re-fetches the whole list after a GraphQL mutation. Refactor it so that it updates the local state array (add / remove / update item) instead of calling the list query again.”

3. **Add delete logic**

   > “Extend this React component so that it includes a delete button for each item, calls a GraphQL delete mutation, and updates the local list by removing the deleted item.”

4. **Edit item and update state**

   > “Given this GraphQL updateStudent mutation, generate a React component that allows editing a student and updates the local list so that the changed student data is visible immediately.”

5. **Split into hook + UI**

   > “Create a custom React hook useStudentsWithAdd that loads students, runs an addStudent mutation, and updates local state. Then generate a simple UI component that uses this hook.”

---

### 7. Summary

1. After a GraphQL mutation, the **UI does not update automatically**; you must either **re-fetch** or **update local state**.
2. Adding, deleting, or updating items in local state (arrays) makes the page update instantly without a full reload.
3. Codex can generate full React components that call mutations and **keep the UI in sync** by updating the local list of items.

