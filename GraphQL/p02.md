
# Chapter 2. REST vs GraphQL

## 1. Introduction  
REST gives you many fixed endpoints.  
Each endpoint returns a fixed shape of data.  
Sometimes you receive more data than needed (**overfetching**) or less than needed (**underfetching**).  
GraphQL solves this by giving one flexible endpoint where the client chooses the exact fields.  
This makes development smoother for both frontend and backend.

---

## 2. Why This Matters  
- Reduces network calls for complex screens.  
- UI can change without changing backend endpoints.  
- Makes data fetching predictable and easy to maintain.  
- Faster iteration for microservices and large systems.

---

## 3. Real-Life Example (Shopping Story)  
Imagine you enter a shop and ask for:  
- Customer details  
- The list of items they bought  
- Only the item name and price  

REST is like visiting **different counters** for each thing.  
You might get extra details you didn’t ask for.  

GraphQL is like talking to **one shop employee** who gives you exactly the fields you request—no extra, no missing fields.

---

## 4. Code Examples

### A. REST: Overfetching Example  
You need only the customer's name and their order numbers.

But REST:

```

GET /customers/10
→ returns full customer record (name, phone, email, address, …)



To get orders:

```

GET /customers/10/orders
→ returns full order objects (orderId, items, price, timestamps, …)

```

Even if UI needs only:

```

customer.name
order.id

```

you still get everything.

---

### B. REST: Underfetching Example  
Maybe the UI needs:

- customer name  
- each order’s **total amount**  
- AND item count per order  

REST may not have a single endpoint for this.  
So you call:

```

GET /customers/10
GET /customers/10/orders
GET /orders/{id}/items

````

Three calls = underfetching problem.

---

### C. GraphQL: One flexible endpoint  
GraphQL lets you fetch all data in **one request**:

```graphql
query {
  customer(id: 10) {
    name
    orders {
      id
      total
    }
  }
}
````

The server returns only these fields.

---

### D. GraphQL Response

```json
{
  "data": {
    "customer": {
      "name": "Amit Sharma",
      "orders": [
        { "id": 101, "total": 450 },
        { "id": 102, "total": 320 }
      ]
    }
  }
}
```

Clean, precise, no waste.

---

## 5. Diagram

**REST style (many trips)**

```
Frontend
   ↓
GET /customer/10
   ↓
GET /customer/10/orders
   ↓
GET /orders/.../items
```

**GraphQL style (one trip)**

```
Frontend
   ↓
GraphQL Endpoint (/graphql)
   ↓
Query → Resolver → Database
```

---

## 6. How to Instruct Codex (Copy-Paste Prompts)

**Prompt 1**
“Write a short comparison table REST vs GraphQL with examples of API calls and responses for a ‘customer + orders’ scenario.”

**Prompt 2**
“Codex, show an example of overfetching and underfetching in REST and how GraphQL solves it.”

**Prompt 3**
“Codex, generate a GraphQL query to fetch customer name and order totals in a single request.”

**Prompt 4**
“Codex, produce REST endpoints needed for the same UI scenario and compare them with one GraphQL query.”

---

## 7. Summary

* REST often suffers from overfetching and underfetching.
* REST uses many endpoints; GraphQL uses one flexible endpoint.
* GraphQL lets the client pick exactly the fields it needs.
* Cleaner, faster, and easier especially for complex UIs.

```
```

