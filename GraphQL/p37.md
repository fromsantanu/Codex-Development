# Chapter 37. Securing Mutations

### 1. Simple heading

**Securing Mutations – Preventing Unwanted Changes in GraphQL**

---

### 2. Short introduction

Mutations change data.
Because they change the database, they must be **carefully protected**.

If we don’t add checks, users may:

* Update someone else’s information
* Delete items they shouldn’t touch
* Send wrong or incomplete data
* Break the system with invalid inputs

So we need **server-side validation** and **clear error messages**.
This keeps the app safe and also makes the user experience friendly.

---

### 3. Use-case story

Think of a **clinic system** again:

* A **doctor** writes notes for a patient — this is allowed.
* A **patient** must not change another patient’s record.
* A **receptionist** must not delete medical notes.

Every mutation needs to check:

1. **Who** is doing this action (check JWT and role).
2. **Is this action allowed?** (doctor-only? patient-only?)
3. **Is the input valid?** (no empty fields, correct formats)
4. **Is the resource theirs?** (patients can update only their own profile)

This is like a hospital clerk checking your form:

* “Do you have permission?”
* “Is the form correctly filled?”
* “Are you changing only your own details?”

---

### 4. Code examples (small & clear)

We follow the Node + Apollo style, but the idea works with any stack.

#### 4.1 GraphQL schema example

```graphql
type Mutation {
  updatePatientProfile(
    name: String!
    phone: String!
  ): Patient!

  addMedicalNote(
    patientId: ID!
    note: String!
  ): MedicalNote!
}
```

* First mutation → patient updates own profile.
* Second mutation → doctor writes a note.

We must secure both.

---

#### 4.2 Secure mutation resolver with validation

##### Example: patient updates own profile

```js
// patientMutations.js
import { requireRole } from './authHelpers.js';

export const resolvers = {
  Mutation: {
    async updatePatientProfile(_, args, { db, currentUser }) {
      // 1. Check role
      requireRole(currentUser, ['PATIENT']);

      // 2. Validate fields (server-side)
      if (!args.name.trim()) {
        throw new Error('Name cannot be empty.');
      }

      if (!/^[0-9]{10}$/.test(args.phone)) {
        throw new Error('Phone must be a 10-digit number.');
      }

      // 3. Only update the logged-in patient’s own profile
      const updated = await db.patient.update({
        where: { id: currentUser.id },
        data: {
          name: args.name,
          phone: args.phone,
        },
      });

      return updated;
    },
  },
};
```

Key ideas:

* Check role → only PATIENT can call.
* Validate input → no empty name, phone format checked.
* Update only the user’s own record → prevents them from updating others.

---

#### 4.3 Secure mutation for doctor-only action

```js
// medicalNoteMutations.js
export const resolvers = {
  Mutation: {
    async addMedicalNote(_, { patientId, note }, { db, currentUser }) {

      // 1. Only doctor can write notes
      requireRole(currentUser, ['DOCTOR']);

      // 2. Validate note text
      if (!note.trim()) {
        throw new Error('Medical note cannot be empty.');
      }

      // 3. Check if patient exists
      const patient = await db.patient.findUnique({
        where: { id: Number(patientId) },
      });

      if (!patient) {
        throw new Error('Patient not found.');
      }

      // 4. Create note
      return db.medicalNote.create({
        data: {
          patientId: Number(patientId),
          doctorId: currentUser.id,
          note,
        },
      });
    },
  },
};
```

This prevents:

* “Ghost notes” (assigning notes to non-existent patients)
* Empty notes
* Unauthorized roles

---

#### 4.4 Returning user-friendly error messages

GraphQL errors should still be **simple and clear**.
Example user-friendly errors:

* “You must be logged in.”
* “You are not allowed to perform this action.”
* “Name cannot be empty.”
* “Phone must be a 10-digit number.”
* “Patient not found.”

Avoid:

* technical logs
* stack traces
* private details (like passwords)

---

### 5. Diagram

```text
         Mutation received
                 |
                 v
         Check JWT (role)
                 |
             allowed? ------- no ----> return "Not authorized"
                 |
                 v
           Validate input
                 |
            valid? ------- no ----> return "Invalid input: ..."
                 |
                 v
          Check ownership
                 |
            allowed? ------- no ----> return "You cannot change this record"
                 |
                 v
            Perform update
                 |
                 v
            Return success
```

---

### 6. “How to instruct Codex” prompts

Here are ready-to-use prompts.

1. **Add validation inside mutations**

> “Add server-side validation and sensible error messages to these mutations, and return user-friendly error text.”

2. **Check if resource belongs to the user**

> “Modify these GraphQL mutations so that patients can update only their own profile, and return a clear error if they try to update another user.”

3. **Doctor-only mutation protection**

> “Update the addMedicalNote resolver to allow only DOCTOR role users and return readable errors for empty notes or invalid patient IDs.”

4. **Combine role check + validation**

> “Improve these resolvers by adding role-based access checks and input validation, and return friendly messages instead of technical errors.”

---

### 7. Summary

1. Mutations must be secured because they **change** data.
2. We need **role checks**, **input validation**, and **ownership checks**.
3. Always return **simple, user-friendly error messages**, never raw technical details.

With these protections, your GraphQL backend becomes safe, predictable, and professional.

