# Chapter 33. Performance Considerations

*Selecting only needed fields, avoiding huge responses*

---

### 1. Introduction – Do less, get more speed

GraphQL gives a **big advantage**:
clients can ask for only the fields they need.

But if you ask for **too many fields**,
you end up with:

* Larger network responses
* Slower rendering on the frontend
* More work for the backend resolvers
* Unnecessary database queries

So good performance starts with a simple idea:
**“Take only what you need.”**

Just like at a buffet—you don’t load your plate with everything.
Otherwise you slow yourself down, waste food, and make others wait.

---

### 2. Why this matters

* Faster loading for users (especially on mobile connections).
* Reduced server load.
* Smaller bandwidth usage → less cost on cloud servers.
* More predictable performance for dashboards and lists.

The main performance trick in GraphQL is:
**ask for fewer fields** and **avoid fetching large nested lists you don’t need**.

---

### 3. Real-life example – Clinic dashboard

Imagine a clinic app showing a **list of patients**.

Bad GraphQL query (asks for everything):

```graphql
query {
  patients {
    id
    fullName
    phoneNumber
    email
    gender
    address
    prescriptions {
      id
      medicines {
        id
        name
        manufacturer
        cost
        expiryDate
        dosageInstructions
      }
    }
    appointments {
      id
      date
      doctor {
        id
        fullName
        specialization
        phoneNumber
      }
    }
  }
}
```

This is like asking the receptionist:
“Give me every detail about every patient in the clinic.”
It’s too much!

Better query for a **simple list**:

```graphql
query {
  patients {
    id
    fullName
    phoneNumber
  }
}
```

Ask for deeper details **only when needed**:

* When opening patient profile
* When viewing appointment history
* When showing prescription details

---

### 4. Code Examples – Optimizing queries

#### 4.1 Before and after (simple list page)

**Before (bad):**

```graphql
query {
  patients {
    id
    fullName
    phoneNumber
    email
    gender
    address
    appointments { id date }
    prescriptions { id }
  }
}
```

**After (good):**

```graphql
query {
  patients {
    id
    fullName
    phoneNumber
  }
}
```

Why better?

* Faster response
* Less CPU and database work
* Simple UI only needs basic fields anyway

---

#### 4.2 Avoid loading heavy nested lists

Bad query (too deep):

```graphql
query {
  doctor(id: "D1") {
    id
    fullName
    appointments {
      id
      date
      patient {
        id
        fullName
        prescriptions {
          id
          medicines {
            name
          }
        }
      }
    }
  }
}
```

This fetches **hundreds of nested items**
even if you need only the doctor’s basic info.

Better:

```graphql
query {
  doctor(id: "D1") {
    id
    fullName
  }
}
```

Load appointments only when user opens “View Appointments”.

---

#### 4.3 Asking only for needed fields in details page

Bad:

```graphql
query {
  patient(id: "P1") {
    id
    fullName
    prescriptions {
      id
      medicines {
        id
        name
        manufacturer
        cost
        expiryDate
        dosageInstructions
      }
    }
  }
}
```

Suppose you only want medicine name for displaying a quick summary.

Optimized:

```graphql
query {
  patient(id: "P1") {
    id
    fullName
    prescriptions {
      id
      medicines {
        name
      }
    }
  }
}
```

This reduces:

* JSON size
* DB lookups
* Resolver work

---

### 5. REST vs GraphQL – performance approach

REST endpoints often give **fixed** payloads:

```http
GET /patients
```

Response may contain fields you don’t need.

GraphQL lets you request **only** what matters:

```graphql
query {
  patients {
    id
    fullName
  }
}
```

This built-in flexibility is a major performance tool.

---

### 6. Diagram – How unnecessary fields cause overhead

```text
Query → Resolver → Database → Response → Browser

If query asks for extra fields:
       ↑        ↑        ↑
 More DB work   |   Larger JSON size
 More resolver logic
```

Lower load = faster results.

---

### 7. How to Instruct Codex to Help

Use Codex as a **query optimizer**.

1. **Main prompt (from your question):**

> “Optimize these example queries to only request necessary fields and explain how that helps performance.”

Paste your queries, e.g.:

```graphql
query {
  patients {
    id
    fullName
    email
    address
    prescriptions {
      id
      medicines {
        id
        name
        manufacturer
      }
    }
  }
}
```

Codex will:

* Remove unnecessary fields
* Reduce nesting
* Explain why

2. Ask Codex to create **optimized versions for different UI pages**

> “Generate optimized queries for: Patient List Page, Patient Profile Page, Appointment History Page.”

3. Ask Codex to create **heavy vs light** versions

> “Create a lightweight query for table display and a heavier query for detail page. Avoid fetching nested lists in the table version.”

4. Ask Codex to catch **hidden performance issues**

> “Review these queries and point out where they fetch too much data. Suggest smaller queries for the same UI.”

Codex becomes your **performance advisor**, helping reduce load.

---

### 8. Summary

* GraphQL lets you choose exactly which fields you want; use this power to stay fast.
* Avoid huge nested queries unless necessary.
* Smaller queries → smaller responses → faster apps.
* Use Codex to review and optimize queries for different pages and use-cases.

