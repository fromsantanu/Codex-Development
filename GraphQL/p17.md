# Chapter 17. Schema Stitching & Federation (Simple Idea)

---

## 1. Simple Introduction

As systems grow, you may have **many GraphQL schemas**, one for each service:

* A **User** GraphQL service
* A **Billing** GraphQL service
* An **Orders** GraphQL service

Now you want to combine them so the client sees *one* GraphQL API.

There are two simple ways to do this:

### **Schema Stitching**

“Join” many schemas together into **one big schema**.

### **Federation**

Each service keeps its **own schema**, but they can link to each other using shared keys.

Think of stitching as “put everything in one big book,”
and federation as “keep separate books but link their pages through references.”

---

## 2. Why This Matters

In a microservice system:

* Each team manages its own service.
* Each service may already expose GraphQL.
* You want a **single GraphQL gateway** for frontend apps.

GraphQL stitching or federation helps you:

* Combine many schemas
* Allow teams to work independently
* Avoid building one giant monolithic GraphQL server

Both methods help you scale without confusing the frontend.

---

## 3. Real-Life Example Story

Imagine a **shopping mall** with:

* A User desk
* A Billing counter
* An Order counter

Customers don’t want to go to each desk separately.

There are two solutions:

### **Schema Stitching (One Big Counter)**

Like putting all desks into **one giant counter**.
Staff from each desk sits behind one long table.
From the outside you see **one service**, inside they are still separate.

### **Federation (Linked Counters)**

Each desk stays independent.
But they share a **common token**, like a “Customer ID card.”
So when you say, “Show me customer + bills + orders,”
they use the shared ID to fetch data from each counter smoothly.

---

## 4. Code & Structure Examples

Below is a **simple, beginner-friendly** explanation.

---

## 4.1 Individual Service Schemas

### User Service

```graphql
type User {
  id: ID!
  name: String!
  email: String!
}

type Query {
  user(id: ID!): User
}
```

### Billing Service

```graphql
type Bill {
  id: ID!
  userId: ID!
  amount: Float!
}

type Query {
  billsByUser(userId: ID!): [Bill!]!
}
```

### Orders Service

```graphql
type Order {
  id: ID!
  userId: ID!
  total: Float!
}

type Query {
  ordersByUser(userId: ID!): [Order!]!
}
```

These are **3 disconnected schemas**.

---

## 4.2 What Schema Stitching Does

Schema stitching **combines all three schemas** into one big schema:

```
Big Combined Schema
   |
   +-- User schema
   +-- Billing schema
   +-- Orders schema
```

So the final GraphQL server supports:

```graphql
query {
  user(id: "123") {
    id
    name
    email
  }
  billsByUser(userId: "123") {
    id
    amount
  }
  ordersByUser(userId: "123") {
    id
    total
  }
}
```

You simply “merge” many schemas into **one file**.

It is simple, but not very smart.

It does not know that **User**, **Bill**, and **Order** are connected by `userId`.
You must manually write resolvers to join them.

---

## 4.3 What Federation Does

Federation keeps each service **independent**,
but lets them **extend each other** using shared keys.

### Example: Orders Gateway Says:

```graphql
extend type User @key(fields: "id") {
  id: ID! @external
  orders: [Order]
}
```

Meaning:

* “User exists in another service.”
* “I want to add a field `orders` to User.”

### In Billing Service:

```graphql
extend type User @key(fields: "id") {
  id: ID! @external
  bills: [Bill]
}
```

Now, without stitching everything together, clients can ask:

```graphql
query {
  user(id: "123") {
    name
    email
    orders { total }
    bills { amount }
  }
}
```

And the GraphQL federation gateway will:

* Fetch the **User** from User service
* Ask Orders service for user’s orders
* Ask Billing service for user’s bills
* Merge everything

Automatically.

---

## 5. Simple Text Diagrams

### ❖ Schema Stitching (One Big Counter)

```
            Frontend
                |
                v
     +----------------------+
     |  Combined Schema     |
     | (stitched together)  |
     +----------------------+
        /        |        \
       v         v         v
  User Service  Billing  Orders
```

Everything is merged inside the gateway.

---

### ❖ Federation (Linked Counters)

```
               Frontend
                   |
                   v
         +------------------+
         |  Federation Hub  |
         +------------------+
          /        |        \
         /         |         \
        v          v          v
     Users     Billing     Orders
      |           |           |
      |<-- shared keys ------>|
```

Each service stays **independent**,
but they link using shared fields like `id`, `userId`, etc.

---

## 6. How to Instruct Codex to Automate This

Here are ready-to-paste prompts.

---

### Prompt 1 — Explain Stitching

> “Codex, explain schema stitching in very simple terms using the example of User, Billing, and Orders GraphQL schemas. Include a text diagram and show how to combine the schemas into one gateway.”

---

### Prompt 2 — Explain Federation

> “Codex, explain GraphQL federation using the same User, Billing, and Orders microservices. Show how User can be extended with orders and bills using @key and @external.”

---

### Prompt 3 — Generate Example Code

> “Codex, generate example schemas and extension types for a federated system with a User service, Billing service, and Orders service. Include simple resolvers.”

---

### Prompt 4 — Compare Both Methods

> “Codex, create a simple comparison table of schema stitching vs federation for the User–Billing–Orders system, explaining when to use which approach.”

---

## 7. Summary

1. **Schema Stitching** → merges many schemas into one big schema (simple but less smart).
2. **Federation** → keeps schemas separate but links them using shared keys (smart & scalable).
3. Both methods help create **a single GraphQL API** even when your backend is split into many microservices.

