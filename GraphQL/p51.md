# 51. CI/CD Basics

*Auto test + deploy*

---

### 1. Introduction

CI/CD sounds big, but the idea is very simple:

* **CI (Continuous Integration)** = Every time you push code, tests run automatically.
* **CD (Continuous Delivery/Deployment)** = After tests pass, the app is prepared or deployed automatically.

Think of it like this:

* Whenever a chef finishes cooking a dish (your code),
* A **taster** checks if it is OK (tests).
* If it is good, the dish is **moved to the serving counter** (build/deploy).

We’ll use **GitHub Actions** as our kitchen assistant that does this automatically for your GraphQL project.

---

### 2. Why this matters

For a GraphQL backend (or REST):

* You avoid “it works on my machine” problems.
* You catch bugs early when someone pushes broken code.
* Your Docker image is always ready to deploy.

This is very useful when:

* Many students or developers work on the same project.
* You deploy often and don’t want to repeat manual steps.

---

### 3. Real-life example

Imagine a **clinic GraphQL API**:

* You have a test suite that checks:

  * `query { patient(id: 1) { name } }` returns correct data.
  * Mutations properly validate inputs.

You want:

* Whenever someone pushes to `main`:

  1. Run tests.
  2. If tests pass, build a fresh Docker image.

Later, you can add auto deploy (e.g., push Docker image to registry, then update VPS). For now, we focus on **auto-test + auto-build**.

---

### 4. Code Examples

We’ll assume:

* Node.js GraphQL server (Apollo / Yoga / etc.).
* Dockerfile already exists.
* Tests run with `npm test`.

You can easily adapt this to Python, etc.

---

#### 4.1 Project scripts (package.json)

Make sure you have scripts like:

```json
{
  "scripts": {
    "test": "npm test",
    "build": "npm run build"
  }
}
```

If you don’t have a `build` step, you can skip it or just run tests and docker build.

---

#### 4.2 Dockerfile (already in repo, example)

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install --production

COPY . .

ENV PORT=4000
EXPOSE 4000

CMD ["node", "src/index.js"]
```

---

#### 4.3 Simple GitHub Actions workflow (CI + Docker build)

Create folder and file:

```text
.github/
  workflows/
    ci.yml
```

Now add this content to `ci.yml`:

```yaml
name: CI for GraphQL Server

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Setup Node
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      # 3. Install dependencies
      - name: Install dependencies
        run: npm install

      # 4. Run tests
      - name: Run tests
        run: npm test

      # 5. Build Docker image (only if tests pass)
      - name: Build Docker image
        run: |
          docker build -t my-graphql-app:latest .
```

What this does:

1. **Triggers** on:

   * Push to `main`, or
   * Pull request targeting `main`.
2. Checks out your code.
3. Installs Node and dependencies.
4. Runs your tests.
5. If tests pass, builds Docker image.

If tests fail, the workflow stops and Docker build does **not** run.

---

#### 4.4 REST vs GraphQL in CI/CD

CI/CD doesn’t care if it’s REST or GraphQL:

* **REST project**: run tests, build Docker image.
* **GraphQL project**: same steps, just different tests.

The main difference is **inside** the tests:

* REST: test `GET /patients/1` and `POST /patients`.
* GraphQL: test `query { patient(id: 1) { ... } }` and mutations.

The CI pipeline itself looks almost identical.

---

### 5. Simple Diagram

```text
Developer pushes code to GitHub
            |
            v
     GitHub Actions
            |
   +--------+--------+
   |                 |
Run tests      (if tests fail) → Stop, show errors
   |                 
   v                 
Build Docker image (if tests pass)
   |
   v
Optional: Push image to registry / deploy to VPS
```

---

### 6. How to Instruct Codex

Here are ready-made prompts for you or your students.

---

#### Prompt 1 — Basic workflow (given prompt)

> “Create a simple GitHub Actions workflow that runs tests and builds the Docker image for my GraphQL project. Assume it uses Node.js and ‘npm test’ to run tests, and there is a Dockerfile in the root folder. Explain each step in simple language.”

---

#### Prompt 2 — Add Docker push to registry

> “Extend this GitHub Actions workflow so that, after building the Docker image, it logs in to Docker Hub using secrets DOCKER_USERNAME and DOCKER_PASSWORD, tags the image, and pushes it to my Docker Hub repository.”

---

#### Prompt 3 — Separate test and build jobs

> “Split the workflow into two jobs: one for testing and one for building the Docker image. The build job should only run if tests pass. Use simple, clear names and comment each section.”

---

#### Prompt 4 — Python / REST version

> “Adapt this workflow for a Python-based REST or GraphQL API using pytest. Replace node setup with Python setup and run ‘pytest’ instead of ‘npm test’.”

---

### 7. Summary

* **CI/CD** automates testing and building whenever you push code.
* GitHub Actions can run tests and build your **Docker image** for GraphQL automatically.
* The pipeline is similar for both REST and GraphQL; only the tests differ.
* Codex can generate and refine your workflows, so you focus on writing good APIs, not remembering YAML syntax.

