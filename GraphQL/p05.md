# Chapter 5. Schema – the “Menu Card” of GraphQL

---

## A. Introduction

In GraphQL, the **schema** is like a **menu card** in a restaurant.
It tells you:

* What you can **ask for** (queries).
* What you can **change** (mutations).
* What **types of data** exist (Student, Course, etc.).

Everything starts from the schema.
If the schema is clear, your API is clear.

---

## B. Why this matters

As a backend developer, the schema:

* Defines what your frontend is **allowed** to request.
* Acts as a **contract** between frontend and backend.
* Makes API changes easier to **discuss** and **review**.
* Helps tools (like Codex, IDEs) to give **auto-completion** and **validation**.

No schema → no GraphQL.
Good schema → happy frontend.

---

## C. Real-life example – School menu card

Imagine a **school office**.

The “menu card” hanging on the wall says:

* You can **ask**:

  * “Give me student by ID.”
  * “Give me list of all courses.”
* You can **request changes**:

  * “Add a new student.”
  * “Enroll a student into a course.”

In GraphQL:

* “Ask” = **Query**
* “Change” = **Mutation**

So our **GraphQL schema** for a school is like that office menu card.

---

## D. Code Examples

### 1. Simple GraphQL schema for student–course system

We will define:

* Types: `Student`, `Course`
* Root types: `Query`, `Mutation`

```graphql
# This is our "menu card" (schema) for the student–course system.
# It says what data exists and what operations are allowed.

# A student in our system
type Student {
  id: ID!          # Unique ID of the student
  name: String!    # Name of the student
  email: String!   # Email address
  courses: [Course!]!  # List of courses this student is enrolled in
}

# A course in our system
type Course {
  id: ID!          # Unique ID of the course
  title: String!   # Course title
  description: String # Short description
  students: [Student!]!  # List of students in this course
}

# Read-only operations (like asking questions)
type Query {
  # Get a single student by ID
  student(id: ID!): Student

  # Get all students
  students: [Student!]!

  # Get a single course by ID
  course(id: ID!): Course

  # Get all courses
  courses: [Course!]!
}

# Write operations (like asking to change data)
type Mutation {
  # Add a new student
  addStudent(
    name: String!
    email: String!
  ): Student!

  # Add a new course
  addCourse(
    title: String!
    description: String
  ): Course!

  # Enroll an existing student into an existing course
  enrollStudent(
    studentId: ID!
    courseId: ID!
  ): Student!
}

# The full schema ties together Query and Mutation
schema {
  query: Query
  mutation: Mutation
}
```

Key ideas:

* `type Query` = **what you can read**.
* `type Mutation` = **what you can write/change**.
* `schema { query: Query, mutation: Mutation }` = **entry points**.

---

### 2. Comparing REST vs GraphQL for the same school example

**REST way**:

```http
# Get a student
GET /students/123

# Get the student's courses
GET /students/123/courses

# Add a new student
POST /students
Body: { "name": "Alice", "email": "alice@example.com" }
```

**GraphQL way** (same idea, one endpoint):

```graphql
# Read student + courses in one request
query {
  student(id: "123") {
    id
    name
    courses {
      id
      title
    }
  }
}

# Add student using mutation
mutation {
  addStudent(name: "Alice", email: "alice@example.com") {
    id
    name
    email
  }
}
```

* REST: many URLs, one operation per URL.
* GraphQL: **one URL**, many possible operations, defined by the **schema**.

---

### 3. Example resolver sketch (backend side)

Just to connect the dots, here is a **pseudo-code** (for Node.js / JS style) to show how schema connects to functions.

```js
const resolvers = {
  Query: {
    student: (parent, args, context) => {
      // args.id contains the student ID from GraphQL query
      return context.db.getStudentById(args.id);
    },
    students: (parent, args, context) => {
      return context.db.getAllStudents();
    },
    course: (parent, args, context) => {
      return context.db.getCourseById(args.id);
    },
    courses: (parent, args, context) => {
      return context.db.getAllCourses();
    },
  },
  Mutation: {
    addStudent: (parent, args, context) => {
      return context.db.createStudent(args.name, args.email);
    },
    addCourse: (parent, args, context) => {
      return context.db.createCourse(args.title, args.description);
    },
    enrollStudent: (parent, args, context) => {
      return context.db.enrollStudentInCourse(args.studentId, args.courseId);
    },
  },
  Student: {
    courses: (student, args, context) => {
      return context.db.getCoursesForStudent(student.id);
    },
  },
  Course: {
    students: (course, args, context) => {
      return context.db.getStudentsForCourse(course.id);
    },
  },
};
```

You can imagine:

* **Schema** = menu card.
* **Resolvers** = kitchen functions that prepare the requested items.

---

## E. Simple Diagram

Think of the flow like this:

```text
Client (Frontend)
        |
        v
  GraphQL Endpoint (single URL)
        |
        v
    Schema (menu card)
        |
        v
   Resolvers (waiters)
        |
        v
 Database / Microservices
```

* Client sends a **query/mutation**.
* GraphQL server checks it against the **schema**.
* Resolvers run and fetch/update data from DB or microservices.

---

## F. How to Instruct Codex to Automate This

Here are some ready-made prompts you (or your students) can copy-paste to Codex.

1. **Basic schema generation (given in your note):**

> “Generate a simple GraphQL schema for a student-course system with Query and Mutation types. Add comments in plain English.”

2. **Schema + resolvers (backend integration):**

> “Write a GraphQL schema and resolver skeleton for a student-course system. Include types Student and Course, Query for reading, and Mutation for adding students and courses. Add clear comments explaining each field and resolver in plain English.”

3. **REST to GraphQL conversion help:**

> “I have these REST endpoints:
> GET /students, GET /students/:id, POST /students, GET /courses, POST /courses.
> Suggest a GraphQL schema (types, Query, Mutation) that covers the same functionality. Add comments like you are explaining to a beginner.”

4. **Schema review and improvement:**

> “Here is my current GraphQL schema for students and courses:
>
> ```graphql
> [PASTE YOUR SCHEMA HERE]
> ```
>
> Review and improve it. Suggest better field names, add comments, and ensure Query and Mutation types are clear and simple.”

---

## G. Summary

1. A **GraphQL schema** is like a **menu card** that lists all allowed queries (reads) and mutations (writes).
2. `type Query` and `type Mutation` are the main entry points; they define what clients can **ask** and what they can **change**.
3. Codex can help you **design, generate, and improve** your schema, turning your REST thinking into a clear GraphQL “menu” for your APIs.

