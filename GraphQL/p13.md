
# Chapter 13. Connecting to a Database

---

## 1. Introduction

Until now, your GraphQL server was working with **fake in-memory lists**.  
This is useful for learning, but not for real applications.

Now we connect GraphQL resolvers to a **real database** like:

- MySQL  
- PostgreSQL  
- MongoDB  

This makes your app behave like a real system where data is stored safely and retrieved reliably.

Think of it like moving from:

- A **temporary notebook** → to  
- A **proper filing cabinet** where all records are saved permanently.

---

## 2. Why This Matters

Real applications need:

- Permanent storage  
- Ability to add, edit, delete records  
- Consistent reading of data  
- Multiple users reading and writing at the same time  

GraphQL resolvers can call any database, just like a waiter who now checks a **proper computer system** instead of a handwritten list.

Once you learn this connection flow, you can use the same pattern for any backend system.

---

## 3. Real-Life Example

Think of a college’s student information desk:

- Earlier, the staff wrote student details in a **small notebook** (in-memory list).  
- Now, the college has moved to a **database system** where every student record is saved permanently.

Resolvers now fetch data from:

- MySQL or PostgreSQL (like structured filing cabinets)  
- MongoDB (like flexible, folder-based storage)

The waiter (resolver) now checks the **official system** instead of temporary notes.

---

## 4. Code Examples

We will show:

1. SQL databases with **SQLAlchemy** (MySQL/PostgreSQL)  
2. A quick MongoDB example with **PyMongo**  
3. Rewriting resolvers to use a database instead of memory  
4. Integrating with Apollo Server (Node) or Graphene/Ariadne (Python)

---

# 4.1 SQL Example with SQLAlchemy (Python)

We will assume:

- A MySQL database named `college_db`
- Two tables: `students` and `courses`
- You are using **Graphene** for GraphQL

---

### Step 1: Install packages

```bash
pip install graphene flask flask-graphql sqlalchemy pymysql
````

`pymysql` is the MySQL driver.

---

### Step 2: Database setup (SQLAlchemy)

```python
# db.py
from sqlalchemy import create_engine, Column, String, Integer, ForeignKey
from sqlalchemy.orm import declarative_base, sessionmaker, relationship

DB_URL = "mysql+pymysql://root:password@localhost/college_db"

engine = create_engine(DB_URL, echo=True)
SessionLocal = sessionmaker(bind=engine)

Base = declarative_base()

class Student(Base):
    __tablename__ = "students"

    id = Column(String(10), primary_key=True)
    name = Column(String(100))
    email = Column(String(150))

    courses = relationship("Course", secondary="student_courses")

class Course(Base):
    __tablename__ = "courses"

    id = Column(String(10), primary_key=True)
    title = Column(String(200))
    credits = Column(Integer)

class StudentCourse(Base):
    __tablename__ = "student_courses"

    student_id = Column(String(10), ForeignKey("students.id"), primary_key=True)
    course_id  = Column(String(10), ForeignKey("courses.id"), primary_key=True)

Base.metadata.create_all(engine)
```

This builds:

* `students`
* `courses`
* `student_courses` (join table)

---

### Step 3: Graphene schema mapped to SQLAlchemy

```python
# schema.py
import graphene
from graphene_sqlalchemy import SQLAlchemyObjectType
from db import Student, Course, SessionLocal

class StudentType(SQLAlchemyObjectType):
    class Meta:
        model = Student

class CourseType(SQLAlchemyObjectType):
    class Meta:
        model = Course

class Query(graphene.ObjectType):
    students = graphene.List(StudentType)
    student = graphene.Field(StudentType, id=graphene.ID(required=True))
    courses = graphene.List(CourseType)

    def resolve_students(root, info):
        session = SessionLocal()
        return session.query(Student).all()

    def resolve_student(root, info, id):
        session = SessionLocal()
        return session.query(Student).filter_by(id=id).first()

    def resolve_courses(root, info):
        session = SessionLocal()
        return session.query(Course).all()

class AddStudent(graphene.Mutation):
    class Arguments:
        id = graphene.ID(required=True)
        name = graphene.String(required=True)
        email = graphene.String(required=True)

    student = graphene.Field(lambda: StudentType)

    def mutate(self, info, id, name, email):
        session = SessionLocal()
        new_student = Student(id=id, name=name, email=email)
        session.add(new_student)
        session.commit()
        return AddStudent(student=new_student)

class Mutation(graphene.ObjectType):
    add_student = AddStudent.Field()

schema = graphene.Schema(query=Query, mutation=Mutation)
```

Now resolvers fetch records directly from the database.

---

### Step 4: Flask server

```python
# app.py
from flask import Flask
from flask_graphql import GraphQLView
from schema import schema

app = Flask(__name__)
app.add_url_rule(
    "/graphql",
    view_func=GraphQLView.as_view("graphql", schema=schema, graphiql=True),
)

if __name__ == "__main__":
    app.run(debug=True)
```

---

# 4.2 MongoDB Example (Short)

MongoDB stores data in flexible JSON-like documents.

```bash
pip install pymongo graphene flask flask-graphql
```

```python
from pymongo import MongoClient

client = MongoClient("mongodb://localhost:27017")
db = client["college_db"]
students = db.students
```

Resolver example:

```python
def resolve_students(root, info):
    return list(students.find())
```

MongoDB is simpler, but less relational.

---

## 5. Simple Diagram

```
Client Query
    ↓
GraphQL Server
    ↓
Resolvers (waiters)
    ↓
Database (MySQL/PostgreSQL/MongoDB)
```

* Earlier the resolver checked a **list in memory**
* Now it checks **real tables in the database**

---

## 6. How to Instruct Codex

Here are prompts you can directly use.

### Prompt 1 — Convert fake resolvers to SQLAlchemy

```
Codex, convert these fake in-memory resolvers to use SQLAlchemy models 
for Student and Course with a MySQL database.

I want:
- SQLAlchemy models (Student, Course, StudentCourse)
- session-based resolvers
- updated Query and Mutation resolvers
- Graphene schema or Ariadne schema, whichever is easier
- clear imports and file structure
```

### Prompt 2 — Add CRUD operations

```
Codex, add create, update, and delete mutations for Student and Course 
using SQLAlchemy sessions. Keep the example simple and readable.
```

### Prompt 3 — Switch from MySQL to PostgreSQL

```
Codex, modify the SQLAlchemy connection string from MySQL to PostgreSQL 
and adjust any code needed. Use async SQLAlchemy if possible.
```

### Prompt 4 — MongoDB version

```
Codex, rewrite these resolvers to use MongoDB (PyMongo), including 
find(), insert_one(), and update_one() operations. Keep the schema the same.
```

---

## 7. Summary

1. Resolvers now connect to a **real database** instead of in-memory lists.
2. You learned SQLAlchemy example mappings for Student and Course.
3. You saw how CRUD operations work in GraphQL using a database.
4. Codex can convert your in-memory code into full database-backed code easily.

---

```
```

