# Chapter 39. N+1 Problem (Simple Grocery Example)

---

### 1. Introduction

The **N+1 problem** is about **too many small database calls**.
In GraphQL, this can happen very easily if we are not careful with resolvers.

* You first run **1 query** to get a list of records (the “+1”).
* Then, for each record in that list, you run **another query** (the “N”).
* Total: **N+1 database calls** instead of **1 or 2** big calls.

This makes your app slow, especially when the list grows.

---

### 2. Why this matters

As a backend developer, you care about:

* **Speed** – fewer DB calls = faster response.
* **Scalability** – same code should work when you have 10 items or 10,000 items.
* **Cost** – too many DB hits increase load on your database server.

GraphQL gives you flexible queries from the frontend.
But if resolvers are written in a naive way, you may create N+1 without noticing.

---

### 3. Real-life grocery story

Imagine an **online grocery store**.

* You have a page that shows a **list of grocery items**.
* For each item, you also show its **category** (e.g., “Fruits”, “Vegetables”, “Dairy”).

In plain words, the frontend asks:

> “Give me all grocery items, and for each item, also give me its category details.”

If your GraphQL server:

1. First asks the database:
   “Give me all grocery items” → 1 DB call.
2. Then, for each item in that list, asks again:
   “Give me the category for this item” → 1 DB call *per item*.

If there are **100 items**, you now have **1 + 100 = 101 DB queries**.
This is the **N+1 problem**.

Better way:

* First get all grocery items (1 call).
* Collect all unique `categoryId`s.
* Get all categories in **one ‘IN’ query** (1 call).
* Now you have **2 DB calls total**, not 101.

---

### 4. Code Examples (Bad vs Good)

We’ll use a simple Node.js + Apollo Server style in JavaScript.
Assume we have a fake `db` layer.

#### 4.1 Simple GraphQL schema

```graphql
# schema.graphql
type Category {
  id: ID!
  name: String!
}

type GroceryItem {
  id: ID!
  name: String!
  category: Category!
}

type Query {
  groceryItems: [GroceryItem!]!
}
```

Sample GraphQL query:

```graphql
query {
  groceryItems {
    id
    name
    category {
      id
      name
    }
  }
}
```

---

#### 4.2 BAD resolvers – with N+1 problem

```js
// badResolvers.js
const resolvers = {
  Query: {
    groceryItems: async () => {
      // 1 DB call: get all items
      return db.groceryItems.findAll(); 
    },
  },

  GroceryItem: {
    category: async (parent) => {
      // ❌ N DB calls: one per item
      // parent.categoryId is used to fetch category each time
      return db.categories.findById(parent.categoryId);
    },
  },
};

module.exports = resolvers;
```

What happens:

* `groceryItems` → 1 DB call.
* For each item in the list, `category` resolver runs separately → N DB calls.
* Total: **N+1 calls**.

---

#### 4.3 GOOD resolvers – batch load categories (simple version)

One simple improvement is to fetch categories **in one shot**.

A common pattern is to use something like **DataLoader**,
but we can also show a very simple manual batching idea.

```js
// goodResolvers.js
const resolvers = {
  Query: {
    groceryItems: async () => {
      // 1 DB call: get all items
      return db.groceryItems.findAll();
    },
  },

  GroceryItem: {
    category: async (parent, _args, context) => {
      // Use a map of categories in context
      // so we don't hit DB for each item.
      if (!context.categoryById) {
        // First time: preload all categories used in this request

        // Collect all categoryIds from already fetched items
        const allItems = context.groceryItemsCache;

        const categoryIds = [
          ...new Set(allItems.map((item) => item.categoryId)),
        ];

        // 1 DB call: get all categories in one go
        const categories = await db.categories.findByIds(categoryIds);

        // Build a map { id: category }
        context.categoryById = new Map();
        for (const cat of categories) {
          context.categoryById.set(cat.id, cat);
        }
      }

      // Now just read from the map (no DB call)
      return context.categoryById.get(parent.categoryId);
    },
  },
};

module.exports = resolvers;
```

Plus, in your Apollo Server setup, you’d pass and fill the context:

```js
// server.js (simplified idea)
const server = new ApolloServer({
  typeDefs,
  resolvers,
  context: async () => {
    const groceryItems = await db.groceryItems.findAll();
    return {
      groceryItemsCache: groceryItems, // cached list for this request
    };
  },
});
```

Now:

* DB call 1: `findAll groceryItems` (inside `context`).
* DB call 2: `findByIds categories` (inside first `category` resolver run).
* After that, **no more DB calls** for categories.
* Total: **2 DB calls**, no matter how many items.

> In real apps, you’d use **DataLoader** or an ORM that can do **joins**.
> The idea is the same: **batch requests** instead of per-item requests.

---

#### 4.4 REST vs GraphQL view

**REST example** for same grocery screen:

```http
GET /api/grocery-items            # list items
GET /api/categories?ids=1,2,3,4   # second call for all categories
```

**GraphQL example**:

```graphql
query {
  groceryItems {
    id
    name
    category {
      id
      name
    }
  }
}
```

* REST makes **2 HTTP calls** but **each** is efficient.
* GraphQL makes **1 HTTP call**, but inside that call you must **avoid N+1 DB calls** by writing smart resolvers.

So GraphQL is not automatically fast.
Your resolver and DB access pattern matter a lot.

---

### 5. Simple Diagram

**BAD (N+1) case**

```text
Client GraphQL Query
        |
        v
GraphQL Server
   |       \
   |        \__ GroceryItem.category resolver (runs N times)
   v
DB: 1 query for all items
DB: N queries for categories
Total: 1 + N calls
```

**GOOD (batched) case**

```text
Client GraphQL Query
        |
        v
GraphQL Server
   |            \
   |             \__ GroceryItem.category resolver (batched)
   v
DB: 1 query for all items
DB: 1 query for all needed categories (IN clause)
Total: 2 calls
```

---

### 6. How to Instruct Codex to Automate This

You can use Codex as your assistant to **explain**, **detect**, and **fix** N+1 issues.

Copy–paste style prompts:

1. **Explain N+1 and show examples**

> **Prompt 1**
> “Explain the N+1 problem with GraphQL using a grocery example, then show bad vs good resolver code.”

2. **Convert bad resolvers to good resolvers**

> **Prompt 2**
> “Here is my GraphQL schema and resolvers for groceryItems and category. Please check if there is an N+1 problem and rewrite the resolvers to batch category loading using DataLoader in Node.js.”

3. **Show SQL-based batching**

> **Prompt 3**
> “Generate an example where a GraphQL query for grocery items causes N+1 SQL queries. Then show how to fix it using one JOIN query or one IN (…) query instead.”

4. **Help with other stacks**

> **Prompt 4**
> “I’m using Python with Graphene and SQLAlchemy for a grocery app. Show how N+1 can happen when resolving item.category and then show a better resolver using eager loading.”

---

### 7. Summary

1. The **N+1 problem** happens when you first fetch a list (1 query) and then fetch related data **per item** (N more queries).
2. In a grocery GraphQL API, naive resolvers can easily make **hundreds of DB calls** just to get categories for grocery items.
3. The fix is to **batch** your data loading (e.g., DataLoader, joins, IN queries) so that you use **1–2 efficient queries** instead of N+1.

