# Chapter 34. Common Beginner Mistakes

*Overloading root Query, leaking DB fields, and other pitfalls*

---

### 1. Introduction – Small mistakes that cause big trouble

When beginners start writing GraphQL schemas, they often make mistakes that look small but create **confusing APIs**, **performance problems**, and **security risks**.

These mistakes come from treating GraphQL like REST, or exposing database tables directly, or putting everything in one place.

Think of it like a new receptionist who keeps all files on one desk, exposes confidential records, or mixes patient and doctor information in the same notebook.

A little awareness fixes most issues.

---

### 2. Why this matters

Good schema design makes life easier for:

* Frontend developers
* Mobile teams
* Backend developers
* Future maintainers

Bad schema design causes:

* Hard-to-read APIs
* Slow responses
* Tight coupling with database structure
* Security leaks (showing internal fields accidentally)

Understanding these mistakes helps you build **clean, safe, and scalable** GraphQL backends.

---

### 3. Real-life example – Clinic app mistakes

Imagine a clinic system where a beginner exposes:

* patient table fields like `passwordHash`
* raw database column names
* dozens of queries in the root `Query` type
* deeply nested fields that cause huge responses

This is like giving patients access to internal hospital files.
We need simple, clean, safe structure.

---

### 4. Code Examples — 10 Common Beginner Mistakes

Below are **10 mistakes** with small schema examples.

---

### **1. Putting EVERYTHING in root Query**

**Mistake:**

```graphql
type Query {
  patients: [Patient!]
  doctors: [Doctor!]
  invoices: [Invoice!]
  medicines: [Medicine!]
  getAllAppointments: [Appointment!]
  getAllVisits: [Visit!]
  getAllLabTests: [LabTest!]
  # ...20 more fields
}
```

Why wrong:
Root Query becomes a **dumping ground**. Hard to maintain.

Fix:
Group by feature, use `extend type Query` in modules.

---

### **2. Exposing raw database columns**

**Mistake:**

```graphql
type Patient {
  id: ID!
  full_name: String
  dob: String
  ph_no: String
  created_ts: String
  updated_ts: String
  password_hash: String   # dangerous!
}
```

Why wrong:
Schema looks like a DB table. Also leaks sensitive fields.

Fix:
Use clean API names, hide internal fields.

---

### **3. Using vague or inconsistent names**

**Mistake:**

```graphql
type Patient {
  nm: String
  ph: String
  dob_value: String
}
```

Why wrong:
Names like `nm` and `ph` force developers to guess.

Fix:
Use clear, readable names: `fullName`, `phoneNumber`.

---

### **4. Making fields non-null when they should be optional**

**Mistake:**

```graphql
type Patient {
  id: ID!
  email: String!   # not every patient has email
}
```

Why wrong:
Backend must always return a value → errors if missing.

Fix:
Use `email: String`.

---

### **5. Exposing huge nested lists accidentally**

**Mistake:**

```graphql
type Doctor {
  id: ID!
  fullName: String!
  appointments: [Appointment!]!  # may contain thousands
}
```

Why wrong:
Querying a doctor loads ALL appointments → slow.

Fix:
Use pagination:

```graphql
appointments(limit: Int, offset: Int): [Appointment!]
```

---

### **6. Mutations that return only “Boolean”**

**Mistake:**

```graphql
type Mutation {
  createPatient(input: CreatePatientInput!): Boolean!
}
```

Why wrong:
Frontend needs the newly created record.

Fix:

```graphql
createPatient(input: CreatePatientInput!): Patient!
```

---

### **7. Avoiding input types and stuffing arguments directly**

**Mistake:**

```graphql
updatePatient(
  id: ID!
  fullName: String
  phoneNumber: String
  gender: String
  age: Int
): Patient
```

Why wrong:
Hard to manage, not scalable.

Fix:

```graphql
updatePatient(id: ID!, input: UpdatePatientInput!): Patient!
```

---

### **8. Returning arrays without clear limits**

**Mistake:**

```graphql
query {
  patients {
    id
    fullName
  }
}
```

Why wrong:
If there are 50,000 patients, this kills performance.

Fix:

```graphql
patients(limit: Int = 20, offset: Int = 0): [Patient!]
```

---

### **9. Mixing business logic in GraphQL schema**

**Mistake:**

```graphql
type Appointment {
  id: ID!
  appointmentStatus: String! # status string from business logic
}
```

Status might actually come from business rules, not raw data.

Better:

```graphql
enum AppointmentStatus {
  BOOKED
  CANCELLED
  COMPLETED
}
```

Enums reduce errors and clarify allowed values.

---

### **10. Ignoring schema modularization**

**Mistake:**

```graphql
# One gigantic schema file with 1000+ lines
type Patient { ... }
type Doctor { ... }
type Appointment { ... }
type Invoice { ... }
type Medicine { ... }
```

Why wrong:
Hard to navigate, maintain, and scale.

Fix:
Split into folders:

```text
patient/
doctor/
appointment/
billing/
pharmacy/
```

---

### 5. Simple Diagram – How mistakes cause problems

```text
Bad Schema → Confusion → Wrong Queries → Slow Responses → Unmaintainable System
```

Or:

```text
Leaky DB fields → Security risk
Huge lists → Performance issues
Inconsistent names → Developer frustration
Overloaded root Query → Chaos
```

---

### 6. How to Instruct Codex to Help

You can ask Codex to scan your schema and catch mistakes.

1. **Main prompt (from your question):**

> “List 10 common mistakes beginners make in GraphQL schema design and show one small example for each.”

2. Ask Codex to **review your schema**

> “Here is my GraphQL schema. Identify mistakes such as DB field leakage, inconsistent naming, missing pagination, too many root queries, and unclear input types.”

3. Ask Codex to **suggest fixes**

> “For each mistake found, propose the best correction and rewrite the affected part cleanly.”

4. Ask Codex for **a clean, modular structure**

> “Restructure this monolithic schema into patient, doctor, appointment, billing, and pharmacy modules using extend type Query and extend type Mutation.”

5. Ask Codex for a **naming improvement pass**

> “Review this schema and propose clearer and more consistent field names, following camelCase and full-word naming.”

These prompts help beginners avoid mistakes from day one.

---

### 7. Summary

* Beginners often overload the root Query, leak DB fields, skip input types, or return huge lists.
* These mistakes create confusion, slow responses, and security issues.
* Modular schemas, clean naming, pagination, enums, and safe field exposure make the schema strong and easy to maintain.
* Codex can scan your schema, list mistakes, and even rewrite them to best practices.

