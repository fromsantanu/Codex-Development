# Chapter 35. Login & JWT with GraphQL

### 1. Simple heading

**Login & JWT in GraphQL – Getting a Token After Login**

---

### 2. Short introduction

In most apps, users must “log in” before they see private data.
In GraphQL, we usually do this with a **login mutation**.

If the email and password are correct, the server sends back a **JWT token**.
JWT means **JSON Web Token**.
You can think of it as a **signed entry pass** that the user will send with every request after login.

---

### 3. Use-case story

Think of a **clinic app**:

* Receptionist opens the app.
* They see a **Login** form: email + password.
* When they submit:

  * The app calls a **GraphQL login mutation**.
  * The server checks the user in the database.
  * If match → server creates a **JWT token**.
  * The token says: “This is user X, role: receptionist.”
* The frontend stores this token (for example, in memory or local storage).
* For every **future GraphQL request**, the frontend sends the token in the **Authorization header**.

Like entering a gated community:

* At the first gate, you show your ID.
* They give you a **gate pass**.
* For the rest of the day, you just show the **gate pass**, not your original ID again.

---

### 4. Code examples (small & clear)

We’ll use a **Node + Apollo Server** example with `jsonwebtoken`.
You can adapt it to Python or any stack later.

#### 4.1 GraphQL schema – login mutation + payload

```graphql
# schema.graphql

type User {
  id: ID!
  name: String!
  email: String!
}

type AuthPayload {
  token: String!
  user: User!
}

type Mutation {
  login(email: String!, password: String!): AuthPayload!
}
```

Explanation in simple words:

* `login` is a **mutation** because we are doing an action (login), not just reading data.
* It takes `email` and `password`.
* It returns:

  * `token`: the JWT token.
  * `user`: basic user info (so frontend can show “Welcome, Alice”).

---

#### 4.2 Example login mutation from frontend

```graphql
mutation LoginExample {
  login(email: "alice@example.com", password: "secret123") {
    token
    user {
      id
      name
      email
    }
  }
}
```

Response might look like:

```json
{
  "data": {
    "login": {
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "user": {
        "id": "1",
        "name": "Alice",
        "email": "alice@example.com"
      }
    }
  }
}
```

---

#### 4.3 Simple resolver with JWT (Node + Apollo example)

> This is just one stack. You can replace with your own (NestJS, Graphene, Ariadne, etc.).

```js
// authResolvers.js
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt'; // if you store hashed passwords

const JWT_SECRET = process.env.JWT_SECRET || 'supersecret';

export const resolvers = {
  Mutation: {
    async login(_, { email, password }, { db }) {
      // 1. Find user by email
      const user = await db.user.findUnique({ where: { email } });

      if (!user) {
        throw new Error('Invalid email or password');
      }

      // 2. Check password
      const isValid = await bcrypt.compare(password, user.passwordHash);
      if (!isValid) {
        throw new Error('Invalid email or password');
      }

      // 3. Create JWT token (only put minimal info inside)
      const token = jwt.sign(
        { userId: user.id, role: user.role },
        JWT_SECRET,
        { expiresIn: '1h' }
      );

      // 4. Return token and user
      return {
        token,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
        },
      };
    },
  },
};
```

Key ideas:

* `db.user.findUnique` → check user by email.
* `bcrypt.compare` → compare typed password with stored hashed password.
* `jwt.sign` → create token that expires in 1 hour.
* We store only what we need in the token (like `userId`, `role`).

---

#### 4.4 Using the token in later requests (frontend example)

After login, frontend code stores the token:

```js
// pseudo-code (React or plain JS)

const response = await fetch('/graphql', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    query: `
      mutation Login($email: String!, $password: String!) {
        login(email: $email, password: $password) {
          token
          user { id name email }
        }
      }
    `,
    variables: {
      email: 'alice@example.com',
      password: 'secret123',
    },
  }),
});

const result = await response.json();
const token = result.data.login.token;

// Save token somewhere (localStorage/session/in-memory)
localStorage.setItem('authToken', token);
```

For later GraphQL calls:

```js
const token = localStorage.getItem('authToken');

const res = await fetch('/graphql', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`, // important
  },
  body: JSON.stringify({
    query: `
      query Me {
        me {
          id
          name
          email
        }
      }
    `,
  }),
});
```

On the server side, a middleware will read this header, verify the token, and set `context.user`.

---

### 5. Diagram – simple view

```text
[Frontend Login Form]
        |
        | 1) login mutation (email, password)
        v
[GraphQL Server]
        |
        | 2) Check user in DB
        | 3) Create JWT token
        v
[Response: { token, user }]
        |
        | 4) Frontend stores token
        v
[Next GraphQL Requests]
        |
        | 5) Send Authorization: Bearer <token>
        v
[GraphQL Server verifies token, knows current user]
```

---

### 6. “How to instruct Codex” prompts

You can ask Codex to create or improve this setup.

1. **Basic login mutation + resolver**

> “Generate a login mutation and resolver that returns a JWT token for a user if email/password match, using [your stack]. Use a User table with id, name, email, passwordHash, and show how to sign the token with a secret.”

2. **Add middleware to read JWT and set current user**

> “Write middleware for my GraphQL server (using [your stack]) that reads Authorization: Bearer <token>, verifies the JWT, and adds currentUser to the context. Use the same secret as the login mutation.”

3. **Protect a GraphQL query**

> “Given my GraphQL schema, modify the resolver for the me query so that it throws an error if there is no currentUser in context, otherwise returns that user.”

4. **Frontend integration**

> “Generate React code that sends a GraphQL login mutation, stores the JWT token in localStorage, and then uses that token in the Authorization header for later GraphQL queries.”

---

### 7. Summary

1. **Login with GraphQL** is usually done as a **mutation** that returns a **JWT token** and basic user info.
2. The **JWT token** is like a signed entry pass; the frontend sends it in the **Authorization header** with all later requests.
3. Codex can help you **generate schema, resolvers, middleware, and frontend code** to handle login and JWT in your own stack.

