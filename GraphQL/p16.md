# Chapter 16. GraphQL as a “Single Window Counter”

---

## 1. Simple Introduction

In many systems, data comes from different places:

* One service stores **customer info**
* Another service stores **orders**
* Another service stores **payments**
* Another stores **support tickets**

If the frontend calls all these services directly, it becomes messy.

GraphQL can act like a **single window counter** — the kind you see in government offices or banks:

* You go to **one counter**
* The person at the counter talks to many departments **on your behalf**
* You receive **one clean answer**, without knowing the internal mess

GraphQL works the same way.

---

## 2. Why This Matters

Frontend developers want **simple data requests**.

Backend systems often look like:

```
Customer REST
Order REST
Payment REST
Support REST
```

Each with different URLs, formats, fields, and quirks.

GraphQL gives your frontend a **single, stable, friendly API**.

Even if backend services change, your frontend does **not** break.

This makes development faster, frontends cleaner, and systems easier to maintain.

---

## 3. Real-Life Example Story

Think of a **university help desk**.

A student wants:

* His basic profile
* His attendance
* His fee payment status
* His exam results

He doesn’t go to all departments separately.

He goes to **one counter**, says:

> “Please give me my dashboard.”

The counter staff then:

* Calls the Attendance Department
* Calls the Finance Department
* Calls the Exam Cell
* Collects the information
* Combines them into a single report
* Hands it back to the student

GraphQL plays exactly this role.

The frontend asks:

```
customerDashboard(id: "123") { ... }
```

GraphQL internally calls:

* `/customers/123`
* `/orders?customerId=123`
* `/payments?customerId=123`

Then returns one neat JSON object.

---

## 4. Code Examples — “CustomerDashboard” Query

### 4.1 GraphQL Schema

```graphql
# schema.graphql
type CustomerDashboard {
  profile: Customer!
  orders: [Order!]!
  payments: [Payment!]!
}

type Customer {
  id: ID!
  name: String!
  email: String!
}

type Order {
  id: ID!
  amount: Float!
  status: String!
}

type Payment {
  id: ID!
  method: String!
  totalPaid: Float!
}

type Query {
  customerDashboard(id: ID!): CustomerDashboard!
}
```

This hides **three separate REST services** but exposes **one** GraphQL field.

---

### 4.2 Backend REST services (assumed)

* `GET http://localhost:3001/customers/:id`
* `GET http://localhost:3002/orders?customerId=:id`
* `GET http://localhost:3003/payments?customerId=:id`

GraphQL will call all three.

---

### 4.3 Resolver Logic (Node.js Example)

```js
// resolvers.js
import fetch from 'node-fetch';

export const resolvers = {
  Query: {
    customerDashboard: async (_, { id }) => {
      // 3 REST calls in parallel
      const [customerRes, ordersRes, paymentsRes] = await Promise.all([
        fetch(`http://localhost:3001/customers/${id}`),
        fetch(`http://localhost:3002/orders?customerId=${id}`),
        fetch(`http://localhost:3003/payments?customerId=${id}`)
      ]);

      const customer = await customerRes.json();
      const orders = await ordersRes.json();
      const payments = await paymentsRes.json();

      // Return the combined result
      return {
        profile: customer,
        orders,
        payments
      };
    },
  },
};
```

Key idea:

* Frontend → just `customerDashboard`.
* GraphQL → does the heavy lifting.

---

### 4.4 Example GraphQL Query (Frontend)

```graphql
query GetDashboard {
  customerDashboard(id: "123") {
    profile {
      id
      name
      email
    }
    orders {
      id
      amount
      status
    }
    payments {
      id
      method
      totalPaid
    }
  }
}
```

One request → one JSON → no frontend complexity.

---

### 4.5 REST vs GraphQL Comparison

**REST (frontend must call multiple endpoints):**

```
GET /customers/123
GET /orders?customerId=123
GET /payments?customerId=123
```

You must join the data manually.

---

**GraphQL (frontend only calls one field):**

```
customerDashboard(id: "123")
```

Backend joins everything for you.

Just like a **single window counter**.

---

## 5. Simple Diagram

```text
         Frontend / App
                |
                v
      +-----------------------+
      |  GraphQL – One Window |
      +-----------------------+
         |        |        |
         v        v        v
   +----------+ +----------+ +-----------+
   | Customer | |  Orders  | | Payments  |
   |  REST    | |   REST   | |   REST    |
   +----------+ +----------+ +-----------+
```

GraphQL talks to all three services but shows **one face** to the client.

---

## 6. How to Instruct Codex to Automate This

Ready-to-use prompts for students:

---

### Prompt 1 — Generate Schema

> “Codex, generate a GraphQL schema defining a CustomerDashboard type that includes profile, orders, and payments fields. Add a customerDashboard(id: ID!) query that hides three separate REST services.”

---

### Prompt 2 — Generate Resolver Code

> “Codex, write an Apollo Server resolver for customerDashboard(id) that calls the following REST services in parallel: `/customers/:id`, `/orders?customerId=:id`, and `/payments?customerId=:id`. Combine all responses into one CustomerDashboard object.”

---

### Prompt 3 — Create a Full Server Example

> “Codex, generate a complete Node.js Apollo Server setup with schema.graphql, resolvers.js, and app.js to implement the CustomerDashboard gateway pattern.”

---

### Prompt 4 — Example Client Query

> “Codex, generate a sample GraphQL query that calls customerDashboard and fetches profile, orders, and payments.”

---

## 7. Summary

**1. GraphQL can act as a single-window counter**, giving clients one clean point of access.
**2. It hides many REST services behind simple GraphQL fields**, reducing frontend complexity.
**3. The CustomerDashboard pattern is powerful for dashboards, mobile apps, and microservices.

