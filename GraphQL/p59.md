
# Chapter 59. One Backend & One UI → REST Is Enough (Why Appropriate)

## 1. Introduction

Some projects are very simple:  
one backend → one frontend → one clear set of screens.  
In these cases, the data flow is straightforward, and every screen knows exactly what it needs.  

For such apps, REST works perfectly.  
You don’t need the flexibility or complexity of GraphQL.  
A fixed set of endpoints is more than enough.

---

## 2. Why REST Fits “One Backend + One UI” Projects

Think of a **small shop with one counter**.  
You don’t need different stations or advanced routing — one counter handles everything.

When your system has:

- one frontend (web/mobile)  
- one backend service  
- clear API shapes known in advance  
- simple business rules  
- fixed screens (not highly dynamic)

…REST is the simplest choice.

REST gives you:

- clean endpoints  
- predictable request/response shapes  
- very easy debugging  
- easier logging and monitoring  
- no need for schema/resolvers/query language

It keeps the project lean.

---

## 3. Real-Life Example: Employee Attendance App

Imagine a company with one attendance app:

- Employee checks in  
- Employee checks out  
- Manager sees daily attendance  
- HR downloads reports  

This is a **single UI with a single backend**.

### REST fits perfectly:

- `POST /checkin`
- `POST /checkout`
- `GET /attendance/today`
- `GET /attendance/report?month=11`

Very direct.  
Everyone understands it easily.  
No nested or complex data fetching is required.

GraphQL would only add more moving parts:

- Schema  
- Resolvers  
- Query/Mutation design  
- More layers to maintain  

Unnecessary for such a simple system.

---

## 4. Code Examples

### A. REST Endpoints (FastAPI)

```python
from fastapi import FastAPI
from pydantic import BaseModel
from datetime import datetime

app = FastAPI()

attendance_log = []

class Attendance(BaseModel):
    emp_id: int
    action: str   # "checkin" or "checkout"
    time: str

@app.post("/checkin")
def checkin(emp_id: int):
    record = Attendance(emp_id=emp_id, action="checkin", time=str(datetime.now()))
    attendance_log.append(record)
    return {"message": "Checked in"}

@app.post("/checkout")
def checkout(emp_id: int):
    record = Attendance(emp_id=emp_id, action="checkout", time=str(datetime.now()))
    attendance_log.append(record)
    return {"message": "Checked out"}

@app.get("/attendance/today")
def today_attendance():
    return attendance_log
````

Simple, direct, clean.

### B. Equivalent GraphQL (more unnecessary work)

You would need:

* type definitions
* queries
* mutations
* resolvers
* updated query/mutation clients

REST needs none of that.

---

## 5. Diagram

```
Frontend UI
   |
   |  Simple API calls (GET/POST/PUT/DELETE)
   v
REST Backend
   |
   v
Database
```

No middle layer.
No extra logic.
Straight and predictable.

---

## 6. How to Instruct Codex

Here are useful prompts for such projects:

1. **“Generate simple REST CRUD endpoints for an attendance system using FastAPI.”**

2. **“Create a NiceGUI or React UI that calls /checkin, /checkout, and /attendance/today.”**

3. **“Generate clean request/response examples for this REST API so frontend and backend follow the same contract.”**

4. **“Write a small test script using Python requests to verify all REST endpoints work correctly.”**

---

## 7. Summary

1. When you have **one frontend and one backend**, REST gives the cleanest and simplest structure.
2. You don’t need GraphQL’s extra layers unless you have complex or highly flexible data needs.
3. REST keeps your project lightweight, easy to maintain, and easy to teach to students.

---

