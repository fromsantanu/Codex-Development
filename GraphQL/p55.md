# 55. Analytics Dashboard Combining 3 Microservices

### 1. Introduction

In this chapter, we build an **Analytics Dashboard** that talks to **three different REST microservices**:

* **Sales service** – sales numbers
* **Inventory service** – stock levels
* **Customer service** – customer data

We will:

* Design a **GraphQL gateway** in front of these 3 services
* Call the REST services **from GraphQL resolvers**
* Build a **React dashboard page** that uses this GraphQL gateway

Think of GraphQL here as a **single front desk** that talks to three separate back offices.

---

### 2. Why this matters

In real systems:

* Different teams build different services: **sales**, **inventory**, **customers**
* Frontend wants **one clean API** for dashboards

Without GraphQL, the frontend must:

* Call `/sales/summary`
* Call `/inventory/low-stock`
* Call `/customers/active`

Then **merge the data** in the UI code.

With a **GraphQL gateway**, frontend does **one query**:

```graphql
query {
  analyticsDashboard {
    totalSalesToday
    lowStockProducts {
      name
      currentStock
    }
    topCustomers {
      name
      totalSpent
    }
  }
}
```

Backend (GraphQL gateway) talks to the 3 REST services and returns **one combined response**.

This keeps the **frontend simple** and the **backend microservices independent**.

---

### 3. Use-case story (real-life example)

Imagine a **shop owner** with:

* A **sales service** that knows all bills
* An **inventory service** that tracks items in the warehouse
* A **customer service** that tracks who is buying often

The owner wants **one dashboard**:

* “How much did we sell today?”
* “Which products are about to go out of stock?”
* “Who are my top customers this month?”

The GraphQL gateway:

* Calls all three REST services
* Combines results
* Gives the frontend exactly what it needs

So the owner sees everything in **one screen**.

---

### 4. Code Examples

We’ll use:

* **Node.js + Apollo Server** for the GraphQL gateway
* **fetch / axios** inside resolvers to call REST services
* **React** for the dashboard UI

Assume the REST microservices:

* Sales: `http://sales-service.local`
* Inventory: `http://inventory-service.local`
* Customers: `http://customers-service.local`

#### 4.1 GraphQL Schema (Gateway)

```graphql
# analytics-gateway.graphql

type LowStockProduct {
  id: ID!
  name: String!
  currentStock: Int!
}

type TopCustomer {
  id: ID!
  name: String!
  totalSpent: Float!
}

type AnalyticsDashboard {
  totalSalesToday: Float!
  totalSalesThisMonth: Float!
  lowStockProducts: [LowStockProduct!]!
  topCustomers: [TopCustomer!]!
}

type Query {
  analyticsDashboard: AnalyticsDashboard!
}
```

**In simple words:**

* `AnalyticsDashboard` is the **combined view**.
* It **does not store data itself**.
* It **pulls data** from 3 REST services via resolvers.

---

#### 4.2 Resolvers Calling REST Microservices

We’ll use `node-fetch` (or you can use `axios`).

```js
// resolvers.js
const fetch = require("node-fetch");

const SALES_URL = "http://sales-service.local";
const INVENTORY_URL = "http://inventory-service.local";
const CUSTOMERS_URL = "http://customers-service.local";

async function getSalesSummary() {
  const res = await fetch(`${SALES_URL}/summary/today-and-month`);
  return res.json();
  // Example response:
  // { totalSalesToday: 1234.5, totalSalesThisMonth: 56789.0 }
}

async function getLowStockProducts() {
  const res = await fetch(`${INVENTORY_URL}/low-stock`);
  return res.json();
  // Example: [{ id, name, currentStock }, ...]
}

async function getTopCustomers() {
  const res = await fetch(`${CUSTOMERS_URL}/top-customers?limit=5`);
  return res.json();
  // Example: [{ id, name, totalSpent }, ...]
}

const resolvers = {
  Query: {
    async analyticsDashboard() {
      // Call 3 services in parallel
      const [salesSummary, lowStock, topCust] = await Promise.all([
        getSalesSummary(),
        getLowStockProducts(),
        getTopCustomers(),
      ]);

      return {
        totalSalesToday: salesSummary.totalSalesToday,
        totalSalesThisMonth: salesSummary.totalSalesThisMonth,
        lowStockProducts: lowStock,
        topCustomers: topCust,
      };
    },
  },
};

module.exports = resolvers;
```

**Key ideas in simple words:**

* GraphQL gateway **does not own** the business logic.
* It just **asks** each microservice, then **repackages** their answers into the GraphQL shape.

---

### 4.3 React Analytics Dashboard Page

The frontend does **one GraphQL query** to the gateway.

#### 4.3.1 Query String

```js
// analyticsQueries.js
export const ANALYTICS_DASHBOARD_QUERY = `
  query {
    analyticsDashboard {
      totalSalesToday
      totalSalesThisMonth
      lowStockProducts {
        id
        name
        currentStock
      }
      topCustomers {
        id
        name
        totalSpent
      }
    }
  }
`;
```

#### 4.3.2 Dashboard Page (React)

```jsx
// AnalyticsDashboardPage.jsx
import React, { useEffect, useState } from "react";
import { ANALYTICS_DASHBOARD_QUERY } from "./analyticsQueries";

export function AnalyticsDashboardPage() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  useEffect(() => {
    async function load() {
      try {
        const res = await fetch("http://localhost:4000/graphql", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: ANALYTICS_DASHBOARD_QUERY,
          }),
        });

        const json = await res.json();

        if (json.errors) {
          setError(json.errors[0].message);
        } else {
          setData(json.data.analyticsDashboard);
        }
      } catch (err) {
        setError("Could not load analytics dashboard");
      } finally {
        setLoading(false);
      }
    }

    load();
  }, []);

  if (loading) return <div>Loading analytics…</div>;
  if (error) return <div>Error: {error}</div>;
  if (!data) return <div>No data.</div>;

  return (
    <div style={{ padding: "1rem" }}>
      <h1>Business Analytics Dashboard</h1>

      {/* Top Cards */}
      <div style={{ display: "flex", gap: "1rem", marginBottom: "1.5rem" }}>
        <div style={{ border: "1px solid #ccc", padding: "1rem", flex: 1 }}>
          <h3>Sales Today</h3>
          <p>{data.totalSalesToday}</p>
        </div>
        <div style={{ border: "1px solid #ccc", padding: "1rem", flex: 1 }}>
          <h3>Sales This Month</h3>
          <p>{data.totalSalesThisMonth}</p>
        </div>
      </div>

      {/* Low Stock Products */}
      <section style={{ marginBottom: "1.5rem" }}>
        <h2>Low Stock Products</h2>
        {data.lowStockProducts.length === 0 ? (
          <p>All good, no low stock items.</p>
        ) : (
          <table border="1" cellPadding="4">
            <thead>
              <tr>
                <th>Product</th>
                <th>Current Stock</th>
              </tr>
            </thead>
            <tbody>
              {data.lowStockProducts.map((p) => (
                <tr key={p.id}>
                  <td>{p.name}</td>
                  <td>{p.currentStock}</td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
      </section>

      {/* Top Customers */}
      <section>
        <h2>Top Customers</h2>
        {data.topCustomers.length === 0 ? (
          <p>No customers yet.</p>
        ) : (
          <table border="1" cellPadding="4">
            <thead>
              <tr>
                <th>Name</th>
                <th>Total Spent</th>
              </tr>
            </thead>
            <tbody>
              {data.topCustomers.map((c) => (
                <tr key={c.id}>
                  <td>{c.name}</td>
                  <td>{c.totalSpent}</td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
      </section>
    </div>
  );
}
```

**In simple words:**

* UI makes **one GraphQL request**.
* It shows **two number cards**, a **low stock table**, and a **top customers table**.
* No need for the UI to know how many REST services exist.

---

### 5. Simple Diagram

```text
        [React Analytics Dashboard]
                     |
              GraphQL Query:
      analyticsDashboard { ... }
                     |
             [GraphQL Gateway]
         (Apollo / other server)
      /           |           \
     /            |            \
[Sales Service] [Inventory] [Customer Service]
  /summary       /low-stock   /top-customers
```

Steps:

1. React sends `analyticsDashboard` query to GraphQL gateway.
2. Gateway calls:

   * Sales REST API for totals
   * Inventory REST API for low stock
   * Customer REST API for top customers
3. Gateway merges all responses into one `AnalyticsDashboard` object.
4. React receives this and builds the dashboard.

---

### 6. How to instruct Codex to automate this

You can let Codex do most of the heavy lifting.

Main prompt from you:

> “Design a GraphQL gateway that combines 3 REST microservices (sales, inventory, customers) and generate a dashboard page using it.”

More detailed prompts:

1. **Gateway design:**

   > “Using Node.js and Apollo Server, create a GraphQL gateway schema and resolvers that call three REST endpoints: /summary/today-and-month from the sales service, /low-stock from the inventory service, and /top-customers from the customer service. Combine them into a single analyticsDashboard query.”

2. **React dashboard UI:**

   > “Generate a React page called AnalyticsDashboardPage that calls the analyticsDashboard GraphQL query and displays sales numbers, a low stock table, and a top customers table. Use fetch and simple inline styles.”

3. **Error handling + loading:**

   > “Improve this AnalyticsDashboardPage component by adding clear loading text, user-friendly error messages, and safe handling when any list is empty.”

4. **NiceGUI variant (optional):**

   > “Create a NiceGUI app in Python that calls the analyticsDashboard GraphQL endpoint and shows the same information in cards and tables.”

---

### 7. Summary

1. A **GraphQL gateway** can sit in front of **multiple REST microservices** and expose **one clean API** for dashboards.
2. The `analyticsDashboard` query combines data from **sales**, **inventory**, and **customer** services into one response.
3. A single **React dashboard** page can then show rich analytics with **one GraphQL call**, keeping frontend logic simple and separating it from backend microservice complexity.
