````md
# Chapter 12. Resolvers — Mapping Schema to Data

---

## 1. Introduction

In GraphQL, the **schema** is only the **menu card**.  
It tells *what* is available, but not *how* to get it.

The **resolver** is the **waiter**:

- It reads what the customer asked for (the query).
- It goes to the “kitchen” (database, API, microservice).
- It brings back the correct data.

In this chapter, we will:

- Understand what resolvers do.
- Write simple resolvers using **fake in-memory lists**.
- See how this fits with the `Student` and `Course` schema.

---

## 2. Why This Matters

Without resolvers:

- Your GraphQL server knows the menu (schema),  
  but **cannot actually serve any dish** (no data).

Resolvers:

- Connect your schema to **real data sources**.
- Can call:
  - Databases (PostgreSQL, MySQL, MongoDB, etc.).
  - Other microservices (REST APIs).
  - Even simple in-memory arrays for quick testing.

For early development, using a **fake list in memory** is very helpful.  
You can test your schema and queries *before* wiring real databases.

---

## 3. Real-Life Example

Think of a **university help desk**:

- The **schema** defines:
  - “You can ask for student details.”
  - “You can ask for course details.”
- The **resolver** is like the **person at the desk** who:
  - Looks into files or the computer.
  - Finds the right student or course.
  - Gives you the information.

If the “files” are not ready yet,  
they might use a **temporary notebook** with sample entries.  
That is like our **in-memory list** for testing.

---

## 4. Code Examples

We will:

1. Use a simple `Student` / `Course` schema.
2. Add **in-memory lists**.
3. Write resolvers to:
   - Get all students
   - Get one student by ID

We will show Node (Apollo) and a short Python example.

---

### 4.1 Schema Reminder (SDL)

```graphql
# schema.graphql (reminder)

type Student {
  id: ID!
  name: String!
  email: String!
  courses: [Course!]!
}

type Course {
  id: ID!
  title: String!
  credits: Int!
}

type Query {
  student(id: ID!): Student
  students: [Student!]!
  courses: [Course!]!
}
````

---

### 4.2 Node.js (Apollo Server) with In-Memory Data

#### Step 1: Fake data

```js
// data.js
const students = [
  { id: "1", name: "Alice", email: "alice@example.com", courseIds: ["101", "102"] },
  { id: "2", name: "Bob",   email: "bob@example.com",   courseIds: ["101"] },
];

const courses = [
  { id: "101", title: "Math 101",      credits: 3 },
  { id: "102", title: "Computer 101",  credits: 4 },
];

module.exports = { students, courses };
```

#### Step 2: Resolvers = Waiters

```js
// resolvers.js
const { students, courses } = require("./data");

const resolvers = {
  Query: {
    // Get all students
    students: () => {
      return students;
    },

    // Get one student by ID
    student: (_, args) => {
      const { id } = args;
      return students.find((s) => s.id === id) || null;
    },

    // Get all courses
    courses: () => {
      return courses;
    },
  },

  // Field-level resolver for Student.courses
  Student: {
    courses: (parent) => {
      // parent = current student
      const courseIds = parent.courseIds || [];
      return courses.filter((c) => courseIds.includes(c.id));
    },
  },
};

module.exports = { resolvers };
```

Key points:

* `Query.students` and `Query.student` map the **query** to our **in-memory list**.
* `Student.courses` resolver uses the student’s `courseIds`
  to return the list of full `Course` objects.
* This is like:

  * Query = what the customer asks.
  * Resolver = waiter who looks into the notebook (`students`, `courses`) and returns data.

#### Step 3: Using these resolvers in the server

```js
// index.js
const { ApolloServer } = require('@apollo/server');
const { expressMiddleware } = require('@apollo/server/express4');
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const fs = require("fs");
const path = require("path");
const { resolvers } = require("./resolvers");

const typeDefs = fs.readFileSync(path.join(__dirname, "schema.graphql"), "utf8");

async function start() {
  const app = express();
  const server = new ApolloServer({ typeDefs, resolvers });

  await server.start();
  app.use('/graphql', cors(), bodyParser.json(), expressMiddleware(server));

  app.listen(4000, () => console.log("GraphQL server at http://localhost:4000/graphql"));
}

start();
```

Now you can run:

```bash
node index.js
```

Then test this query in the GraphQL UI:

```graphql
query {
  students {
    id
    name
    email
    courses {
      id
      title
    }
  }
}
```

---

### 4.3 Python (Graphene) with In-Memory Data (Short Example)

```python
# data.py
students = [
    {"id": "1", "name": "Alice", "email": "alice@example.com"},
    {"id": "2", "name": "Bob",   "email": "bob@example.com"},
]
```

```python
# schema.py
import graphene
from data import students

class Student(graphene.ObjectType):
    id = graphene.ID()
    name = graphene.String()
    email = graphene.String()

class Query(graphene.ObjectType):
    students = graphene.List(Student)
    student = graphene.Field(Student, id=graphene.ID(required=True))

    def resolve_students(root, info):
        return students

    def resolve_student(root, info, id):
        for s in students:
            if s["id"] == id:
                return s
        return None

schema = graphene.Schema(query=Query)
```

This is the same idea:

* `resolve_students` returns the full list.
* `resolve_student` finds one by ID.

You can plug `schema` into a Flask or Django server to expose `/graphql`.

---

## 5. Simple Diagram

```text
Client Query
   |
   v
 GraphQL Server
   |
   v
+--------------------------+
|       Resolvers          |
|  (like waiters)          |
|                          |
|  Query.students  ─→ in-memory list
|  Query.student   ─→ in-memory list
|  Student.courses ─→ in-memory list
+--------------------------+
```

Later, the in-memory list can be replaced by:

* Database calls
* REST API calls
* Microservice calls

The **resolver signatures stay similar**,
only the internal logic changes.

---

## 6. How to Instruct Codex

You can ask Codex to write resolvers for you.

### Prompt 1 (exact one you asked for)

```text
Codex, generate resolver functions for the student queries using a fake 
in-memory list so I can test quickly.

Entities:
- Student(id, name, email, courseIds)
- Course(id, title, credits)

GraphQL schema:
- Query.students: list all students
- Query.student(id): get one student by id
- Query.courses: list all courses
- Student.courses: list courses for a given student

Use Node.js, Apollo Server style resolvers and export them from resolvers.js.
Also create a simple data.js with sample students and courses.
```

### Prompt 2 (Python version)

```text
Codex, write Graphene (Python) resolvers for a Student type and Query type 
using an in-memory list of students.

Requirements:
- students: [Student!]!
- student(id: ID!): Student

Use a list of dicts as the fake database.
Return only the Python code.
```

### Prompt 3 (Refactor later)

```text
Codex, here is my current resolver code using in-memory lists. 
Refactor it so that the data access part is moved into a separate module 
(e.g., student_repository.js), and resolvers only call those functions.
```

---

## 7. Summary

1. **Resolvers** are like **waiters** who map GraphQL queries to real data.
2. You can start with **fake in-memory lists** to test your schema and queries quickly.
3. Later, you can swap the in-memory logic with **database or microservice calls**, keeping the same resolver structure.

---

```
```

