# Chapter 29. When Simple `fetch()` Is Enough

---

### 1. Simple introduction

Apollo Client is powerful, but you **don’t always need it**.

For many small projects, demos, student exercises, or quick prototypes, a simple:

```js
fetch('/graphql', {
  method: 'POST',
  body: JSON.stringify({ query: "...", variables: {...} }),
})
```

is completely **enough**.

Think of it like this:

* Apollo Client = a **full toolbox** with many tools.
* `fetch()` = a **simple screwdriver**.

If all you need is to tighten one small bolt, you don’t need the entire toolbox.

---

### 2. Why this matters

Sometimes you want:

* A quick demo
* A small project
* A simple page that just loads a list
* A “one-off” script
* To learn GraphQL with minimal setup
* Very low bundle size (no extra libraries)

In these cases, installing Apollo Client may be **unnecessary overhead**.

Using plain `fetch()`:

* No installation
* No cache layer
* No special hooks
* Straightforward to understand
* Perfect for simple or short-lived UIs

---

### 3. Real-life example (small shop demo)

Imagine you’re building a **small product page** for a class demo:

* One screen that shows a product list
* No mutations
* No caching
* No routing
* No complex state

Using Apollo Client would be like using a **delivery truck** to carry a **single packet**.

Using `fetch()` is simple:

* Make one POST request
* Get the list
* Render it

Done.

---

### 4. Minimal code example (React + fetch + GraphQL)

This example shows:

* How to call a GraphQL endpoint using only `fetch()`
* How to pass a query and variables
* How to show the response

#### 4.1 GraphQL Query (as a plain string)

```js
const GET_PRODUCTS = `
  query {
    products {
      id
      name
      price
    }
  }
`;
```

#### 4.2 React component using `fetch()`

```jsx
import React, { useEffect, useState } from 'react';

export function ProductsPage() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function load() {
      try {
        const res = await fetch('https://example.com/graphql', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            query: `
              query {
                products {
                  id
                  name
                  price
                }
              }
            `,
          }),
        });

        const json = await res.json();

        if (json.errors) {
          throw new Error(json.errors[0].message);
        }

        setProducts(json.data.products);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    load();
  }, []);

  if (loading) return <p>Loading products...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <>
      <h2>Products (using fetch)</h2>
      <ul>
        {products.map((p) => (
          <li key={p.id}>
            {p.name} – ${p.price}
          </li>
        ))}
      </ul>
    </>
  );
}
```

This is all you need for small GraphQL usage.

---

### 5. REST vs GraphQL angle

Using fetch with GraphQL is similar to using fetch with REST.

REST example:

```js
const res = await fetch('/api/products');
```

GraphQL example:

```js
const res = await fetch('/graphql', {
  method: 'POST',
  body: JSON.stringify({ query: GET_PRODUCTS }),
});
```

The main difference:

* REST → endpoint already defines what data you get
* GraphQL → you specify what data you want

But the fetch style is the same.

---

### 6. When `fetch()` is enough (simple checklist)

Use **only fetch** when:

* You have **a few pages**
* You do **simple queries**
* You don’t need a **cache**
* You don’t do many mutations
* You don’t reuse queries across many components
* You don’t need real-time subscriptions
* You want minimal setup
* You just want to **learn GraphQL basics**

Use Apollo Client when:

* You need **cache**
* You need **many queries** across many pages
* You have **mutations and cache updates**
* You want `useQuery` / `useMutation` hooks
* You need **error handling**, **pagination**, **refetching**, **normalization**, etc.
* You want consistency across a large app

Simple rule of thumb:

> Small app → fetch
> Medium/large app → Apollo Client

---

### 7. Simple diagram

```text
React Component
       |
       | fetch('/graphql')
       v
  GraphQL Server
       |
       | returns JSON
       v
React updates UI
```

No cache layer.
No Apollo Client.
Direct request → direct response.

---

### 8. How to instruct Codex to automate this

Here are ready-to-use prompts for Codex.

#### 1. Main prompt (as you requested)

> “Show a minimal example using only fetch for a GraphQL query, and explain when this is enough instead of Apollo.
> Include a React component using fetch() to call a GET_PRODUCTS GraphQL query.”

#### 2. Prompt to add variables

> “Modify the fetch-based GraphQL example to accept variables, such as product(id), and show how to pass variables in the JSON body.”

#### 3. Prompt to wrap fetch in a custom helper

> “Create a small graphqlFetch() helper function that wraps fetch('/graphql') and handles JSON parsing, errors, and headers.
> Then refactor the ProductsPage component to use graphqlFetch().”

#### 4. Prompt to turn fetch into a reusable hook

> “Create a custom React hook useGraphQLQuery(queryString, variables) that uses fetch() internally and returns {data, loading, error}.
> Use this hook to simplify the ProductsPage component.”

#### 5. Prompt to show comparison with Apollo

> “Generate a side-by-side comparison of using fetch vs Apollo Client for a simple products list page.
> Explain in plain language when fetch is enough and when Apollo is better.”

---

### 9. Summary

1. For small demos or simple apps, **plain fetch()** is more than enough to call GraphQL.
2. Fetch works well when you don’t need caching, mutations, subscriptions, or many screens.
3. Codex can help generate minimal fetch-based examples, refactor fetch into helpers or hooks, and compare fetch vs Apollo for different project sizes.

