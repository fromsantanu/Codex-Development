````md
# Chapter 14. Lists, Filters & Pagination

---

## 1. Introduction

Most real apps don’t ask for just **one** record.  
They ask for **lists**:

- List of students  
- List of courses  
- List of orders  

But we rarely want **all** records at once.  
We usually want:

- Only some rows (filtering)  
- Only a small range at a time (pagination)

In GraphQL, we can do this by adding:

- **Arguments** (e.g. `name`, `limit`, `offset`) to queries.  
- Logic in resolvers that uses these arguments.

---

## 2. Why This Matters

Without filters and pagination:

- Your `students` query may return **thousands** of records.  
- This is slow for the server and for the browser.  
- Mobile users will suffer with slow responses.

With filters and pagination:

- You can **search** by name or other fields.  
- You can load data **page by page** (like page 1, page 2…).  
- The UI becomes faster and smoother.

This is **exactly what REST APIs also do** (with `?name=...&limit=10&offset=20` etc.),  
but GraphQL lets you design it clearly in the schema itself.

---

## 3. Real-Life Example

Imagine a **college admin portal**:

- There are 10,000 students in the database.  
- The receptionist wants to find **students whose name contains “Ali”**.  
- They also want to see **10 students per page**.

You would not print **all 10,000 students** on one page.  
Instead, you show:

- Page 1: first 10 matching students  
- Page 2: next 10  
- And so on

This is **pagination**.  
The search for “Ali” is **filtering**.

---

## 4. Code Examples

We’ll:

1. Add arguments to the `students` query in the schema.  
2. Implement filtering and pagination in the resolver.  
3. Show how this looks from GraphQL vs REST.

We’ll use:

- A simple SDL schema  
- Node.js (Apollo Server) resolver example  

---

### 4.1 Schema: Add Filter & Pagination Arguments

Let’s update the `students` query.

```graphql
# schema.graphql (extended)

type Student {
  id: ID!
  name: String!
  email: String!
}

type Query {
  # Old version:
  # students: [Student!]!

  # New version with filters & pagination
  students(
    nameContains: String
    limit: Int = 10
    offset: Int = 0
  ): [Student!]!
}
````

Meaning:

* `nameContains` (optional): filter by a part of the name
* `limit` (default 10): how many students to return
* `offset` (default 0): how many students to skip before starting to return

---

### 4.2 In-Memory Resolver with Filter + Pagination (Node / Apollo)

Assume we still have an in-memory list for now:

```js
// data.js
const students = [
  { id: "1", name: "Alice Johnson", email: "alice@example.com" },
  { id: "2", name: "Bob Ali",        email: "bob@example.com"   },
  { id: "3", name: "Charlie Allen",  email: "charlie@example.com" },
  // ... more students
];

module.exports = { students };
```

Now the resolver:

```js
// resolvers.js
const { students } = require("./data");

const resolvers = {
  Query: {
    students: (_, args) => {
      const { nameContains, limit = 10, offset = 0 } = args;

      // 1. Start with all students
      let result = students;

      // 2. Filter by name if nameContains is provided
      if (nameContains && nameContains.trim() !== "") {
        const lower = nameContains.toLowerCase();
        result = result.filter((s) =>
          s.name.toLowerCase().includes(lower)
        );
      }

      // 3. Apply pagination (offset + limit)
      const paged = result.slice(offset, offset + limit);

      return paged;
    },
  },
};

module.exports = { resolvers };
```

What happens here?

1. We read arguments from `args`.
2. If `nameContains` exists, we filter by that text.
3. We use `slice(offset, offset + limit)` to pick a “page” of data.

---

### 4.3 How a Client Calls This Query

Example query from frontend:

```graphql
query {
  students(nameContains: "Ali", limit: 2, offset: 0) {
    id
    name
    email
  }
}
```

Possible result:

```json
{
  "data": {
    "students": [
      { "id": "2", "name": "Bob Ali", "email": "bob@example.com" },
      { "id": "3", "name": "Charlie Allen", "email": "charlie@example.com" }
    ]
  }
}
```

Next page (offset 2, limit 2):

```graphql
query {
  students(nameContains: "Ali", limit: 2, offset: 2) {
    id
    name
  }
}
```

---

### 4.4 REST vs GraphQL Comparison

**REST style**:

```http
GET /students?nameContains=Ali&limit=2&offset=0
```

**GraphQL style** (single endpoint `/graphql`):

```graphql
query {
  students(nameContains: "Ali", limit: 2, offset: 0) {
    id
    name
    email
  }
}
```

In both cases, you get **filtered, paginated** data.
But GraphQL lets the client choose exactly which fields to fetch.

---

### 4.5 Database Version: Filter + Pagination (SQLAlchemy – short idea)

Very short sketch for SQLAlchemy:

```python
def resolve_students(root, info, name_contains=None, limit=10, offset=0):
    session = SessionLocal()
    query = session.query(Student)

    if name_contains:
        pattern = f"%{name_contains}%"
        query = query.filter(Student.name.ilike(pattern))

    query = query.offset(offset).limit(limit)

    return query.all()
```

You can connect this to a Graphene field like:

```python
students = graphene.List(
    StudentType,
    name_contains=graphene.String(),
    limit=graphene.Int(),
    offset=graphene.Int(),
)
```

---

## 5. Simple Diagram

```text
Client
  |
  |  students(nameContains: "Ali", limit: 10, offset: 20)
  v
GraphQL Server
  |
  v
Students Resolver
  |
  |-- Filter → WHERE name LIKE '%Ali%'
  |-- Pagination → LIMIT 10 OFFSET 20
  v
Database / In-Memory List
```

---

## 6. How to Instruct Codex

Here are prompts you can use directly.

### Prompt 1 — Add filter + pagination (exact idea you gave)

```text
Codex, add filter and pagination arguments to the students query so I can 
filter by name and get results page by page.

Details:
- Query name: students
- Arguments: nameContains (String), limit (Int, default 10), offset (Int, default 0)
- Use an in-memory list of students first.
- Filter by nameContains (case-insensitive).
- Apply pagination using slice(offset, offset + limit).
- Show updated schema.graphql and resolvers.js for Node + Apollo Server.
```

### Prompt 2 — SQLAlchemy version

```text
Codex, convert these in-memory resolvers to use SQLAlchemy models for Student 
with MySQL. Keep the same students(nameContains, limit, offset) signature and 
implement filtering and pagination using ilike(), limit(), and offset().
```

### Prompt 3 — Add total count (for page count)

```text
Codex, extend the students query to return both:
- items: [Student!]!
- totalCount: Int!
so the frontend can calculate how many pages exist. 
Generate the updated schema and resolver code.
```

---

## 7. Summary

1. Lists in GraphQL often need **filters** and **pagination** to stay fast and useful.
2. You can add arguments like `nameContains`, `limit`, and `offset` to your queries.
3. Resolvers use these arguments to slice arrays or limit database queries.
4. Codex can quickly generate or refactor this pattern for both in-memory and database-backed resolvers.

---

```
```

