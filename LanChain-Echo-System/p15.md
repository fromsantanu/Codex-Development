# 15. Asking Codex to Add Features

## 1. Simple Intro

Once your first agent is running, the next step is **adding features**:

- new tools (email, search, DB access),
- new chains (summaries, classifications, reports),
- new capabilities (RAG, SQL, integrations).

You can either:

- hand‑write all the new code, or
- describe the feature to Codex and let it **generate most of the changes**, while you review and wire it into your system.

This chapter is about how to talk to Codex so it can safely extend your agentic workflow.

---

## 2. Why Backend Devs Should Learn This

As a backend developer you’re used to:

- adding new endpoints,
- integrating third‑party APIs,
- introducing new services (email, search, payments),
- evolving schemas and business logic.

With agents, feature work often means:

- adding a **new tool** (e.g. search, DB query, email draft),
- adding a **new chain** (e.g. summarize results, generate report),
- updating **prompts** so the agent knows when to use the new capability.

Codex can:

- scaffold the new tool/chain,
- update the agent wiring,
- add tests and docs,
- keep style and structure consistent.

You stay focused on **requirements and safety**; Codex handles the boilerplate.

---

## 3. Analogy: Upgrading a Restaurant Kitchen

Imagine you run a restaurant:

- At first the kitchen only has a stove and pan.
- Later you add:
  - an oven (baking),
  - a blender (smoothies),
  - a grill (BBQ).

Each new appliance:

- expands what the chef can do,
- needs clear instructions and safety rules,
- must fit into the existing workflow.

For agents:

- The **agent** = the chef.
- **Tools / chains** = kitchen appliances + recipes.
- Adding a feature = giving the chef a new appliance and a recipe for when to use it.

Codex is like the contractor who:

- installs the new appliance (code),
- updates the kitchen layout (folders, imports),
- writes a short manual (docstrings, README).

---

## 4. Key Ideas for Adding Features with Codex

1. **Describe the feature in business terms**  
   - “Add summarization tool for support tickets.”  
   - “Add search tool over our FAQ.”  
   - “Add SQL database support for reading user data.”

2. **Specify inputs and outputs**  
   - What parameters come in?  
   - What should the tool or chain return?  
   - How will your API or agent use it?

3. **Clarify safety and limits**  
   - Read‑only vs write.  
   - Max number of records.  
   - No destructive actions without human review.

4. **Ask Codex where to place code**  
   - `tools/`, `chains/`, `agents/`, `tests/`, `docs/`.  
   - Keep architecture clean as features grow.

5. **Update prompts and docstrings**  
   - The agent must know the new tool exists and when to use it.  
   - Docstrings are the tool’s “mini‑manual”.

6. **Add or update tests**  
   - New features should come with tests.  
   - Codex can scaffold them from examples.

---

## 5. Step‑by‑Step: Using Codex to Add Features

We’ll cover three common upgrades:

- summarization tool,
- search tool,
- SQL database support.

### Step 1: Add a Summarization Tool

Tell Codex:

> “Add a LangChain @tool called summarize_text(text: str) -> str\n\
>  in tools/summary_tools.py. It should use ChatOpenAI to create a\n\
>  1–2 sentence summary. Make it safe and short.”

Codex can:

- create the file,
- write the tool function,
- add the import for `ChatOpenAI`.

Then ask:

> “Register this new summarize_text tool in my main agent\n\
>  and update the system prompt so the agent knows it can\n\
>  summarize long text when asked.”

### Step 2: Add a Search Tool (e.g. FAQ Search)

Tell Codex:

> “Create a search_faq(query: str) -> list[dict] tool in tools/search_tools.py.\n\
>  For now, use an in-memory list of FAQ entries with fields id, question, answer.\n\
>  Return the top 3 matching FAQs using simple keyword matching.”

Codex will:

- create fake FAQ data,
- implement basic filtering / ranking,
- return results as a list of dicts.

Later you can ask it to:

- replace in‑memory data with a DB or vector store,
- paginate results,
- add logging and error handling.

### Step 3: Add SQL Database Support (Read‑Only)

Tell Codex:

> “Add a read-only database tool in tools/db_tools.py that\n\
>  uses SQLAlchemy to fetch a user by id. The tool should be\n\
>  get_user_by_id(user_id: int) -> dict | None. Use a fake model\n\
>  or stubbed session I can replace later.”

Codex can:

- scaffold SQLAlchemy model or stub,
- implement the query,
- return a clean dict.

Then ask:

> “Update the agent so it can:\n\
>  - call get_user_by_id when a question references a user id,\n\
>  - explain to the user when the id is not found.”

### Step 4: Update Prompts and Instructions

Whenever you add a feature, ask Codex to:

> “Update the system prompt and tool docstrings so the agent:\n\
>  - uses summarize_text for long responses,\n\
>  - uses search_faq for FAQ-style questions,\n\
>  - uses get_user_by_id when the user asks about a specific id.\n\
>  Make the rules clear and concise.”

This helps the model **choose the right tool at the right time**.

### Step 5: Add or Extend Tests

Finally, say:

> “Add pytest tests for summarize_text, search_faq, and get_user_by_id\n\
>  using small fake inputs and outputs. Keep them fast and deterministic.”

Codex can:

- write tests for each tool,
- add simple fixtures or fake data,
- show how to mock LLM calls if needed.

---

## 6. Short Code Examples

These are examples of the kind of feature code Codex can generate.

### Example 1: Summarization Tool

```python
# tools/summary_tools.py
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool


llm = ChatOpenAI(model="gpt-4.1-mini")


@tool
def summarize_text(text: str) -> str:
    """
    Summarize the given text in 1–2 short sentences.
    Keep it simple and preserve key meaning.
    """
    prompt = (
        "Summarize the following text in 1–2 short sentences:\n\n"
        f"{text}"
    )
    response = llm.invoke(prompt)
    return response.content
```

Codex can create this file from a short description of the feature.

---

### Example 2: Simple FAQ Search Tool

```python
# tools/search_tools.py
from typing import List, Dict
from langchain_core.tools import tool


FAQ_DATA: List[Dict] = [
    {"id": 1, "question": "How do I reset my password?", "answer": "Go to settings..."},
    {"id": 2, "question": "How do I update my billing info?", "answer": "Open the billing page..."},
    {"id": 3, "question": "How do I contact support?", "answer": "Email support@example.com..."},
]


@tool
def search_faq(query: str) -> List[Dict]:
    """
    Return up to 3 FAQ entries whose questions contain the query keywords.
    Simple case-insensitive substring matching over FAQ_DATA.
    """
    q = query.lower()
    matches = [faq for faq in FAQ_DATA if q in faq["question"].lower()]
    return matches[:3]
```

Later you can ask Codex to:

- replace `FAQ_DATA` with a DB or vector store call,
- add ranking or scoring,
- or paginate results.

---

### Example 3: Updating the Agent to Use New Tools

```python
# agents/support_agent.py
from typing import List

from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain.agents import AgentExecutor, create_tool_calling_agent

from tools.ticket_tools import get_ticket_by_id, draft_reply_email
from tools.summary_tools import summarize_text
from tools.search_tools import search_faq


def create_support_agent(model_name: str = "gpt-4.1-mini") -> AgentExecutor:
    llm = ChatOpenAI(model=model_name)

    tools: List = [
        get_ticket_by_id,
        draft_reply_email,
        summarize_text,
        search_faq,
    ]

    prompt = ChatPromptTemplate.from_messages([
        ("system",
         "You are a helpful support assistant.\n"
         "- Use get_ticket_by_id for questions about specific ticket IDs.\n"
         "- Use summarize_text when the user asks for a shorter version.\n"
         "- Use search_faq for common how-to questions.\n"
         "Be concise and polite."),
        ("user", "{input}")
    ])

    agent = create_tool_calling_agent(llm, tools, prompt)
    return AgentExecutor(agent=agent, tools=tools)
```

This shows how adding features usually means:

- new tools,
- updated tool list,
- improved system prompt.

Codex can make these edits for you safely and quickly.

---

## 7. How Codex Helps

Codex is particularly useful for feature work when you:

- **Describe new capabilities clearly**
  - “Add an FAQ search feature using an in-memory list now, later DB.”  
  - “Add a read-only SQL tool for user profiles.”

- **Ask for safe defaults**
  - Read‑only tools by default.  
  - Clear error messages and logging.  
  - Small, testable functions.

- **Let Codex update wiring and prompts**
  - Register tools with agents and chains.  
  - Adjust system prompts and docstrings.  
  - Keep imports and modules clean.

- **Generate and evolve tests**
  - Start with simple tests for each tool.  
  - Grow to integration tests for the full agent.

Codex becomes your **feature factory**: you decide what to build; it proposes the code.

---

## 8. Small Diagram

### Adding a New Feature with Codex

```text
Feature Idea (e.g. FAQ search)
              ↓
     Describe to Codex
              ↓
   ┌───────────────────────┐
   │  New Code from Codex  │
   │  - tools/search_tools │
   │  - agent updates      │
   │  - tests              │
   └───────────────────────┘
              ↓
     You Review & Adjust
              ↓
     Deployed Agent Feature
```

### Agent After Adding Features

```text
User → API → Support Agent
              │
              ├─ get_ticket_by_id
              ├─ draft_reply_email
              ├─ summarize_text
              └─ search_faq
                     ↓
               DB / Data / LLM
```

---

## 9. Summary

- Adding features to an agent usually means new tools, new chains, and updated prompts so the agent knows when to use them.
- Codex can generate most of the feature boilerplate: tools (summarization, search, SQL), wiring in the agent, and tests.
- You should clearly describe the feature, expected inputs/outputs, and safety requirements; Codex turns that into code.
- Updating the agent’s tool list and system prompt is key so the new feature is actually used.
- With this approach, Codex acts as your **kitchen upgrader** for agents: it installs new “appliances” (features) while you stay focused on design, safety, and business logic.

