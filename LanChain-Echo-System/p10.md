# 10. Creating Tools for Agents

## 1. Simple Intro

An **agent** is a smart assistant.  
A **tool** is something that assistant can use to **take action**:

- run Python code
- query a database
- send an email
- call an API

In LangChain, a tool is usually just a **Python function with a clear name, parameters, and docstring** that the agent is allowed to call.

---

## 2. Why Backend Devs Should Learn This

As a backend developer you already create:

- helper functions
- service classes
- repository methods
- microservice endpoints

Tools are the **same thing**, but now:

- instead of another developer calling them,
- an **AI agent** calls them when it decides they’re needed.

This lets you:

- connect the agent to **real systems** (DB, email, queues, HTTP APIs),
- keep logic in **safe, testable Python functions**,
- control **exactly** what the agent can and cannot do.

---

## 3. Analogy: Chef and Kitchen Tools

Imagine a chef in a kitchen:

- The **chef** = the agent (decides what to cook).
- The **knife, oven, blender, pan** = tools (things that do work).

If you give the chef:

- no tools → they can only talk about food.
- a knife + pan → they can actually cook.
- a huge dangerous machine → they might hurt someone if not careful.

Same with agents:

- If you give no tools, the agent can only **answer from its own knowledge**.
- If you give safe tools (DB read, email draft, calculations), it can actually **do work**.
- If you give risky tools (delete data, wire money), you must add **strong rules and checks**.

---

## 4. Key Ideas About Tools

1. **Tool = callable function**  
   - Usually a Python function decorated with `@tool`.  
   - The function signature tells LangChain what inputs it needs.

2. **Docstring = natural language spec**  
   - The docstring explains when and how to use the tool.  
   - The model reads this to decide if the tool is relevant.

3. **Narrow, focused behavior**  
   - Each tool should do **one thing well**.  
   - Example: `get_user_by_id`, `send_welcome_email`, `calculate_discount`.

4. **Safe by default**  
   - Avoid “do anything” tools like “run arbitrary shell command.”  
   - Prefer small, restricted operations.

5. **Wrap existing logic**  
   - Most of the time, you **already have** the function.  
   - You just wrap it as a tool so the agent can call it.

6. **Registered with the agent**  
   - Tools must be **passed into** the agent when you create it.  
   - If it’s not in the list, the agent can’t use it.

---

## 5. Step‑by‑Step: Building a Tool

Let’s walk through turning regular backend code into tools.

### Step 1: Identify What Should Be a Tool

Look for things your agent might need to do:

- **Calculator** logic (totals, tax, discounts).
- **Database** queries (find user, list orders).
- **Email** actions (draft welcome email, send reminder).
- **External API** calls (payment, shipping, CRM).

These are good candidates for tools.

### Step 2: Write a Clean Python Function

Make sure the function:

- has clear parameters and types,
- returns a simple, serializable value (dict, list, string, number),
- has a short docstring explaining its purpose.

### Step 3: Decorate It as a Tool

Use LangChain’s `@tool` decorator so the agent can “see” it and understand its schema.

### Step 4: Provide a Helpful Description

The docstring should answer:

- What does this do?  
- When should the agent call it?  
- What inputs does it expect?

This is like writing a **good README** for the function.

### Step 5: Register the Tool with the Agent

- Put the tools in a list (e.g. `tools = [add_two_numbers, get_user_from_db]`).
- Pass that list to the agent factory (e.g. `create_tool_calling_agent`).

### Step 6: Test the Tool Alone

First call the function **directly** in Python tests:

- Does it work?
- Are errors handled?
- Is the return value clean and small?

Only after that should you let the agent call it.

---

## 6. Short Code Examples

All examples use the LangChain `@tool` decorator.  
(You can run them in a normal Python project with LangChain installed.)

### Example 1: Simple Calculator Tool

```python
from langchain_core.tools import tool

@tool
def add_two_numbers(a: int, b: int) -> int:
    """Add two integers and return the result."""
    return a + b
```

- Clear name: `add_two_numbers`
- Typed parameters: `a`, `b`
- Short docstring: explains exactly what it does

The agent can now decide: “I need to add 3 and 5 → call `add_two_numbers`.”

---

### Example 2: Database Tool (Read‑Only)

```python
from typing import Optional
from langchain_core.tools import tool

# Imagine you inject a real DB session here in practice.

@tool
def get_user_by_id(user_id: int) -> Optional[dict]:
    """
    Look up a user by numeric ID.
    Return a dict with basic fields or null if not found.
    """
    # Example dummy data; replace with your DB call.
    fake_db = {
        1: {"id": 1, "name": "Alice", "email": "alice@example.com"},
        2: {"id": 2, "name": "Bob", "email": "bob@example.com"},
    }
    return fake_db.get(user_id)
```

In a real system, you would:

- use your ORM (e.g. SQLAlchemy),
- query the table,
- map to a simple dict that the agent can understand.

This lets the agent answer questions like:

- “Show me user 2’s email address.”

---

### Example 3: Email Drafting Tool (Safe)

Instead of sending real emails, we’ll **only draft** the email text.

```python
from langchain_core.tools import tool

@tool
def draft_welcome_email(user_name: str) -> str:
    """
    Create a friendly welcome email body for a new user.
    Does NOT send the email, only returns the text.
    """
    return (
        f"Hi {user_name},\n\n"
        "Welcome to our platform! Let us know if you have any questions.\n\n"
        "Best regards,\nThe Team"
    )
```

The agent can:

- generate the email body,
- show it to a human,
- and your backend can then **decide** whether to send it.

This pattern keeps the agent **helpful but safe**.

---

### Example 4: Wiring Tools into an Agent

Here’s a small illustration of using tools with a chat model.

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain.agents import create_tool_calling_agent, AgentExecutor

from my_tools import add_two_numbers, get_user_by_id  # your tools

llm = ChatOpenAI(model="gpt-4.1-mini")
tools = [add_two_numbers, get_user_by_id]

prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful backend assistant."),
    ("user", "{input}")
])

agent = create_tool_calling_agent(llm, tools, prompt)
agent_executor = AgentExecutor(agent=agent, tools=tools)

result = agent_executor.invoke({"input": "What is 3 + 7?"})
print(result["output"])
```

Flow:

- User asks a question.
- Agent sees tools `add_two_numbers` and `get_user_by_id`.
- Agent decides to call `add_two_numbers(3, 7)`.
- Tool returns `10`.
- Agent responds to the user with the final answer.

---

## 7. How Codex Helps

Codex is extremely helpful when working with tools:

- **Generating tool stubs**  
  - You can say: “Create tools for listing users, getting order details, and calculating tax.”  
  - Codex will scaffold functions, type hints, and docstrings.

- **Wrapping existing code**  
  - “Take these existing service functions and wrap them as LangChain tools with @tool.”

- **Improving docstrings**  
  - “Rewrite these docstrings so they clearly explain when the agent should use each tool.”

- **Adding tests**  
  - “Generate pytest tests for each tool, using simple fake data.”

- **Refactoring for safety**  
  - “Split this big tool into small, safe tools: one for read, one for write.”

Think of Codex as your **pair programmer** for:

- designing tool interfaces,
- writing boilerplate,
- cleaning up names and comments,
- keeping things consistent across your project.

---

## 8. Small Diagram

### Agent Using Tools

```text
User Question
    ↓
Agent (LLM)
    ↓ decides which tool to call
Tools List: [Calculator, DB Reader, Email Drafter]
    ↓
Selected Tool runs (Python code)
    ↓
Result back to Agent
    ↓
Final Answer to User
```

### Tools in a Backend Architecture

```text
          ┌───────────┐
User → API│  Agent    │
          └────┬──────┘
               │ uses tools
      ┌────────┴───────────────┐
      │                        │
 ┌────▼────┐              ┌────▼──────┐
 │DB Tools │              │Email Tools│
 └────┬────┘              └────┬──────┘
      │                        │
   Database                 Email Service
```

---

## 9. Summary

- A **tool** is a normal Python function that an agent can call to **take real actions** (calculate, read DB, draft emails, call APIs).
- Tools should be **small, focused, and safe**, with clear parameters and simple return values.
- The **docstring** explains to the model *when* and *how* to use the tool.
- You register tools in a list and pass them into the agent; if a function is not in that list, the agent cannot use it.
- Codex can help you design, generate, refactor, and test tools so you can connect your agents to real backend systems quickly and safely.

