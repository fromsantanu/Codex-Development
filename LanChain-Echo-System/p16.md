# 16. Incremental Development using Codex CLI

## 1. Simple Intro

You don’t have to build a full agent system in one shot.  
You can build it **step by step**, like normal backend work:

- add a small feature,
- refactor one function,
- run tests,
- repeat.

**Codex CLI** fits perfectly with this **incremental development** style:

- it lives inside your project folder,
- understands your files,
- helps you make small, safe changes,
- and keeps track of context across a session.

---

## 2. Why Backend Devs Should Learn This

As a backend developer you already:

- ship changes in small pull requests,
- run tests frequently,
- avoid huge “big bang” rewrites,
- use IDE tools to refactor safely.

Incremental development with Codex CLI lets you:

- treat agent code like any other backend service,
- evolve prompts, tools, and chains in tiny, reviewable steps,
- keep your **git history clean** and **tests passing**,
- try ideas quickly without losing control.

Instead of copy‑pasting code into a browser, you keep everything **in your repo**, with Codex helping you _inside_ that folder.

---

## 3. Analogy: Renovating One Room at a Time

Imagine renovating a house:

- Bad approach: tear down everything at once; chaos, dust, and surprises.
- Better approach: one room at a time:
  - plan,
  - do the work,
  - inspect,
  - move to the next room.

Codex CLI helps you do the same for your codebase:

- “Scan the house” → understand the current structure.
- “Work on this room” → change one agent, one tool, or one chain.
- “Inspect the work” → review diffs, run tests.
- Then move on to the next small step.

This keeps your agent project **stable and predictable** as it grows.

---

## 4. Key Ideas for Incremental Development with Codex CLI

1. **Use your project folder as the workspace**  
   - Start Codex CLI in the **root of your repo**.  
   - It can read and edit files directly (with your approval).

2. **Upload / attach the folder once per session**  
   - Point Codex at the folder so it can see: `app/`, `agents/`, `tools/`, `chains/`, `tests/`.  
   - After that, you work in **small steps** without re‑uploading files.

3. **Ask Codex to scan files before changing anything**  
   - “Scan this folder and summarize the architecture.”  
   - “List where agents and tools are defined.”  
   - “Show me all references to this function.”

4. **Make small, focused edits**  
   - Add one tool.  
   - Refactor one chain.  
   - Improve one prompt.  
   - Keep each change understandable and testable.

5. **Review diffs and run tests often**  
   - Never blindly accept large edits.  
   - Use your normal test commands (pytest, etc.).  
   - Let Codex suggest tests if coverage is weak.

6. **Keep a running conversation with Codex CLI**  
   - It remembers what you changed in this session.  
   - You can say: “Now update the tests to match the new behavior.”

7. **Refactor with safety**  
   - Rename tools, move files, split large agents, all with Codex proposing patches and you reviewing them.

---

## 5. Step‑by‑Step: Incremental Workflow with Codex CLI

We’ll walk through a typical loop:

- open project,
- scan,
- add a feature,
- refactor,
- test.

### Step 1: Open the Project in Codex CLI

1. In your terminal, `cd` into your project root (where `app/`, `agents/`, `tools/` live).
2. Start Codex CLI there so it can see the whole folder.
3. Confirm it can list your files and read key modules.

Now Codex CLI has **project context** and you can work incrementally.

### Step 2: Ask Codex to Scan the Codebase

First, get a quick “map”:

- “Scan this repo and summarize the main modules and folders.”  
- “Where are the agents defined?”  
- “Where are tools and chains located?”

You can also ask:

- “Show me how the support agent is wired.”  
- “Which tests cover this agent?”

This step replaces you manually opening 10–20 files just to understand structure.

### Step 3: Add a Small Feature

Next, pick a **tiny feature**:

- add a new tool (e.g. summarization),
- extend a prompt,
- add a new chain for a small workflow.

Example request:

> “In this project, add a summarization tool in tools/summary_tools.py\n\
>  and register it with the support agent. Keep the change minimal.\n\
>  Then show me the diff.”

You review the suggested patch, adjust if needed, and save.

### Step 4: Refactor Carefully

Once a feature works, you may notice:

- duplicated code,
- long functions,
- unclear naming.

Ask Codex CLI:

> “Refactor this agent file to:\n\
>  - extract tool setup into a separate function,\n\
>  - keep behavior the same,\n\
>  - improve naming and docstrings.\n\
>  Show me only the changed code.”

Again, you:

- inspect the patch,
- verify that public interfaces stay stable,
- rerun tests.

### Step 5: Run Tests Between Steps

After each small change:

- run your test suite (or at least affected tests),
- if something fails, copy the **failing test + stack trace** back to Codex,
- ask it to help fix the regression.

Example:

> “After your last refactor, this test started failing. Here is the test\n\
>  and the error. Please explain what broke and propose a minimal fix.”

Repeat this loop for each incremental improvement.

---

## 6. Short Code Examples

Here are small code snippets that represent typical incremental changes Codex CLI can help you make.

### Example 1: Extracting Tool Setup into a Helper

You might start with an agent file where tools are inlined. An incremental refactor is to **extract tool setup** into its own function.

```python
# agents/support_agent.py
from typing import List

from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain.agents import AgentExecutor, create_tool_calling_agent

from tools.ticket_tools import get_ticket_by_id, draft_reply_email
from tools.summary_tools import summarize_text


def _build_tools() -> List:
    """Return the list of tools used by the support agent."""
    return [
        get_ticket_by_id,
        draft_reply_email,
        summarize_text,
    ]


def create_support_agent(model_name: str = "gpt-4.1-mini") -> AgentExecutor:
    llm = ChatOpenAI(model=model_name)
    tools = _build_tools()

    prompt = ChatPromptTemplate.from_messages([
        ("system",
         "You are a helpful support assistant.\n"
         "Use tools when needed, otherwise answer directly."),
        ("user", "{input}")
    ])

    agent = create_tool_calling_agent(llm, tools, prompt)
    return AgentExecutor(agent=agent, tools=tools)
```

You can ask Codex CLI: “Extract the tools list into a helper function like `_build_tools()` and keep behavior identical.”

---

### Example 2: Small Prompt Improvement

Another small incremental change is refining the system prompt to mention new tools.

```python
prompt = ChatPromptTemplate.from_messages([
    ("system",
     "You are a helpful support assistant.\n"
     "- Use get_ticket_by_id for questions about specific ticket IDs.\n"
     "- Use summarize_text when the user asks for a shorter version.\n"
     "If a tool is not needed, answer directly."),
    ("user", "{input}")
])
```

You might say:

> “Update the support agent system prompt so it explicitly explains when\n\
>  to use summarize_text, but keep it concise.”

Codex CLI edits just this block, leaving everything else untouched.

---

### Example 3: Adding a Targeted Test

Incremental development also means **incremental testing**. For each new feature or refactor, add a small test.

```python
# tests/test_support_agent_summary.py
from agents.support_agent import create_support_agent


def test_support_agent_can_summarize_long_text():
    agent = create_support_agent()

    user_input = (
        "Summarize the following message: "
        "'I am unhappy because the API was down all weekend and I could not process orders.'"
    )

    result = agent.invoke({"input": user_input})
    output = result.get("output", "")

    assert "unhappy" in output.lower()
    assert len(output.split()) < 40  # should be short
```

You can ask Codex:

> “Add a pytest that checks the support agent can summarize a long complaint\n\
>  into a short response. Keep it fast and simple.”

---

## 7. How Codex Helps

Codex CLI is especially powerful when you:

- **Work in small steps**
  - “Change just this function.”  
  - “Add one new tool.”  
  - “Refine this prompt.”

- **Keep it anchored in your repo**
  - All edits happen in your files, not in random snippets.  
  - You can see and review diffs like any normal change.

- **Use Codex for both feature work and refactors**
  - Scaffold new tools and chains.  
  - Clean up old code and improve structure.

- **Combine with your existing tooling**
  - Run your normal tests and linters.  
  - Keep using git, code reviews, and CI.

In other words, Codex CLI becomes a **smart teammate inside your terminal**, helping you evolve your agent system one small, safe change at a time.

---

## 8. Small Diagram

### Incremental Loop with Codex CLI

```text
[Start Session in Project Folder]
             ↓
     Ask Codex to Scan
             ↓
   Plan Small Change (feature/refactor)
             ↓
   Codex Proposes Patch → You Review
             ↓
       Apply Change + Run Tests
             ↓
       Repeat for Next Change
```

### Codex CLI in Your Workflow

```text
Developer ↔ Codex CLI ↔ Codebase
     ↓                  ↓
   Git / PRs       Tests / CI
```

---

## 9. Summary

- Incremental development with Codex CLI means evolving your agent project in **small, reviewable steps** from inside your repo.
- You start by opening the project folder, asking Codex to **scan and summarize** the code, then adding features or refactors one at a time.
- For each change, Codex proposes patches; you review them, run your own tests, and iterate.
- This workflow makes agent code feel like normal backend code: versioned, tested, and easy to refactor.
- Used this way, Codex CLI becomes a long‑running teammate in your terminal, helping you safely grow your agentic workflows over time.

