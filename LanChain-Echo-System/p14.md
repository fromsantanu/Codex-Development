# 14. Asking Codex to Debug Agent Code

## 1. Simple Intro

Agent code can fail in many ways:

- wrong tool arguments,
- bad prompt variables,
- missing environment variables,
- infinite loops or useless tool calls,
- confusing error messages from APIs or DBs.

Instead of manually chasing every bug, you can treat Codex like a
**senior engineer who reads your error logs and code with you**.

You:

- show Codex the error and the code,
- explain what you expected,
- ask it to find the cause, explain it simply, and propose a fix.

---

## 2. Why Backend Devs Should Learn This

As a backend developer you already debug:

- stack traces,
- SQL errors,
- integration failures,
- performance issues.

Agent systems add extra layers:

- LLM behavior,
- prompts,
- tools,
- chains,
- external APIs.

Debugging everything alone can be slow.

Using Codex to debug:

- reduces time spent staring at stack traces,
- catches subtle bugs (wrong key names, arguments, types),
- helps you understand **why** the agent behaved strangely,
- suggests better logging, tests, and structure.

You still stay in control; Codex just accelerates your usual debug loop.

---

## 3. Analogy: Pair Programming With a Senior Engineer

Imagine you’re pairing with a senior engineer:

- You show them the failing test and stack trace.
- They read the code quickly and say:
  - “You’re passing the wrong field here.”
  - “This function can return None; add a check.”
  - “The prompt doesn’t mention the tool; update it.”

Codex plays this role:

- you paste logs, errors, and code,
- you ask for a clear explanation in simple terms,
- you ask for a patch or refactor.

You are still the **driver**:

- you decide what to keep,
- you run tests,
- you deploy the changes.

---

## 4. Key Ideas for Debugging with Codex

1. **Always include context**  
   - Error message and stack trace.  
   - Relevant code (agent, tools, chains, config).  
   - What you expected vs what happened.

2. **Ask for a diagnosis first**  
   - “Explain this error in simple language.”  
   - “Which line is most likely wrong?”  
   - “What is the root cause?”

3. **Then ask for a fix**  
   - “Propose a minimal code change to fix this.”  
   - “Keep the public API the same.”

4. **Keep changes small and reviewable**  
   - Fix one issue at a time.  
   - Ask for small patches, not total rewrites.

5. **Improve observability**  
   - Ask Codex to add logging around tools and chains.  
   - Ask it to print intermediate steps during debugging.

6. **Reproduce with tests**  
   - Have Codex write a failing test that reproduces the bug.  
   - Once fixed, the test becomes a safety net.

7. **Iterate like normal debugging**  
   - Run code → collect error → ask Codex → patch → rerun.

---

## 5. Step‑by‑Step: Debugging an Agent with Codex

### Step 1: Capture the Error and Context

Run your agent:

- from a script,
- from a FastAPI route,
- or from a notebook.

When it fails, collect:

- the **full stack trace**,
- the **prompt or input** that caused it,
- any **tool arguments** and outputs.

### Step 2: Show Everything to Codex

In Codex CLI or VS Code:

1. Paste the stack trace.  
2. Paste the relevant code files (agent, tools, chains).  
3. Add a short description:

> “This support agent should read a ticket and draft a reply.\n\
>  It crashes with this error when I ask it about ticket 1.\n\
>  Please explain the error and point to the root cause.”

### Step 3: Ask for a Plain‑Language Explanation

Ask:

> “Explain this error like I’m a backend dev.\n\
>  What is going wrong step by step?”

Codex can:

- translate long errors into simple sentences,
- tell you which variable or line is suspicious,
- highlight missing imports or mis‑typed keys.

### Step 4: Ask for a Minimal Patch

Once you understand the cause, ask:

> “Propose a minimal patch to fix this.\n\
>  Keep the existing function names and public interfaces.\n\
>  Show only the changed lines or blocks.”

Then you:

- review the patch,
- apply it,
- rerun the failing scenario.

### Step 5: Add Logging and Better Error Messages

If the bug is tricky, ask Codex:

> “Add lightweight logging around tool calls and agent steps\n\
>  so I can see inputs and outputs when something goes wrong.\n\
>  Use Python’s logging module.”

This helps you understand:

- what data is being passed,
- which tool or chain step fails,
- how often the agent loops.

### Step 6: Add a Reproducing Test

To avoid regressions:

> “Write a pytest test that reproduces this bug using fake data.\n\
>  Mock the LLM so the test is deterministic.”

Once the test passes with the fix, you have:

- a **documented bug**,
- a **test that guards it**,
- more confidence in future refactors.

---

## 6. Short Code Examples

These are small patterns Codex can help you generate.

### Example 1: Wrapping an Agent Call with Logging

```python
import logging
from agents.support_agent import create_support_agent

logger = logging.getLogger(__name__)


def run_support_agent(user_input: str) -> str:
    agent = create_support_agent()

    try:
        logger.info("Calling support agent with input: %s", user_input)
        result = agent.invoke({"input": user_input})
        logger.info("Agent output keys: %s", list(result.keys()))
        return result.get("output", "")
    except Exception:
        logger.exception("Support agent failed")
        raise
```

You can ask Codex to **add this kind of wrapper** around your existing agent calls to make debugging easier.

---

### Example 2: Handling a Missing Tool Field

Suppose a tool expects a field `ticket["body"]`, but sometimes that key is missing.

```python
from typing import Dict
from langchain_core.tools import tool


@tool
def summarize_ticket(ticket: Dict) -> str:
    """
    Summarize a support ticket.
    Expects keys: 'subject' and 'body'.
    """
    subject = ticket.get("subject", "No subject")
    body = ticket.get("body")

    if body is None:
        # Better error message for debugging
        raise ValueError("Ticket is missing 'body' field")

    return f"Ticket about: {subject}. User says: {body}"
```

If your agent crashed with `KeyError: 'body'`, you can ask Codex:

> “Here is the tool and the stack trace. Please update the tool so it\n\
>  fails with a clear error message instead of KeyError, and explain why.”

Codex can then propose this safer version with a clear `ValueError`.

---

### Example 3: Simple Failing Test Skeleton

```python
# tests/test_support_agent_error.py
import pytest
from agents.support_agent import create_support_agent


def test_support_agent_handles_missing_ticket_body_gracefully():
    agent = create_support_agent()

    with pytest.raises(Exception):
        agent.invoke({"input": "Summarize ticket 999 with missing body"})
```

You can ask Codex to:

- turn a bug report into a test like this,
- refine it to check for a specific exception or message,
- or mock tools/LLMs for faster tests.

---

## 7. How Codex Helps

Codex is especially strong in debugging when you:

- **Provide real errors and logs**
  - Paste stack traces, inputs, and outputs.  
  - Ask for step‑by‑step reasoning in plain language.

- **Ask for targeted fixes**
  - “Fix just this function.”  
  - “Keep the interface, only adjust internals.”

- **Improve observability**
  - “Add logging to all tool calls and show me a summary of what is logged.”  
  - “Add type hints and docstrings to clarify contracts.”

- **Harden prompts and tools**
  - “The agent keeps calling the wrong tool. Adjust the prompt and docstrings so it uses the right tool.”  
  - “Add guardrails: if input is missing, return an error message.”

- **Turn bugs into tests**
  - “Take this bug and write a test that will fail until the fix is applied.”

Used this way, Codex becomes your **AI debugging partner**, not just a code generator.

---

## 8. Small Diagram

### Debugging Loop with Codex

```text
Run Agent
   ↓
Error / Unexpected Behavior
   ↓
Collect Stack Trace + Code
   ↓
Ask Codex:
  - Explain the error
  - Propose a fix
   ↓
Apply Patch → Rerun
   ↓
Add Test if Needed
   ↓
More Stable Agent
```

### Where Debugging Fits in the System

```text
User → API → Agent → Tools / DB
             ↓
         Error / Logs
             ↓
           Codex
             ↓
      Fixes & Refactors
             ↓
      Safer, More Reliable Agent
```

---

## 9. Summary

- Agent bugs often involve prompts, tools, chains, and external systems, so debugging them by hand can be slow.
- Codex can read your stack traces and code, explain errors in plain language, and suggest small, targeted fixes.
- A good workflow is: run → collect error + code → ask Codex to diagnose → apply minimal patch → rerun → add a test.
- You can also ask Codex to add logging, better error messages, and stronger type hints to make future debugging easier.
- Treat Codex like a senior pair‑programmer for debugging: you keep control of design and safety, while Codex accelerates the investigation and patching process.

