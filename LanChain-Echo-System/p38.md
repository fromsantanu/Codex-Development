# **Chapter 38. Versioning Your Prompts**

### **1. Simple Introduction**

Prompts are not “write once and forget”.
Just like software code, prompts evolve over time:

* You discover better instructions
* You add new rules
* You improve formatting
* New model versions behave differently
* You fix mistakes or hallucinations

If you do not **version** your prompts, you quickly lose track of:

* Which prompt produced which output
* What changed over time
* Which version is used in production
* Why an agent suddenly behaves differently

So, prompt versioning is as important as code versioning.

---

### **2. Real-Life Analogy**

Think of prompt versions like recipe versions.

If your cake tastes good, you save that recipe.
If you change the sugar or temperature, you call it **Recipe v2**.

That way you always know:

* What changed
* Which recipe works best
* How to reproduce a good result

Prompt versioning works exactly the same way.

---

## **3. Why Version Matters**

### **A. Reproducibility**

If a customer says:

> “Your agent behaved differently today.”

You must be able to check:

* Which prompt version was used
* What was changed recently

### **B. Debugging**

When you test two prompts:

* Prompt v3 works
* Prompt v4 fails

You know exactly where the problem is.

### **C. Experimentation**

You may want to try:

* Strict formatting version
* Short prompt version
* Richer instructions version

Versioning lets you A/B test easily.

### **D. Safety**

Sometimes a small change removes an important safety instruction.
Version control helps you detect that.

---

## **4. Prompt Folder Structure**

A clean folder structure makes prompt management simple.

### **Recommended Folder Layout**

```
prompts/
   ├── agent_sales/
   │       ├── v1.md
   │       ├── v2.md
   │       └── v3.md
   ├── agent_healthcare/
   │       ├── v1.md
   │       ├── v2.md
   │       └── v3_strict_safety.md
   ├── agent_workflow/
   │       ├── v1.md
   │       └── v2.md
   └── template_library/
           ├── summarize_template.md
           ├── qa_template.md
           ├── extraction_template.md
           └── system_template.md
```

### **Benefits of This Structure**

* Each agent has its own folder
* Each version is a separate file
* Templates are reusable
* Easy to compare versions
* Works perfectly with Git

---

## **5. Version Naming Styles**

### **A. Simple Sequential Versioning**

```
v1, v2, v3, v4
```

### **B. Semantic Prompt Versioning**

```
1.0.0  – initial stable version
1.1.0  – added more safety rules
1.2.0  – added formatting rules
2.0.0  – major rewrite
```

### **C. Purpose-Based Versions**

```
v1_safety
v1_fast
v2_detailed
v3_strict_json
```

Choose whichever is simplest for your team.

---

## **6. Example Prompt Version**

### **Version 1 – Simple**

```
You are a helpful assistant. Summarize the text in 5 bullet points.
```

### **Version 2 – Improved Clarity**

```
You are a concise summarizer.
Rules:
- Output EXACTLY 5 bullet points.
- Each bullet must be under 12 words.
- No new facts.
- Do not include introductions or conclusions.
```

### **Version 3 – JSON Output**

```
You are a summarizer producing structured output.

Return JSON:
{
   "summary": [
        "point1",
        "point2",
        "point3",
        "point4",
        "point5"
   ]
}

Rules:
- Each bullet must be <= 12 words.
- No extra text outside JSON.
```

With versioning, you always know which prompt is active.

---

## **7. Codex-Assisted Prompt Improvement**

Codex is excellent at improving prompts because it can:

* Rewrite long prompts into clean structure
* Add missing rules
* Reduce ambiguity
* Improve formatting
* Add examples
* Fix contradictions
* Add safety instructions

### **Example Prompt to Codex**

**Your Request:**

```
Codex, here is my prompt (v1). Please:
- make it clearer
- add safety rules
- enforce JSON output
- remove ambiguous instructions
- suggest a v2 version
```

**Codex Output (v2):**

```markdown
# Prompt v2 – Clean & Structured

## Role
You are a structured summarization agent.

## Task
Summarize the given text into exactly 5 bullet points.

## Output Format (JSON only)
{
  "summary": ["...", "...", "...", "...", "..."]
}

## Rules
- Each point must be <= 12 words.
- Do not invent facts.
- Do not output anything outside the JSON block.
- No introductions, no explanations.
```

You can then save this as:

```
prompts/agent_summarizer/v2.md
```

---

## **8. Using Codex to Compare Two Prompt Versions**

Ask Codex:

```
Compare v3.md and v4.md. 
List differences, potential problems, and improvements.
Highlight missing safety rules.
```

Codex will:

* Show line-by-line improvements
* Catch rule conflicts
* Identify weak instructions
* Suggest better structure

This makes prompt engineering 10× faster.

---

## **9. Storing Prompt Version in Logs (Important)**

Whenever an agent runs, always store:

* **prompt_version**
* **prompt_name**
* **timestamp**

Using LangFuse or LangSmith trace metadata:

```python
metadata={"prompt_version": "v3", "agent": "symptom_agent"}
```

This helps with:

* Debugging
* Reproducing failures
* Understanding model behavior
* Ensuring safety standards

---

## **10. Summary**

Versioning prompts is essential because:

### ✔ Prompts evolve over time

### ✔ You need to track which version caused which output

### ✔ Helps debugging & improving reliability

### ✔ Works perfectly with Git

### ✔ Codex can help create better, safer, cleaner versions

A clean folder structure + Codex-assisted improvement makes your entire agent system stable, traceable, and professionally engineered.

---
