# 8. Designing Your First Agent Project Folder Structure

When you start building agents, it is very tempting to throw everything into a single `main.py` file: prompts, tools, chains, agents, and even HTTP endpoints.

That works for a quick demo, but it falls apart fast.

This chapter shows you how to give your **agent project a clean folder structure** so it feels like any other well‑organized backend service.

Think of it as:

> “Creating a home for each part of your agent system: entrypoints, agents, tools, chains, and tests — so future you doesn’t hate present you.”

We will stay in normal backend territory: folders, modules, imports, and a tiny amount of code in each place.

---

## 1. Simple introduction

At a high level, we want a project layout like this:

```text
project/
  app/       # entrypoints (CLI, API)
  agents/    # agent definitions and orchestration
  tools/     # functions the agents can call
  chains/    # reusable chains / workflows
  tests/     # tests for tools, chains, agents
```

The idea is simple:

- **`app/`** holds the ways people talk to your system  
  (CLI scripts, FastAPI app, background workers).
- **`agents/`** holds the “brains” — how the agent reasons and which tools it can use.
- **`tools/`** holds normal Python functions that do work: DB queries, API calls, calculations.
- **`chains/`** holds reusable workflows built from models and tools.
- **`tests/`** checks that everything works as expected.

Each folder has **one clear responsibility**, just like separating routers, services, and models in a normal backend.

---

## 2. Why it matters for backend developers

You already know what happens when everything lives in one giant file:

- it becomes **hard to read**,
- nobody remembers where a function lives,
- small changes feel risky,
- tests are painful to write.

With agents, this can get even worse:

- prompts, tools, chains, and agents get mixed together,
- you are never sure which prompt version is actually in use,
- a quick experiment silently turns into production code.

A simple structure fixes that:

- teammates can **guess where things live** (`agents/`, `tools/`, etc.),
- you can **add new tools or agents** without touching unrelated code,
- tests can be **organized by feature**, not by accident,
- onboarding a new dev becomes much easier: “start in `app/main.py`, then follow the imports.”

In short, a clean folder layout gives your agent project the **same discipline** as your other backend services.

---

## 3. Real-life analogy

Imagine a **workshop with many drawers**:

- one drawer for screwdrivers,
- one drawer for wrenches,
- one shelf for manuals,
- a box for safety gear.

If you throw everything into one cardboard box:

- you waste time digging,
- you buy tools you already own,
- nobody wants to use the workshop.

But if you label the drawers:

- “Tools”, “Plans”, “Materials”,
- everyone can **find and put back** what they need.

In our agent project:

- `app/` is like the **front door** where people walk in.
- `agents/` is the **workbench** where decisions are made.
- `tools/` is the **drawer of actual tools** (functions, APIs).
- `chains/` is the **set of step‑by‑step recipes** pinned to the wall.
- `tests/` is your **checklist** to make sure everything still works.

The clearer the labels, the smoother the work.

---

## 4. Key concepts

Let’s map each important folder to ideas you already know.

- **`app/` – entrypoints**
  - Think: FastAPI `main.py`, CLI scripts, schedulers.
  - This is where you:
    - parse input (HTTP, CLI args, messages),
    - call the right agent,
    - return or log the result.

- **`agents/` – brains and orchestration**
  - Each file can define an agent:
    - which tools it has,
    - what prompts it uses,
    - how it behaves.
  - Similar to a “service layer” or “use‑case layer” in normal apps.

- **`tools/` – business logic as tools**
  - Normal Python functions with clear inputs/outputs.
  - Wrap database queries, HTTP clients, email senders, calculators.
  - Exposed to the agent via LangChain’s `@tool` decorator or Tool objects.

- **`chains/` – reusable workflows**
  - Chains are like **stored procedures** for your AI:
    - step‑by‑step flows built from prompts, models, and tools.
  - You can reuse them across different agents or endpoints.

- **`tests/` – safety net**
  - Split tests in a way that matches code:
    - `test_tools_*.py`
    - `test_chains_*.py`
    - `test_agents_*.py`
  - Start with simple “does this run without crashing” tests, then grow.

- **`__init__.py` – treat folders as packages**
  - Add `__init__.py` files so imports stay clean:
    - `from agents.support_agent import support_agent`
    - `from tools.order_tools import get_order_total`

Optionally, you may later add:

- `prompts/` – reusable prompt templates.
- `config/` – settings, environment handling.
- `data/` – seed data or fixtures for local runs.

But first, we keep it minimal: **`app/`, `agents/`, `tools/`, `chains/`, `tests/`**.

---

## 5. Step-by-step explanation

### Step 1: Start from a clean project folder

Assume you already created a project and virtual environment (from the previous chapter):

```bash
mkdir my-agent-project
cd my-agent-project
```

You should now have something like:

```text
my-agent-project/
  .venv/        # virtual environment
  .env          # API keys and config (optional)
```

We are going to grow this into a real agent project.

---

### Step 2: Create the core folders

Create the main folders for your agent system:

```bash
mkdir -p app agents tools chains tests
```

This gives you:

```text
my-agent-project/
  app/
  agents/
  tools/
  chains/
  tests/
  .venv/
  .env
```

Each folder is still empty, but the **structure already tells a story**:

- `app/` = “here is where execution starts,”
- `agents/` = “this is where decisions happen,”
- `tools/` = “this is where real work lives,”
- `chains/` = “this is where workflows live,”
- `tests/` = “this is how we validate everything.”

---

### Step 3: Add `__init__.py` files

Turn these folders into Python packages:

```bash
touch app/__init__.py agents/__init__.py tools/__init__.py chains/__init__.py
```

Now you can import cleanly:

```python
from agents.support_agent import support_agent
from tools.order_tools import get_order_total
```

This might feel like a tiny detail, but it keeps imports **predictable and stable**, especially once your project grows.

---

### Step 4: Create a minimal entrypoint in `app/`

Let’s create a tiny `app/main.py` so the project actually runs:

```bash
touch app/main.py
```

Inside `app/main.py`, you might start with something as simple as:

```python
def run():
    # Later: wire this to an agent call
    print("Agent app is starting..." )


if __name__ == "__main__":
    run()
```

Right now this just prints a message, but the important part is:

- everyone knows **where execution starts**,
- later you can plug in:
  - a CLI interface,
  - a FastAPI application,
  - or a worker loop that calls your agents.

---

### Step 5: Sketch your first agent and tools

Create a **placeholder agent** and **placeholder tools** to show how the pieces connect.

In `tools/order_tools.py`:

```python
from langchain_core.tools import tool


@tool
def get_order_total(order_id: int) -> float:
    """Return total price for a given order."""
    # Replace this with real DB logic later
    return 42.0
```

In `agents/support_agent.py`:

```python
from langchain_openai import ChatOpenAI
from langchain.agents import initialize_agent

from tools.order_tools import get_order_total


llm = ChatOpenAI(model="gpt-4.1-mini")

support_agent = initialize_agent(
    tools=[get_order_total],
    llm=llm,
    agent_type="zero-shot-react-description",
)
```

And update `app/main.py` to call it:

```python
from agents.support_agent import support_agent


def run():
    response = support_agent.invoke(
        "What is the total for order 123? Be friendly."
    )
    print(response)


if __name__ == "__main__":
    run()
```

You now have a **full path**:

- user runs `python -m app.main`,
- `app.main` calls an agent from `agents/`,
- the agent calls a tool from `tools/`,
- the tool (eventually) hits your database or services.

We will refine prompts, tools, and agents in later chapters — here we only care that **each piece has a clear home**.

---

### Step 6: Prepare a simple test

Create a basic test file so `tests/` is part of the story from day one.

In `tests/test_tools_order.py`:

```python
from tools.order_tools import get_order_total


def test_get_order_total_returns_number():
    total = get_order_total.invoke({"order_id": 1})
    assert isinstance(total, float)
```

This is intentionally tiny:

- it proves the tool is wired correctly,
- it ensures refactors don’t silently break the tool’s interface.

Over time you can:

- add tests for more tools,
- add tests for chains,
- add tests that run full agent flows end‑to‑end.

---

## 6. Short code examples

Here is a quick summary of the most important snippets.

**Creating the folder structure and base files:**

```bash
mkdir -p app agents tools chains tests
touch app/main.py app/__init__.py agents/__init__.py tools/__init__.py chains/__init__.py
```

**Example tool in `tools/order_tools.py`:**

```python
from langchain_core.tools import tool


@tool
def get_order_total(order_id: int) -> float:
    """Return total price for a given order."""
    return 42.0
```

**Example agent in `agents/support_agent.py`:**

```python
from langchain_openai import ChatOpenAI
from langchain.agents import initialize_agent
from tools.order_tools import get_order_total


llm = ChatOpenAI(model="gpt-4.1-mini")

support_agent = initialize_agent(
    tools=[get_order_total],
    llm=llm,
    agent_type="zero-shot-react-description",
)
```

These are **minimal** on purpose: they give you a skeleton you can extend with real business logic.

---

## 7. How Codex helps

OpenAI Codex is great at doing the **boring parts** of this structure for you.

Examples of things you can ask Codex to do:

- “Create a clean folder structure for an agent project with `app/`, `agents/`, `tools/`, `chains/`, and `tests/`.”
- “Generate a sample `support_agent` and one `order_tools` module using LangChain tools.”
- “Add `__init__.py` files and fix any import paths so everything runs with `python -m app.main`.”
- “Write basic tests for my tools and agents under `tests/`.”

In practice, Codex can:

- **scaffold** the whole tree in one go,
- create **starter files** with clear docstrings,
- keep imports **consistent** when you rename or move modules,
- generate **tests** that match your structure.

You stay in control:

- you describe the structure you want,
- Codex generates the code and folders,
- you review and run tests,
- you refine the structure as the project grows.

The more consistent your layout is, the easier it is for Codex to:

- find things,
- propose refactors,
- and extend your agents without breaking existing behavior.

---

## 8. Small diagram

Here is how the pieces fit together in your project:

```text
project/
  app/
    main.py        # entrypoint: calls agents
  agents/
    support_agent.py  # defines support_agent
  tools/
    order_tools.py    # get_order_total, etc.
  chains/
    ...               # reusable workflows (later)
  tests/
    test_tools_order.py
```

And the runtime flow:

```text
[User / Client]
      ↓
   app/main.py
      ↓
   support_agent  (agents/)
      ↓
   tools (order_tools, etc.)
      ↓
  DB / APIs / Services
```

This mirrors real backend systems you already know:

- entrypoints,
- orchestration layer,
- business logic functions,
- tests and infrastructure.

---

## 9. Summary

- A **simple, consistent folder structure** keeps your agent project understandable as it grows.
- Use `app/`, `agents/`, `tools/`, `chains/`, and `tests/` to **separate concerns**:
  - entrypoints,
  - decision‑making,
  - business logic,
  - workflows,
  - and safety nets.
- Start with tiny placeholder files and **grow them gradually** rather than one huge script.
- Let **Codex** scaffold and maintain this structure so you can focus on real logic and data, not on moving files around.
- With this layout, your agent system feels like any other **clean backend service**: easy to navigate, extend, test, and debug.

