# 18. ReAct Agent with Codex

## 1. Simple Intro

So far we mostly used **“tool-calling agents”** without worrying about *how* they reason in multiple steps.

The **ReAct** pattern (“**Re**ason + **Act**”) makes that explicit:

- the agent **thinks** about what to do next,
- then **acts** by calling a tool,
- looks at the **observation** (tool result),
- then **thinks again**, and repeats,
- until it’s ready to give a final answer.

You can picture this when:

- planning a dinner,
- looking up recipes,
- checking what’s in your pantry,
- building a shopping list step by step.

In this chapter we’ll connect that idea to LangChain agents and show how Codex can help you build and debug ReAct‑style loops.

---

## 2. Why Backend Devs Should Learn This

As a backend developer you already design:

- workflows that make **decisions mid‑flow**,
- multi‑step jobs that **call services**, inspect results, and continue,
- logs/traces that show each step clearly.

ReAct matters because it gives you:

- a **clear mental model** of what the agent is doing:
  - Thought → Action → Observation → (loop),
- better **debuggability** (you can see where the reasoning went wrong),
- safer **tool use** (the agent inspects results before the next step),
- a solid foundation for:
  - planners,
  - routers,
  - LangGraph workflows.

Codex can then:

- scaffold the tools and ReAct prompts,
- wire them into a LangChain `AgentExecutor`,
- and help you instrument and test each loop.

---

## 3. Analogy: Planning Dinner with a Phone

Imagine you’re planning a **vegetarian dinner for four**:

1. You **think**: “What dishes should I make?”
2. You **act**: search recipes on your phone.
3. You **observe**: see a few good recipes.
4. You **think**: “What ingredients do I already have?”
5. You **act**: open your pantry and check items.
6. You **observe**: you have some things, others are missing.
7. You **think**: “I should write a shopping list.”
8. You **act**: add missing ingredients to your notes app.
9. You **observe**: list looks good → you’re done.

That loop is ReAct:

- **Reason** (“Thought”),
- **Action** (tool: search, check pantry, add to list),
- **Observation** (results),
- repeat until the goal is satisfied.

ReAct agents in code behave the same way, just with:

- LLM “thoughts”,
- your tools (Python functions, APIs),
- and LangChain orchestrating the loop.

---

## 4. Key Ideas About ReAct

Here’s how ReAct maps to LangChain terms:

- **Thought**
  - The LLM’s internal reasoning step.
  - Often expressed in natural language (“I should search for recipes first”).

- **Action**
  - A **tool call**: `search_recipes`, `check_pantry`, `add_to_shopping_list`, etc.
  - Triggered by the agent based on the Thought.

- **Observation**
  - The **result** of the tool call.
  - Fed back into the model as context for the next Thought.

- **Scratchpad**
  - The running history of Thoughts, Actions, and Observations.
  - Letting the agent remember previous steps within a single run.

- **Agent loop**
  - LangChain’s `AgentExecutor`:
    - passes observations back into the model,
    - keeps calling tools until the model decides to answer directly.

In modern LangChain, the **tool-calling agents you’ve seen already follow a ReAct‑style loop internally**.  
This chapter is about **thinking in that pattern**, and making it explicit in your tools, prompts, and logs.

---

## 5. Step-by-Step: A Dinner-Planning ReAct Agent

We’ll walk through a simple ReAct agent that:

- plans a vegetarian dinner for four,
- gathers ingredients,
- checks a fake pantry,
- and builds a shopping list.

### Step 1: Define Tools

We’ll start with three tools:

- `search_recipes` – returns a small set of fake recipes,
- `check_pantry` – returns whether an item is available,
- `add_to_shopping_list` – stores missing items in memory.

### Step 2: Write a ReAct-Friendly Prompt

We’ll:

- tell the agent it’s a **dinner planner**,
- describe the tools and when to use them,
- encourage **step‑by‑step reasoning**:
  - think about which dish to choose,
  - check ingredients,
  - only then produce a final menu + shopping list.

We don’t need to force the model to literally print `Thought:` / `Action:` lines,  
because LangChain’s tool‑calling agents already separate “thinking” from “acting” via tool calls.

### Step 3: Build the Agent with LangChain

We’ll use:

- `ChatOpenAI` as the LLM,
- our tools list,
- `create_tool_calling_agent` to let the model call tools,
- `AgentExecutor` to run the ReAct loop until completion.

### Step 4: Run the Agent Once

We call:

```python
result = agent_executor.invoke({
    "input": "Plan a vegetarian dinner for four "
             "and list ingredients. Check my pantry and "
             "mark what I need to buy."
})
```

With `verbose=True`, you’ll see:

- each tool call,
- inputs and outputs,
- the final answer (menu + shopping list).

Behind the scenes, LangChain is doing:

```text
Thought → Action (tool) → Observation → Thought → … → Final Answer
```

### Step 5: Refine Tools, Prompt, and Logging

Once it works, you can improve:

- **tool behavior**:
  - more realistic recipe data,
  - a richer pantry model,
  - persistence of the shopping list,
- **prompt**:
  - tighter instructions,
  - constraints (budget, dietary rules),
- **logging**:
  - structured logs for each Thought / Action / Observation step,
  - tests that assert specific tool sequences.

Codex is very good at automating these incremental refinements.

---

## 6. Short Code Examples

These snippets are simplified but show how a ReAct‑style agent looks with LangChain.

### Example 1: Dinner Planning Tools

```python
# tools/dinner_tools.py
from typing import List, Dict
from langchain_core.tools import tool


RECIPES: List[Dict] = [
    {
        "name": "Veggie pasta",
        "serves": 4,
        "ingredients": ["pasta", "tomatoes", "garlic", "olive oil", "basil"],
    },
    {
        "name": "Roasted veggie tray",
        "serves": 4,
        "ingredients": ["potatoes", "carrots", "zucchini", "olive oil", "salt"],
    },
]

PANTRY = {"pasta", "olive oil", "salt", "garlic"}
SHOPPING_LIST: List[str] = []


@tool
def search_recipes(query: str) -> List[Dict]:
    """
    Return a few vegetarian dinner recipes for four people.
    Ignores the query in this demo and returns a fixed list.
    """
    return RECIPES


@tool
def check_pantry(item: str) -> bool:
    """Return True if the ingredient is already in the pantry."""
    return item.lower() in PANTRY


@tool
def add_to_shopping_list(item: str) -> List[str]:
    """
    Add an ingredient to the shopping list and
    return the updated list.
    """
    if item not in SHOPPING_LIST:
        SHOPPING_LIST.append(item)
    return SHOPPING_LIST
```

These tools form the **Action** part of ReAct;  
the agent will decide *when* to call each.

---

### Example 2: Building the ReAct-Style Agent

```python
# agents/dinner_react_agent.py
from typing import List

from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain.agents import AgentExecutor, create_tool_calling_agent

from tools.dinner_tools import (
    search_recipes,
    check_pantry,
    add_to_shopping_list,
)


def create_dinner_planner_agent(
    model_name: str = "gpt-4.1-mini",
) -> AgentExecutor:
    llm = ChatOpenAI(model=model_name)

    tools: List = [
        search_recipes,
        check_pantry,
        add_to_shopping_list,
    ]

    prompt = ChatPromptTemplate.from_messages([
        (
            "system",
            "You are a helpful dinner planning assistant.\n"
            "- Plan a vegetarian dinner for four people.\n"
            "- Use tools to search recipes, check pantry items,\n"
            "  and build a shopping list.\n"
            "- Think step by step. First choose a suitable menu,\n"
            "  then check which ingredients are already in the pantry,\n"
            "  then add missing ingredients to the shopping list.\n"
            "Finally, respond with the chosen menu and a clear\n"
            "shopping list that marks items to buy.",
        ),
        ("user", "{input}"),
    ])

    agent = create_tool_calling_agent(llm, tools, prompt)
    return AgentExecutor(agent=agent, tools=tools, verbose=True)
```

This agent:

- **reasons** about which tools to call and in what order,
- **acts** by calling tools,
- **observes** the results and loops,
- then returns a final, user‑friendly answer.

---

### Example 3: Invoking the ReAct Agent

```python
# app/demo_react_dinner.py
from agents.dinner_react_agent import create_dinner_planner_agent


def main():
    agent = create_dinner_planner_agent()

    user_input = (
        "Plan a vegetarian dinner for four and list all ingredients. "
        "Check my pantry and mark which items I need to buy."
    )

    result = agent.invoke({"input": user_input})
    print(result.get("output", ""))


if __name__ == "__main__":
    main()
```

Run this with `verbose=True` in the executor to see the ReAct loop:

- tool calls,
- intermediate results,
- final plan and shopping list.

---

## 7. How Codex Helps

Codex is very good at the **mechanical parts** of ReAct agents so you can focus on design and safety.

You can ask Codex to:

- **Generate ReAct tools and agent scaffolding**
  - “Create dinner planning tools (search_recipes, check_pantry, add_to_shopping_list) and a LangChain tool‑calling agent that plans a vegetarian dinner using ReAct‑style reasoning.”

- **Instrument and log the loop**
  - “Add structured logging so each Thought / tool call / Observation in the dinner agent is logged with step numbers.”

- **Turn traces into tests**
  - “From this successful ReAct run, create a pytest that asserts which tools are called and that the final shopping list contains tomatoes and basil.”

- **Refactor from simple to ReAct**
  - “Take this existing single‑step dinner chain and refactor it into a ReAct‑style agent that can call tools multiple times until the shopping list is complete.”

- **Upgrade to LangGraph**
  - “Wrap this ReAct dinner planner into a LangGraph workflow so that each tool call is a node and we can pause/resume long‑running plans.”

Because Codex sees your whole repo, it can:

- reuse existing tools,
- follow your folder structure,
- and evolve your agent from a simple script to a robust ReAct workflow.

---

## 8. Small Diagram

### ReAct Loop for Dinner Planning

```text
User Request:
  "Plan a vegetarian dinner for four and
   tell me what to buy."

          ↓
      [Thought]
  "I should pick a recipe."
          ↓
      [Action]
   → search_recipes
          ↓
    [Observation]
   ← list of recipes
          ↓
      [Thought]
  "Now I should check ingredients
   against the pantry."
          ↓
      [Action]
   → check_pantry for each ingredient
          ↓
    [Observation]
   ← which items are missing
          ↓
      [Action]
   → add_to_shopping_list for missing items
          ↓
    [Observation]
   ← final shopping list
          ↓
      [Thought]
  "I have the menu and list."
          ↓
     [Final Answer]
   Menu + Shopping List
```

This is exactly what LangChain’s agent loop is doing,  
with Codex helping you write and maintain the code.

---

## 9. Summary

- **ReAct** = **Re**ason + **Act**:
  - the agent alternates between internal thoughts and external actions (tool calls),
  - using observations from tools to guide the next step.
- In LangChain, tool‑calling agents already implement a ReAct‑style loop via `AgentExecutor`:
  - Thought → Action → Observation → … → Final Answer.
- Our dinner example showed:
  - tools for recipes, pantry checks, and shopping lists,
  - a ReAct‑friendly prompt,
  - an agent that plans a vegetarian dinner and compiles what to buy.
- Codex helps you:
  - scaffold tools and agents,
  - instrument and log each ReAct step,
  - turn good runs into automated tests,
  - and refactor into more complex LangGraph workflows when needed.
- Thinking in ReAct terms makes agent behavior **more predictable, debuggable, and testable**, which fits naturally with backend engineering practices.

