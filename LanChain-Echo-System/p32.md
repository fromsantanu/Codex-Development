# **Chapter 32. Adding Authentication**

### 1. Simple Introduction

When we expose our agents and services as APIs, **not everyone should be able to call them**.
We need a way to check:

* *“Who is this caller?”*
* *“Are they allowed to use this service?”*

This checking is called **authentication**.

In this chapter we’ll look at:

* **API key** – a simple shared secret
* **JWT (JSON Web Token)** – a signed “entry pass” with user info
* **Simple safe logic** – how to check things without doing risky stuff

---

### 2. Real-Life Analogy

Think of a **secured office building**.

There are two common methods to let people in:

1. **Secret code at the gate** (like an API key)

   * Everyone in the team knows a single code.
   * Security guard lets you in if you tell the correct code.

2. **ID card with details** (like a JWT)

   * Each person has their own card.
   * Card has name, role, expiry date.
   * Machine checks if the card is valid and not expired.

In APIs:

* API Key → one shared secret string
* JWT → small signed object containing user info + expiry date

---

### 3. API Key – Simple and Useful

#### 3.1 What is an API key?

* A long secret string like: `sk_live_xxx` or `my-super-secret-key-123`.
* Sent by the client in **headers** or **query parameters**.
* Server checks: “Is this key correct?”
* If yes → request is allowed. If no → request is rejected.

#### 3.2 Where to use?

* Internal tools
* Simple services
* Low number of users
* When you don’t need per-user roles (just “authorized” vs “not authorized”).

#### 3.3 Storing the API key (safe)

* Put it in **.env** (not hard-coded in code).

```env
# .env
SERVICE_API_KEY=super-secret-api-key-123
```

* Load it in config:

```python
# config.py
from dotenv import load_dotenv
import os

load_dotenv()

SERVICE_API_KEY = os.getenv("SERVICE_API_KEY")
```

#### 3.4 Checking the API key in FastAPI

```python
# auth_api_key.py
from fastapi import Depends, HTTPException, Header, status
from config import SERVICE_API_KEY

async def verify_api_key(x_api_key: str = Header(None)):
    if x_api_key != SERVICE_API_KEY:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or missing API key",
        )
```

Use it in endpoint:

```python
from fastapi import FastAPI, Depends
from auth_api_key import verify_api_key

app = FastAPI()

@app.get("/protected-data")
async def protected_data(_: None = Depends(verify_api_key)):
    return {"message": "You are authorized!"}
```

Client must send:

```bash
curl -H "X-API-Key: super-secret-api-key-123" http://localhost:8000/protected-data
```

---

### 4. JWT – Signed “Entry Pass”

#### 4.1 What is a JWT?

JWT (JSON Web Token) is:

* A **small text token** given after login
* Signed by server using a **secret key**
* Contains data like:

  * user id
  * username
  * role (admin/user)
  * expiry time

It is like a **movie ticket**:

* It proves you paid
* It has show time (expiry)
* Ticket checker only needs to scan it, not ask again.

#### 4.2 Typical flow

1. User logs in: sends username + password to `/login`.
2. If login is correct, server creates a JWT and returns it.
3. Client stores token (in memory, session, etc).
4. For each next request, client sends:
   `Authorization: Bearer <token>`
5. Server checks:

   * Is token signed by me (using secret key)?
   * Is it expired?
   * What is user id/role?

If everything is ok → allow request.

#### 4.3 Simple JWT example with FastAPI

Install:

```bash
pip install pyjwt
```

Config:

```python
# config.py
from dotenv import load_dotenv
import os

load_dotenv()

JWT_SECRET = os.getenv("JWT_SECRET", "change-me-please")
JWT_ALGORITHM = "HS256"
JWT_EXPIRE_MINUTES = 60
```

Create and verify token:

```python
# auth_jwt.py
from datetime import datetime, timedelta
import jwt
from config import JWT_SECRET, JWT_ALGORITHM, JWT_EXPIRE_MINUTES

def create_token(user_id: int):
    expire = datetime.utcnow() + timedelta(minutes=JWT_EXPIRE_MINUTES)
    payload = {"sub": user_id, "exp": expire}
    token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)
    return token

def verify_token(token: str):
    payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
    return payload  # contains "sub" (user_id), "exp"
```

Login endpoint:

```python
# main.py
from fastapi import FastAPI, HTTPException, Depends
from fastapi.security import OAuth2PasswordBearer
from auth_jwt import create_token, verify_token

app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

# Dummy user check for example
def fake_verify_user(username: str, password: str):
    if username == "admin" and password == "secret":
        return 1  # user_id
    return None

@app.post("/login")
async def login(username: str, password: str):
    user_id = fake_verify_user(username, password)
    if not user_id:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_token(user_id)
    return {"access_token": token, "token_type": "bearer"}
```

Protected endpoint:

```python
@app.get("/me")
async def read_me(token: str = Depends(oauth2_scheme)):
    try:
        payload = verify_token(token)
        user_id = payload["sub"]
        return {"user_id": user_id}
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
```

Client:

```bash
# Step 1: Login
curl -X POST "http://localhost:8000/login" \
  -d "username=admin&password=secret"

# Step 2: Use returned token
curl -H "Authorization: Bearer <token_here>" http://localhost:8000/me
```

---

### 5. Simple Safe Logic – Best Practices

To keep things **simple and safe**:

1. **Never hard-code secrets**

   * Store API keys, JWT secret in `.env`, not in Git.

2. **Always check authentication for sensitive endpoints**

   * Don’t expose `/symptom-summary`, `/business-report`, etc., as open, public APIs.

3. **Use expiry for JWT**

   * Tokens should not last forever.
   * Example: 60 minutes or 1 day.

4. **Don’t store tokens in logs**

   * Avoid printing full JWT or API key in server logs.
   * If needed, mask them partially.

5. **Return clear, simple error messages**

   * `401 Unauthorized – Invalid or missing token`
   * `401 Unauthorized – Invalid API key`

6. **Role-based logic (slowly)**

   * Start simple: just “logged in or not”.
   * Later: add roles like `doctor`, `staff`, `admin` to JWT payload and check them.

---

### 6. Where This Fits with Agents and LangServe

When you expose agents through LangServe:

* Add **API key** or **JWT** checks in the FastAPI app.
* Example: symptom agent, report agent, or business workflow agent should only be callable by:

  * Frontend apps
  * Authorized microservices
  * Internal tools

Basic idea:

```text
Client → sends token/api-key → FastAPI + Auth → LangServe route → Agent
```

---

### 7. Simple Diagram

```text
          [ Client App ]
               |
   (API key / JWT in headers)
               |
               v
      [ FastAPI + Auth Check ]
         |           |
    (fail)          (pass)
    401             v
                 [ Agent ]
                    |
                 Response
```

---

### 8. Summary

* **API key** – one simple secret for basic protection.
* **JWT** – signed “entry pass” with user id + expiry, for logged-in users.
* Keep logic **simple and safe**:

  * No hard-coded secrets
  * Use expiry
  * Don’t log full tokens
  * Protected endpoints must always check auth

This way, your agent-based workflows behave more like **real, secure microservices** rather than open test scripts.


