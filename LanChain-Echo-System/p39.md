# **Chapter 39. Build a Full Real-Life Agentic System**

### **End-to-End Example: “Intelligent Report Generator Agent”**

This chapter ties everything together—
all the ideas you learned so far:

* LangChain
* LangGraph
* Codex
* Memory
* Tools
* RAG
* Deployment

We will build a full **Intelligent Report Generator Agent**
that can receive raw data, analyze it, create structured summaries, and produce a clean final report.

This is a complete *real-life*, production-style agent flow.

---

# **1. Simple Introduction**

Let’s imagine a real-world situation:

Your manager wants a weekly business report:

* Sales summary
* Customer issues
* Inventory risk
* Team updates

But collecting all this manually takes hours.

Our **Intelligent Report Generator Agent** will do:

1. Fetch data (from API, DB, or files)
2. Clean + analyze
3. Use LLM to summarize insights
4. Fetch related documents using RAG
5. Follow workflow steps using LangGraph
6. Combine everything into a structured PDF/Markdown
7. Deploy as an API using LangServe
8. Improve everything using Codex

This is exactly how companies build production AI systems today.

---

# **2. High-Level Workflow (Very Simple)**

```
User → Uploads data or asks for a report
          |
          v
   Intelligent Report Generator Agent
          |
   --------------------------------------
   |        |        |        |        |
 Fetch   Analyze   Summaries  RAG    Final
 Data     Data     (LLM)      Info    Report
          |                    |
          +----------Memory----+
          |
         Final output → PDF/JSON/Markdown
```

---

# **3. Core Components You Will Use**

| Part           | Purpose                                         |
| -------------- | ----------------------------------------------- |
| **LangChain**  | Tools, LLMs, prompts, chains                    |
| **LangGraph**  | Step-by-step workflow logic (agents + states)   |
| **Codex**      | Improving code, prompts, structure              |
| **Memory**     | Keep context across steps                       |
| **Tools**      | Fetch data, run calculations, access APIs       |
| **RAG**        | Retrieve relevant documents for deeper analysis |
| **Deployment** | Expose as API or microservice                   |

---

# **4. Step 1 – Tools Setup**

We define a few tools:

### **a. Fetch Sales Data (API tool)**

```python
async def sales_api_tool():
    data = await httpx.get("http://backend/sales")
    return data.json()
```

### **b. Simple Calculator Tool**

```python
def calc_tool(numbers: list):
    return {
        "total": sum(numbers),
        "average": sum(numbers)/len(numbers)
    }
```

### **c. Document Retriever (RAG)**

Using FAISS or Chroma as a vector DB:

```python
retriever = vectorstore.as_retriever(search_kwargs={"k": 5})
```

### **d. Codex for Code Generation / Cleanup**

Codex is used at development time:

* Generate functions
* Improve code
* Improve prompts
* Auto-refactor directory

Not used inside runtime agent.

---

# **5. Step 2 – LLM & Memory Setup**

### **LLM**

```python
from langchain_openai import ChatOpenAI

llm = ChatOpenAI(model="gpt-4o-mini")
```

### **Memory**

Use simple dictionary-like memory:

```python
from langchain.memory import ConversationBufferMemory

memory = ConversationBufferMemory()
```

This stores:

* Summaries
* Data results
* Intermediate insights

---

# **6. Step 3 – Build the Report Steps Using LangGraph**

LangGraph helps define steps like a flowchart:

### **State Definition**

```python
from langgraph.graph import StateGraph, END

class ReportState(TypedDict):
    sales_data: dict
    analysis: dict
    insights: str
    final_report: str
```

### **Graph Nodes**

#### **Node 1 – Fetch Data**

```python
async def fetch_data(state: ReportState):
    state["sales_data"] = await sales_api_tool()
    return state
```

#### **Node 2 – Analyze Numbers**

```python
def analyze_data(state: ReportState):
    numbers = [x["amount"] for x in state["sales_data"]]
    stats = calc_tool(numbers)
    state["analysis"] = stats
    return state
```

#### **Node 3 – Generate Insights (LLM)**

```python
async def generate_insights(state: ReportState):
    prompt = f"""
    Sales numbers: {state["sales_data"]}
    Analysis: {state["analysis"]}

    Give 5 key insights in bullet points.
    """
    result = await llm.ainvoke(prompt)
    state["insights"] = result.content
    return state
```

#### **Node 4 – Retrieve Extra Info (RAG)**

```python
async def rag_step(state: ReportState):
    docs = retriever.get_relevant_documents("sales risk factors")
    joined = "\n".join([d.page_content for d in docs])
    state["rag_info"] = joined
    return state
```

#### **Node 5 – Final Report (LLM)**

```python
async def build_report(state: ReportState):
    prompt = f"""
    Create a full weekly sales report.

    Sections:
    - Analysis numbers
    - Key insights
    - RAG-based context

    Data:
    {state["analysis"]}
    {state["insights"]}
    {state["rag_info"]}

    Output in clean Markdown.
    """

    result = await llm.ainvoke(prompt)
    state["final_report"] = result.content
    return state
```

---

# **7. Step 4 – Build the LangGraph Workflow**

```python
graph = StateGraph(ReportState)
graph.add_node("fetch", fetch_data)
graph.add_node("analyze", analyze_data)
graph.add_node("insights", generate_insights)
graph.add_node("rag", rag_step)
graph.add_node("final", build_report)

graph.set_entry_point("fetch")

graph.add_edge("fetch", "analyze")
graph.add_edge("analyze", "insights")
graph.add_edge("insights", "rag")
graph.add_edge("rag", "final")
graph.add_edge("final", END)

report_app = graph.compile()
```

---

# **8. Step 5 – Expose as an API Using LangServe**

### **Server Code**

```python
from fastapi import FastAPI
from langserve import add_routes

app = FastAPI()

async def run_report():
    result = await report_app.invoke({})
    return result["final_report"]

add_routes(app, run_report, path="/weekly-report")
```

Run:

```bash
uvicorn server:app --port 8000 --reload
```

---

# **9. Step 6 – Deployment via Docker**

### Dockerfile

```dockerfile
FROM python:3.11-slim
WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000
CMD ["uvicorn", "server:app", "--host", "0.0.0.0", "--port", "8000"]
```

Build & run:

```bash
docker build -t report-agent .
docker run -p 8000:8000 report-agent
```

---

# **10. Step 7 – Improving Prompt & Code with Codex**

Ask Codex:

```
Refactor the workflow for clarity.
Clean node functions.
Improve prompt consistency.
Ensure stable output format.
Add input validation.
Add better error handling.
```

Codex can:

* Suggest a cleaner directory
* Merge duplicate logic
* Improve your prompts
* Add docstrings
* Automatically generate tests
* Improve RAG prompt quality

This makes the system production-ready.

---

# **11. Full Architecture Overview**

```
                +-------------------------+
                |  Frontend (Streamlit)   |
                +-----------+-------------+
                            |
                            v
                    /weekly-report API
                            |
                     [LangServe + FastAPI]
                            |
                    Intelligent Report Agent
                            |
    ----------------------------------------------------
    |                 |               |                |
Fetch Data        Analyze         LLM Insights        RAG
(API/DB)         (Tool)           (LangChain)       (Vector DB)
    |                 |               |                |
    ----------------------------------------------------
                            |
                     Final Report (MD/PDF)
```

---

# **12. Final Output Example (Markdown)**

```
# Weekly Sales Report

## Summary
- Total sales: ₹4,52,000
- Average order: ₹1,543
- Week-on-week growth: +8%

## Key Insights
- Sales increased mainly in clothing category.
- Highest demand during weekends.
- Repeat customers contributed 35% of revenue.
- Stockout risk for “Blue Shirt” line.
- Online channel outperformed offline stores.

## Additional Context (RAG-Based)
- Similar products show seasonal peaks.
- Suggest monitoring vendor delays.
```

---

# **13. Summary**

You now built a **full agentic system** combining all powerful concepts:

### ✔ LangChain — LLM, tools, prompts, memory

### ✔ LangGraph — Workflow engine

### ✔ RAG — Document retrieval

### ✔ Tools — APIs, calculator, analysis modules

### ✔ Memory — Store and reuse context

### ✔ Codex — Refactor + improve code

### ✔ Deployment — FastAPI + LangServe + Docker

This is exactly how real AI products are built in modern companies.

---

