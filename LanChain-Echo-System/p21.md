# 21. Designing the Agent Workflow Blueprint

## 1. Introduction

When you build an agent system, it is tempting to:

- jump straight into coding tools,
- wire them to an LLM,
- and hope the behavior “emerges”.

That usually leads to:

- confusing control flow,
- prompts that keep growing,
- and agents that are hard to debug.

Designing an **agent workflow blueprint** means:

- planning the **steps** before coding,
- deciding **which agent or tool** does what,
- mapping **inputs, outputs, and decisions**,
- and drawing a simple **flow diagram** you can implement later.

This chapter shows how to design that blueprint in a way that feels natural for backend developers.

---

## 2. Why Backend Developers Should Care

As a backend developer, you already:

- design **API flows** (auth → validation → business logic → DB),
- draw **sequence diagrams** or **flowcharts**,
- model **workflows** in tools like BPMN or custom code,
- think about **error paths** and **edge cases**.

Agent workflows are the same idea, but with:

- LLM calls and tools instead of just functions,
- decisions made partly by the model,
- memory and state that live across steps.

A clear blueprint helps you:

- avoid a **“giant ball of prompts”**,
- keep responsibilities **separated** (tools vs agents vs orchestrator),
- reason about **cost and latency** per step,
- and make it easy to add **monitoring and tests** later.

If you treat the agent workflow like an **API design problem**, the rest becomes much easier.

---

## 3. Real-life Analogy

Imagine planning a **restaurant kitchen workflow**:

- Customers send **orders**.
- The order goes through **stations**:
  - grill,
  - salad,
  - dessert,
  - plating.
- There is a **ticket board** that tracks:
  - what’s being cooked,
  - special requests,
  - status of each dish.
- The **chef** decides:
  - which station works next,
  - when to speed up,
  - when to remake a dish.

Before opening the restaurant, you would:

- design the **kitchen layout**,
- define **who does what**,
- agree on the **sequence of steps** for each type of order.

The agent workflow blueprint is the same:

- tickets = user requests,
- stations = tools/agents,
- board = workflow state,
- head chef = orchestrator or graph.

You want this blueprint on paper before you start cooking.

---

## 4. Key Concepts

Here are the key pieces of an agent workflow blueprint, expressed in backend-friendly terms.

- **Goal**
  - What the workflow should accomplish end-to-end.
  - Example: “Generate a sales report and email it to the manager.”

- **Inputs**
  - What data is required to start:
    - user question,
    - IDs,
    - external configs.

- **Outputs**
  - The final artifacts:
    - answer text,
    - report file,
    - database updates,
    - emails sent.

- **Stages / Steps**
  - Logical phases the workflow goes through.
  - Example:
    - “Collect requirements,”
    - “Fetch data,”
    - “Analyze,”
    - “Draft output,”
    - “Review,”
    - “Send.”

- **Actors**
  - Who performs each step:
    - LLM-only chain,
    - tool,
    - agent with tools,
    - human reviewer.

- **State**
  - Shared context object that travels through steps.
  - Holds:
    - original input,
    - intermediate results,
    - decisions,
    - errors.

- **Decisions / Branches**
  - Points where the workflow can go down different paths, such as:
    - “Is user authorized?”
    - “Is data complete?”
    - “Did human approve?”

- **Failure and Recovery**
  - What happens when:
    - a tool fails,
    - data is missing,
    - user input is unclear.
  - Decide:
    - retry,
    - ask user for clarification,
    - log and stop.

This is the “blueprint vocabulary” you will use to describe your agent workflow before touching code.

---

## 5. Steps Explained Simply

Here is a simple process you can follow to design an agent workflow blueprint.

### Step 1: Write a One-sentence Goal

Force yourself to write the goal in one, clear sentence, for example:

- “Given a plain-English question, create a SQL report and email a readable summary to the requester.”

This keeps the rest of the design focused.

### Step 2: List Inputs and Outputs

Write down:

- Inputs:
  - user question,
  - user email,
  - allowed database connections.
- Outputs:
  - final email body,
  - executed SQL query string,
  - result summary table.

If it is not in inputs or outputs, it probably belongs in **state**.

### Step 3: Break the Work into Stages

Describe the process in **plain verbs**, not LLM terms:

1. Understand what the user wants.
2. Check if the user is allowed to run this query.
3. Translate the request into a safe SQL query.
4. Run the query and collect results.
5. Summarize the results in plain language.
6. Draft and send an email.

Each line can become one or more **nodes** in your eventual graph.

### Step 4: Assign Actors to Each Stage

For each stage, decide **who** should do it:

- LLM chain with no tools,
- agent with tools,
- pure Python / API call,
- human in the loop.

For example:

- Stage 1: “Understand request” → LLM chain.
- Stage 2: “Check permissions” → Python function + DB.
- Stage 3: “Translate to SQL” → agent with SQL tool.
- Stage 4: “Run query” → tool only.
- Stage 5–6: “Summarize + email” → LLM + email tool.

This separation is what makes the blueprint **implementable**.

### Step 5: Define the State Shape

Create a simple dict or type that can hold everything:

```python
state = {
    "user_id": "",
    "user_email": "",
    "question": "",
    "permissions_ok": False,
    "sql_query": "",
    "raw_results": None,
    "summary_text": "",
    "email_status": "",
}
```

Every step:

- reads some keys,
- writes other keys.

If a step needs new data, you add a new field to `state`.

### Step 6: Mark Decisions and Branches

Identify where the path can change, for example:

- If `permissions_ok` is `False`:
  - skip SQL parts,
  - send a “not allowed” email.
- If `raw_results` is empty:
  - send a “no data found” message.

Write these decisions in plain language; they will later become:

- `if` statements,
- or conditional edges in a graph.

### Step 7: Draw a Simple Flow Diagram

Turn the stages and decisions into a small diagram, for example:

```
[Start]
  ↓
[Understand Request]
  ↓
[Check Permissions] → [Not Allowed Email] → [End]
  ↓ (ok)
[Build SQL] → [Run SQL] → [Summarize] → [Send Email] → [End]
```

This diagram is your **blueprint**.  
You can now hand it to another developer or to Codex and say, “Please implement this.”

---

## 6. Short Code Examples

Here is how you might capture the blueprint in Python structures that are easy to extend later (for example into LangGraph).

### Example 1: Represent the Blueprint with Dataclasses

```python
from dataclasses import dataclass, field
from typing import Callable, Dict, List, Optional


@dataclass
class Step:
    name: str
    run: Callable[[Dict], Dict]
    next_step: Optional[str] = None
    # Optionally, name of a decision function for branching
    decision: Optional[Callable[[Dict], str]] = None


@dataclass
class WorkflowBlueprint:
    name: str
    steps: Dict[str, Step] = field(default_factory=dict)
    entry_step: str = ""
```

This is a simple way to:

- give each step a **name**,
- attach a **function** that mutates state,
- specify what step comes next,
- optionally plug in a **decision function** that chooses the next step.

### Example 2: Define Concrete Steps for a Reporting Agent

```python
def understand_request(state: Dict) -> Dict:
    # Later, call an LLM chain here.
    question = state.get("question", "")
    state["normalized_request"] = question.strip()
    return state


def check_permissions(state: Dict) -> Dict:
    # Later, call your auth DB or service.
    user_id = state.get("user_id")
    state["permissions_ok"] = bool(user_id)
    return state


def decide_after_permissions(state: Dict) -> str:
    return "not_allowed" if not state.get("permissions_ok") else "build_sql"
```

```python
def build_sql(state: Dict) -> Dict:
    # Placeholder; real version would be an agent with tools.
    request = state.get("normalized_request", "")
    state["sql_query"] = f"-- SQL based on: {request}"
    return state


def run_sql(state: Dict) -> Dict:
    # Replace with real DB call.
    state["raw_results"] = [{"column": "value"}]
    return state


def summarize_results(state: Dict) -> Dict:
    results = state.get("raw_results") or []
    state["summary_text"] = f"Found {len(results)} rows."
    return state


def send_email(state: Dict) -> Dict:
    # Later, call an email tool or service.
    state["email_status"] = "sent"
    return state


def send_not_allowed(state: Dict) -> Dict:
    state["email_status"] = "not_allowed_notice_sent"
    return state
```

### Example 3: Assemble and Run the Blueprint

```python
def build_reporting_blueprint() -> WorkflowBlueprint:
    steps = {
        "understand_request": Step(
            name="understand_request",
            run=understand_request,
            next_step="check_permissions",
        ),
        "check_permissions": Step(
            name="check_permissions",
            run=check_permissions,
            decision=decide_after_permissions,
        ),
        "build_sql": Step(
            name="build_sql",
            run=build_sql,
            next_step="run_sql",
        ),
        "run_sql": Step(
            name="run_sql",
            run=run_sql,
            next_step="summarize_results",
        ),
        "summarize_results": Step(
            name="summarize_results",
            run=summarize_results,
            next_step="send_email",
        ),
        "send_email": Step(
            name="send_email",
            run=send_email,
        ),
        "not_allowed": Step(
            name="not_allowed",
            run=send_not_allowed,
        ),
    }

    return WorkflowBlueprint(
        name="reporting_workflow",
        steps=steps,
        entry_step="understand_request",
    )
```

```python
def run_blueprint(blueprint: WorkflowBlueprint, initial_state: Dict) -> Dict:
    state = dict(initial_state)
    current_name = blueprint.entry_step

    while current_name:
        step = blueprint.steps[current_name]
        state = step.run(state)

        if step.decision is not None:
            current_name = step.decision(state)
        else:
            current_name = step.next_step

    return state
```

This runner is intentionally simple:

- it uses only Python dicts and functions,
- it behaves like a tiny workflow engine,
- it mirrors the blueprint you sketched on paper.

Later, you can convert this structure into **LangGraph nodes and edges**, but the planning step stays the same.

---

## 7. How Codex Helps

Codex is very good at turning an informal idea into a **concrete workflow blueprint** and then into code.

You can ask Codex to:

- **Extract stages from a description**
  - “Given this paragraph describing a reporting assistant, list the workflow stages, inputs, outputs, and decisions.”

- **Turn a diagram into code**
  - “Here is a text diagram of my agent workflow. Create a Python blueprint structure with functions for each step.”

- **Propose state shape**
  - “Suggest a `TypedDict` for the shared state in this workflow, based on the steps and tools.”

- **Refine responsibilities**
  - “Split this large step into two: one that prepares the query, and one that executes it. Update the blueprint accordingly.”

- **Upgrade to LangGraph**
  - “Convert this custom blueprint runner into a LangGraph `StateGraph` with equivalent nodes and transitions.”

Codex can keep the **design in sync with the implementation**, so your blueprint never drifts too far from the running code.

---

## 8. Small Diagram

### Agent Workflow Blueprint for a Reporting Assistant

```text
         [Start]
            ↓
   [Understand Request]
            ↓
   [Check Permissions] ── no ──→ [Send Not Allowed Email] → [End]
            │
           yes
            ↓
        [Build SQL]
            ↓
         [Run SQL]
            ↓
    [Summarize Results]
            ↓
        [Send Email]
            ↓
           [End]
```

### State as a Shared “Ticket”

```text
state = {
  user_id,
  user_email,
  question,
  permissions_ok,
  sql_query,
  raw_results,
  summary_text,
  email_status,
}

Each step reads/writes a few fields,
but the ticket (state) stays the same.
```

---

## 9. Summary

- An agent workflow blueprint is a **plan** of steps, actors, state, and decisions, designed before implementation.
- Backend developers can treat agent workflows like **API or workflow designs**, with clear inputs, outputs, and branches.
- The key building blocks are **goal, inputs, outputs, stages, actors, state, and decisions**.
- You can represent the blueprint in simple Python structures, then later move to tools like **LangGraph**.
- Codex can help generate and refine the blueprint, propose state shapes, and translate your diagrams into clean, maintainable code.

