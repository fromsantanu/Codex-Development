# 22. Building the Workflow with LangGraph

## 1. Introduction

Once you have an idea of **how your agent workflow should look**, the next step is to turn that plan into **running code**.

LangGraph is a small library that lets you:

- describe your workflow as a **graph of steps**,
- pass a shared **state object** between steps,
- define **transitions** (which step runs next),
- and add **error handling and recovery** in a structured way.

Instead of a long function full of `if` statements, you get:

- small, focused node functions,
- clear edges between them,
- and a compiled graph you can call from your backend.

---

## 2. Why Backend Developers Should Care

If you’ve ever:

- written a complex request handler that calls many services,
- implemented a custom workflow engine with status fields,
- or drawn a flowchart for business processes,

then LangGraph will feel familiar.

It gives you:

- a **type-safe state object** instead of random dicts,
- explicit **nodes and edges** instead of hidden control flow,
- **checkpoints** so you can pause and resume,
- and a clean way to plug in **LLMs, tools, and APIs** at each step.

You keep using normal backend skills (Python, HTTP, DBs),  
but you gain a clear way to express “how the agent should move through the workflow”.

---

## 3. Real-life Analogy

Think of a **subway map**:

- each station is a **node**,
- tracks between stations are **edges**,
- your ticket / route is the **state**,
- the transit rules decide **where you can go next**.

You can:

- start at a station (entry node),
- move along lines following rules (transitions),
- switch lines (branching),
- reach your destination (end node),
- or get rerouted if there’s a problem (error handling).

LangGraph is like writing this subway map **in code** for your agent workflow:

- stations = steps like “Validate Input”, “Call Tool”, “Summarize Result”,
- ticket = context structure passed between steps,
- rules = edges and conditions,
- control center = checkpointing and recovery logic.

---

## 4. Key Concepts

Here are the core LangGraph concepts in backend-friendly terms.

- **State**
  - A structured object (often a `TypedDict`) that holds:
    - user input,
    - intermediate data,
    - flags and decisions,
    - errors and status.
  - Every node receives and returns this state.

- **Node**
  - A regular Python function (or agent) that:
    - takes the current state,
    - does some work (LLM call, tool call, DB query),
    - returns an updated state.
  - You register each node by name in the graph.

- **Edge**
  - A connection from one node to another:
    - fixed edge: always go A → B,
    - conditional edge: go A → B or A → C depending on state.
  - Edges define the **control flow** of the workflow.

- **Entry and End**
  - Entry node = where the graph starts.
  - `END` = special target that means “workflow is finished”.

- **StateGraph**
  - The builder object you use to:
    - declare the state type,
    - add nodes,
    - wire edges,
    - set entry / end points.
  - When you call `compile`, you get a **runnable graph**.

- **Checkpointer**
  - A storage layer for state:
    - in memory (for demos),
    - or a DB (for production).
  - Lets you:
    - pause and resume workflows,
    - handle long-running flows,
    - recover after failures.

- **Transitions and Recovery**
  - Transitions decide what node runs next.
  - Recovery patterns:
    - retry a node,
    - skip to a fallback node,
    - mark an error field in state and end gracefully.

---

## 5. Steps Explained Simply

Here is a simple process to build a workflow with LangGraph.

### Step 1: Define Your State Type

Create a `TypedDict` that lists all the fields your workflow might use, for example:

- user request,
- validation status,
- tool results,
- final answer,
- error message (if any).

This acts like a **shared ticket** that all nodes read and write.

### Step 2: Implement Node Functions

For each step in your workflow:

- write a small function that:
  - accepts the state,
  - does its work,
  - returns the updated state.

Nodes should be:

- focused on one responsibility,
- easy to test in isolation,
- free of global variables.

### Step 3: Create the StateGraph

Use `StateGraph` to:

- register your state type,
- add each node with a unique name,
- set the entry node.

This is like defining the list of stations and choosing where the train line starts.

### Step 4: Add Edges and Branching

Connect nodes with:

- simple edges (`add_edge("a", "b")`) for straight-line flows,
- conditional edges (`add_conditional_edges`) for branching based on state.

Write small decision functions that:

- read from state,
- return the name of the next node.

### Step 5: Plug in a Checkpointer

Choose a checkpointer:

- `MemorySaver` for local testing,
- a DB-backed checkpointer for production.

Pass it to `compile` so that:

- each time the graph runs,
- state is saved under a **thread id** or similar key,
- and the workflow can be resumed later.

### Step 6: Invoke the Graph from Your Backend

From your API or job handler:

- build an initial state dict,
- call `graph.invoke(state, config=...)`,
- or stream steps with `graph.stream(...)` if you want partial outputs.

Use:

- the state’s final fields (e.g. `final_answer`, `error`) to decide what to return,
- your normal logging / metrics tools for observability.

---

## 6. Short Code Examples

Below is a small example: a LangGraph workflow that:

- validates a user question,
- optionally asks for clarification,
- calls a dummy “business logic” node,
- and handles errors in a structured way.

### Example 1: Define State and Nodes

```python
# graph/workflow_state.py
from typing import TypedDict, Literal, Optional, List


class WorkflowState(TypedDict, total=False):
    user_id: str
    question: str
    clarified_question: str
    validation_status: Literal["ok", "needs_clarification", "invalid"]
    clarification_questions: List[str]
    answer: str
    error: Optional[str]
```

```python
# graph/workflow_nodes.py
from langchain_openai import ChatOpenAI

from .workflow_state import WorkflowState


llm = ChatOpenAI(model="gpt-4.1-mini")


def validate_question(state: WorkflowState) -> WorkflowState:
    """Decide if the question is clear enough."""
    question = state.get("question", "")
    if not question.strip():
        state["validation_status"] = "invalid"
        state["error"] = "Empty question."
        return state

    prompt = (
        "Decide if this question is clear. "
        "Reply with 'ok' or 'needs_clarification'.\n\n"
        f"{question}"
    )
    result = llm.invoke(prompt).content.strip().lower()
    state["validation_status"] = "ok" if "ok" in result else "needs_clarification"
    return state


def ask_for_clarification(state: WorkflowState) -> WorkflowState:
    """Generate follow-up questions to clarify the request."""
    question = state.get("question", "")
    prompt = (
        "The user's question is unclear. Ask 1-2 short follow-up "
        "questions to clarify it.\n\n"
        f"Original question: {question}"
    )
    followup = llm.invoke(prompt).content
    state["clarification_questions"] = [followup]
    return state


def run_business_logic(state: WorkflowState) -> WorkflowState:
    """Placeholder for tools/DB calls + summary."""
    clarified = state.get("clarified_question") or state.get("question", "")
    state["answer"] = f"(Demo answer based on: {clarified})"
    return state
```

### Example 2: Branching Logic and Graph Construction

```python
# graph/workflow_graph.py
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver

from .workflow_state import WorkflowState
from .workflow_nodes import (
    validate_question,
    ask_for_clarification,
    run_business_logic,
)


def after_validation(state: WorkflowState) -> str:
    status = state.get("validation_status")
    if status == "ok":
        return "run_business_logic"
    if status == "needs_clarification":
        return "ask_for_clarification"
    # anything else: treat as error and end
    return "end_with_error"


def end_with_error(state: WorkflowState) -> WorkflowState:
    # could map internal errors to user-friendly messages here
    if "error" not in state:
        state["error"] = "Unknown validation error."
    return state


def build_workflow_graph():
    builder = StateGraph(WorkflowState)

    builder.add_node("validate_question", validate_question)
    builder.add_node("ask_for_clarification", ask_for_clarification)
    builder.add_node("run_business_logic", run_business_logic)
    builder.add_node("end_with_error", end_with_error)

    builder.set_entry_point("validate_question")

    # Branching after validation
    builder.add_conditional_edges(
        "validate_question",
        after_validation,
        {
            "run_business_logic": "run_business_logic",
            "ask_for_clarification": "ask_for_clarification",
            "end_with_error": "end_with_error",
        },
    )

    # Normal forward edges
    builder.add_edge("ask_for_clarification", END)
    builder.add_edge("run_business_logic", END)
    builder.add_edge("end_with_error", END)

    memory = MemorySaver()
    return builder.compile(checkpointer=memory)
```

### Example 3: Using the Graph in Your App

```python
# app/workflow_entry.py
from graph.workflow_graph import build_workflow_graph


graph = build_workflow_graph()


def handle_user_request(user_id: str, question: str) -> dict:
    state = {
        "user_id": user_id,
        "question": question,
    }
    config = {"configurable": {"thread_id": user_id}}

    result = graph.invoke(state, config=config)

    if result.get("error"):
        return {"status": "error", "message": result["error"]}

    if "clarification_questions" in result:
        return {
            "status": "needs_clarification",
            "questions": result["clarification_questions"],
        }

    return {"status": "ok", "answer": result.get("answer", "")}
```

This pattern:

- keeps the **workflow logic in LangGraph**,
- lets your backend handler stay small and clear,
- makes it easy to add new nodes and transitions later.

---

## 7. How Codex Helps

Codex can automate much of the tedious work of wiring LangGraph:

- **From description to graph**
  - “Given this text description of my workflow, create a `WorkflowState`, node functions, and a `StateGraph` with nodes and edges.”

- **Refactor existing code into nodes**
  - “Split this large function into separate node functions and assemble them into a LangGraph.”

- **Add branching and error handling**
  - “Add conditional edges based on `validation_status`, plus an `end_with_error` node that maps internal errors to user-facing messages.”

- **Introduce persistence**
  - “Replace `MemorySaver` with a Postgres-backed checkpointer and show how to configure `thread_id` and retention.”

- **Generate tests**
  - “Write pytest tests that call the graph with different `question` values and assert the state transitions.”

By letting Codex handle boilerplate, you can focus on the **design of the workflow** and the **semantics of each step**, instead of the wiring.

---

## 8. Small Diagram

### LangGraph Workflow Example

```text
        [Start]
           ↓
  ┌─────────────────┐
  │ validate_question│
  └─────────────────┘
      ↓        ↓        ↓
     ok   needs_clar.  invalid
      ↓        ↓        ↓
┌─────────────────┐  ┌───────────────┐
│run_business_logic│ │end_with_error │
└─────────────────┘  └───────────────┘
      ↓
   [END]
```

### Shared State in the Middle

```text
        ┌───────────────┐
        │ WorkflowState │
        │ question      │
        │ status        │
        │ answer/error  │
        └───────────────┘
          ↑     ↑     ↑
          │     │     │
validate_question  run_business_logic
     ask_for_clarification  end_with_error
```

Each node:

- receives the same state object,
- updates some fields,
- passes it to the next node along the edge.

---

## 9. Summary

- LangGraph lets you turn an agent workflow into a **graph** of nodes and edges with a shared state object.
- You define a **state type**, implement small **node functions**, and wire them with **transitions** (including branching).
- Checkpointers give you **pause/resume** and **recovery**, which is essential for real-world agent systems.
- Your backend can treat the compiled graph as a **normal component**: pass in state, get back results, and decide what to return.
- Codex helps you design and implement these workflows quickly by generating state types, nodes, graphs, and tests from natural-language descriptions.

